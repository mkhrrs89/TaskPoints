<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TaskPoints — Game</title>

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="TaskPoints" />

  <!-- Simple TP icon -->
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256'><rect width='256' height='256' fill='%230b0d10'/><text x='128' y='160' text-anchor='middle' font-size='150' fill='white'>TP</text></svg>">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='48' fill='%230b0d10'/><text x='50' y='62' font-size='60' text-anchor='middle' fill='white'>TP</text></svg>">

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="scoring_core.js"></script>
<link rel="stylesheet" href="styles.css">
<script src="toolbar.js" defer></script>

  <style>
    body{
      background:#fafafa;
      color:#111827;
    }
    @media (prefers-color-scheme: dark) {
      body{
        background:#0a0a0a;
        color:#fafafa;
      }
    }

/* MOBILE ONLY: 2-column player cards in Card View */
@media (max-width: 640px) {
  #playersList.card-view,
  .players-grid.card-view {
    grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
  }

  #playersList.gallery-view,
  .players-grid.gallery-view {
    grid-template-columns: repeat(var(--gallery-cols, 2), minmax(0, 1fr));
  }
}

@media (max-width: 640px) and (orientation: landscape) {
  #playersList.gallery-view,
  .players-grid.gallery-view {
    grid-template-columns: repeat(var(--gallery-cols-landscape, 3), minmax(0, 1fr));
  }
}

.player-group {
  border: 1px solid rgba(113, 113, 122, 0.4);
  border-radius: 16px;
  padding: 12px;
  background: rgba(244, 244, 245, 0.7);
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.02);
}

.player-group-title {
  font-size: 0.7rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  font-weight: 600;
  color: rgba(63, 63, 70, 0.8);
}

@media (prefers-color-scheme: dark) {
  .player-group {
    background: rgba(24, 24, 27, 0.7);
    border-color: rgba(63, 63, 70, 0.8);
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.04);
  }

  .player-group-title {
    color: rgba(228, 228, 231, 0.7);
  }
}


.player-img-frame {
  border-radius: 0;
  padding: 8px;
  background: linear-gradient(to bottom, #f4f4f5, #71717a);
  margin: -6px -6px 8px;
}


.player-img-inner {
  background: #000;
  width: 100%;
  height: 100%;
  overflow: hidden;

  padding: 3px; 
  border-radius: 0;

}

/* extra safety: make sure the image itself never gets rounded */
.player-img-inner > img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 0;
  display: block;
}

/* Desktop & mobile: hide content + rotate chevron when collapsed */
.mobile-collapsible[data-collapsed="true"] .mobile-collapsible-body {
  display: none;
}

.mobile-collapsible[data-collapsed="true"] .mobile-collapsible-chevron {
  transform: rotate(-90deg);
}


/* Mobile tweaks */
@media (max-width: 640px) {
  /* 2-column card view grid on mobile */
  #playersList.card-view,
  .players-grid.card-view {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  /* Collapsible cards (Create Player + Stats Guide) */
  .mobile-collapsible-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
    width: 100%;
    padding: 0;
    border: 0;
    background: transparent;
    color: inherit;
    font: inherit;
    text-align: left;
    cursor: pointer;
  }

  .mobile-collapsible-header h2 {
    margin-bottom: 0;
  }

  .mobile-collapsible-body {
    margin-top: 0.5rem;
  }



  .mobile-collapsible[data-collapsed="true"] .mobile-collapsible-body {
    display: none;
  }

  .mobile-collapsible-chevron {
    font-size: 0.8rem;
    opacity: 0.7;
    transition: transform 0.2s ease;
  }

  .mobile-collapsible[data-collapsed="true"] .mobile-collapsible-chevron {
    transform: rotate(-90deg);
  }
}



    .card{
      border:1px solid rgb(228 228 231);
      background:rgba(255,255,255,0.85);
      border-radius:16px;
      padding:16px;
      box-shadow:0 10px 30px rgba(0,0,0,0.12);
      backdrop-filter:blur(10px);
    }
    @media (prefers-color-scheme: dark) {
      .card{
        border-color:rgb(39 39 42);
        background:rgba(24,24,27,0.9);
      }
    }

    .scrollbar-thin{
      scrollbar-width:thin;
    }
    .scrollbar-thin::-webkit-scrollbar{
      height:6px;
      width:6px;
    }
    .scrollbar-thin::-webkit-scrollbar-thumb{
      background:rgba(148,163,184,0.8);
      border-radius:999px;
    }

/* Fix Create Player inputs in new split layout */
.create-player input,
.create-player textarea,
.create-player select {
  max-width: 100%;
}

.record-badge{
  border-radius:999px;
  padding:1px 8px;
  font-size:11px;
  display:inline-flex;
  align-items:center;
  gap:3px;
}


.btn-toolbar{
  padding:6px 8px;
  font-size:11px;
  border-radius:999px;
}

    /* Make form fields readable in both light & dark */
    input, select, textarea{
      background: rgba(255,255,255,0.95);
      color:#111827;
    }
    @media (prefers-color-scheme: dark) {
      input, select, textarea{
        background: rgba(39,39,42,0.95);
        color:#fafafa;
      }
    }
  </style>
</head>
<body class="min-h-screen">
  <div class="mx-auto max-w-6xl p-4 sm:p-6">

    <div class="flex items-center justify-between gap-3 mb-3 md:hidden">
      <a href="index.html" class="flex items-center gap-3">
        <img src="assets/taskpoints-logo.png" alt="TaskPoints logo" class="w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm">
        <h1 class="text-2xl font-extrabold tracking-tight leading-tight">
          <span style="color:#fb923c;">Task</span><span style="color:#1e666d;">Points</span>
        </h1>
      </a>
      <div class="flex items-center gap-2">
        <button type="button" class="btn btn-ghost btn-toolbar" data-export-button>Export</button>
        <label class="btn btn-ghost btn-toolbar cursor-pointer">
          <span>Import</span>
          <input type="file" accept="application/json" class="hidden" data-import-input/>
        </label>
      </div>
    </div>

    <!-- Header / nav -->
    <header class="flex flex-wrap items-center justify-between gap-3 mb-4">
      <a href="index.html" class="hidden md:flex items-center gap-3">
        <img src="assets/taskpoints-logo.svg" alt="TaskPoints logo" class="w-9 h-9 rounded-2xl object-cover shadow-sm">
        <div>
          <h1 class="text-2xl sm:text-3xl font-extrabold tracking-tight">TaskPoints</h1>
        </div>
      </a>
      <div class="toolbar header-nav">
        <a href="index.html"         class="btn btn-teal btn-toolbar nav-btn">Main</a>
        <a href="today.html" class="btn btn-teal btn-toolbar nav-btn">Today</a>
        <a href="daily_sources.html" class="btn btn-teal btn-toolbar nav-btn">Sources</a>
        <a href="log.html"           class="btn btn-teal btn-toolbar nav-btn">Log</a>
        <a href="week.html"          class="btn btn-teal btn-toolbar nav-btn">Week</a>
        <div class="dropdown">
          <button type="button" class="btn btn-teal btn-toolbar nav-btn dropdown-toggle active" data-dropdown-toggle aria-expanded="false">Game <span class="caret">▾</span></button>
          <div class="dropdown-menu">
            <a href="gamehub.html" class="btn btn-teal btn-toolbar nav-btn">Game Hub</a>
            <a href="game.html"         class="btn btn-teal btn-toolbar nav-btn active" aria-current="page">Players</a>
            <a href="standings.html"    class="btn btn-teal btn-toolbar nav-btn">Standings</a>
            <a href="matchups.html"     class="btn btn-teal btn-toolbar nav-btn">Matchups</a>
            <a href="schedule.html"     class="btn btn-teal btn-toolbar nav-btn">Schedule</a>
            <a href="game_ratings.html" class="btn btn-teal btn-toolbar nav-btn">Ratings</a>
            <a href="records.html"      class="btn btn-teal btn-toolbar nav-btn">Records</a>
          </div>
        </div>
        <a href="projects.html" class="btn btn-teal btn-toolbar nav-btn">Projects</a>
        <a href="settings.html" class="btn btn-teal btn-toolbar nav-btn">Settings</a>
      </div>

    </header>

<!-- Player Stats Guide -->
<section id="playerStatsGuide" class="card mb-6 mobile-collapsible" data-collapsed="false">
  <button type="button" class="mobile-collapsible-header">
    <h2 class="font-semibold text-lg mb-2">Player Stats Guide</h2>
    <span class="mobile-collapsible-chevron">▾</span>
  </button>

  <div class="mobile-collapsible-body">
    <ul class="text-sm space-y-2">
      <li><strong>Baseline Δ</strong>: Difference between a player’s average score and their baseline (positive = above baseline).</li>
      <li><strong>PPD</strong>: Points per day in the TaskPoints app (includes habits, flex actions, sleep, etc.).</li>
      <li><strong>Baseline</strong>: Their “default” nightly performance.</li>
      <li><strong>Variance</strong>: How swingy they are night-to-night.</li>
      <li><strong>Momentum</strong>: How much recent good/bad nights affect next game.</li>
      <li><strong>Risky</strong>: How much they chase boom-or-bust lines.</li>
      <li><strong>Variance Tilt</strong>: What % of their swings land <em>above</em> baseline (0% = always below, 100% = always above).</li>
      <li><strong>Style</strong>: Just flavor text for now (can inform future sim tweaks).</li>
    </ul>
  </div>
</section>


<div class="grid gap-6 md:grid-cols-2 mb-6">

<!-- LEFT: Create player -->
<section class="card mb-6 mobile-collapsible" data-collapsed="false">
  <button type="button" class="mobile-collapsible-header">
    <h2 class="font-semibold text-lg mb-2">Create Player</h2>
    <span class="mobile-collapsible-chevron">▾</span>
  </button>

  <div class="mobile-collapsible-body">
    <form id="createPlayerForm" class="space-y-3">
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
        <div>
          <label class="text-xs muted">Name</label>
          <input id="playerName" class="input mt-1" placeholder="Player name">
        </div>

        <div>
          <label class="text-xs muted">Style (optional)</label>
          <select id="playerStyle" class="input mt-1">
            <option value="">Balanced (default)</option>
            <option value="scorer">Scorer</option>
            <option value="sharpshooter">Sharpshooter</option>
            <option value="playmaker">Playmaker</option>
            <option value="slasher">Slasher</option>
            <option value="post">Post scorer</option>
          </select>
        </div>
      </div>

      <div>
        <label class="text-xs muted">Notes</label>
        <textarea id="playerNotes" class="input mt-1 h-20" placeholder="Optional notes"></textarea>
      </div>

      <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
        <div>
          <label class="text-xs muted">Baseline</label>
          <input id="playerBaseline" type="number" class="input mt-1" value="60">
        </div>
        <div>
          <label class="text-xs muted">Variance</label>
          <input id="playerVariance" type="number" class="input mt-1" value="40">
        </div>
        <div>
          <label class="text-xs muted">Variance Tilt (0–100)</label>
          <input id="playerVarianceTilt" type="number" min="0" max="100" class="input mt-1" value="50">
          <p class="text-[11px] opacity-60 mt-1">
            Percent of swings that land <em>above</em> baseline.
          </p>
        </div>
        <div>
          <label class="text-xs muted">Momentum</label>
          <input id="playerMomentum" type="number" class="input mt-1" value="50">
        </div>
        <div>
          <label class="text-xs muted">Risky (0–100)</label>
          <input id="playerRisky" type="number" class="input mt-1" value="30">
        </div>
      </div>

      <div>
        <label class="text-xs muted">Photo (optional)</label>
        <input id="playerImage" type="file" accept="image/*" class="mt-1 text-xs">
        <p class="text-[11px] opacity-60 mt-1">
          You’ll be able to crop this after selecting.
        </p>
      </div>

      <div class="flex items-center gap-2 text-xs">
        <input id="playerActive" type="checkbox" class="toggle-switch" checked>
        <label for="playerActive" class="opacity-80">Active</label>
      </div>

      <div class="flex justify-end">
        <button class="btn btn-success" type="submit">Add player</button>
      </div>
    </form>
  </div>
</section>

  <!-- RIGHT: Simulate Today -->
  <section class="card mb-6">
    <h2 class="font-semibold text-lg mb-3">Simulate Today</h2>
    <button
      onclick="simulateToday()"
      class="w-full btn btn-teal rounded-2xl px-4 py-2 font-semibold"
    >
      Run Simulation
    </button>

    <div id="simResults" class="mt-3 text-sm opacity-85"></div>
  </section>

</div>


    <!-- Players list -->
    <section class="mb-10">
      <div class="flex flex-wrap items-center justify-between gap-3 mb-3">
        <div class="flex items-center gap-3">
          <h2 class="text-lg font-semibold">Players</h2>

          <!-- View toggle -->
          <div class="inline-flex rounded-full border border-zinc-700 overflow-hidden text-xs">
            <button
              id="viewCardBtn"
              type="button"
              class="px-3 py-1 bg-zinc-800 text-white"
            >
              Card view
            </button>
            <button
              id="viewGalleryBtn"
              type="button"
              class="px-3 py-1 bg-zinc-900/40"
            >
              Gallery view
            </button>
          </div>

          <div class="flex items-center gap-2 text-xs">
            <input id="groupActiveToggle" type="checkbox" class="toggle-switch">
            <label for="groupActiveToggle" class="opacity-70">Group active players</label>
          </div>

          <div id="galleryColumnsControl" class="hidden items-center gap-2 text-xs sm:hidden">
            <label for="galleryColumnsSelect" class="opacity-70">Mobile columns</label>
            <select id="galleryColumnsSelect" class="input px-2 py-1 text-xs">
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
          </div>
        </div>

        <div class="flex flex-wrap items-center gap-2 text-xs">
          <label for="playerSort" class="opacity-70">Sort by</label>
          <select
            id="playerSort"
            class="input px-3 py-1 text-xs"
          >
            <option value="name-asc">Name (A → Z)</option>
            <option value="name-desc">Name (Z → A)</option>
            <option value="avg-desc">PPD (high → low)</option>
            <option value="baseline-desc">Baseline (high → low)</option>
            <option value="created-desc">Recently added</option>
            <option value="created-asc">Oldest first</option>
          </select>
          <span id="playerCount" class="opacity-70"></span>
        </div>
      </div>

      <!-- NOTE: we’ll control the grid classes from JS now -->
      <div id="playersList" class="grid gap-4"></div>

      <div id="noPlayersMsg" class="text-sm opacity-60 mt-3 hidden">
        No players yet. Create your first fake hooper above.
      </div>
    </section>


  <!-- Image cropping modal -->
  <div id="cropModal" class="fixed inset-0 bg-black/70 flex items-center justify-center z-50 hidden">
    <div class="bg-zinc-900 text-zinc-50 rounded-2xl shadow-xl w-full max-w-md mx-4 p-4 sm:p-5">
      <h2 class="text-base sm:text-lg font-semibold mb-3">Crop player photo</h2>
      <div class="w-full border border-zinc-700 rounded-xl overflow-hidden bg-black mb-3">
        <canvas id="cropCanvas" class="block w-full"></canvas>
      </div>
      <div class="flex flex-wrap items-center gap-2 mb-3">
        <span class="text-xs opacity-80 mr-1">Aspect:</span>
        <button type="button" class="px-2 py-1 rounded-full text-xs border border-zinc-600 bg-transparent hover:bg-zinc-800" data-aspect="1:1">Square</button>
        <button type="button" class="px-2 py-1 rounded-full text-xs border border-zinc-600 bg-transparent hover:bg-zinc-800" data-aspect="2:3">2:3</button>
        <button type="button" class="px-2 py-1 rounded-full text-xs border border-zinc-600 bg-zinc-800" data-aspect="3:4">3:4</button>
      </div>
      <div class="mb-3">
        <div class="flex items-center justify-between text-xs opacity-80 mb-1">
          <span>Zoom</span>
          <span id="cropZoomLabel"></span>
        </div>
        <input id="cropZoom" type="range" min="100" max="150" value="100" class="w-full">
      </div>
      <p class="text-[11px] opacity-70 mb-3">
        Drag the image to reposition it inside the frame. Use the zoom slider to adjust how close it is. The result will be saved and used as the player photo.
      </p>
      <div class="flex justify-end gap-2">
        <button type="button" id="cropCancelBtn" class="rounded-xl border border-zinc-500 px-3 py-1.5 text-xs sm:text-sm">
          Cancel
        </button>
        <button type="button" id="cropApplyBtn" class="rounded-xl bg-emerald-500 hover:bg-emerald-600 text-white px-3 py-1.5 text-xs sm:text-sm">
          Apply crop
        </button>
      </div>
    </div>
  </div>

  <script>
const STORAGE_KEY = "taskpoints_v1";
const $ = (id) => document.getElementById(id);

function loadState() {
  // Base shape with all the shared keys we care about
  let base = {
    tasks: [],
    completions: [],
    habits: [],
    players: [],
    flexActions: [],
    gameHistory: [],
    matchups: [],
    schedule: [],
    opponentDripSchedules: [],
    youImageId: ""
  };

  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return base;

    const parsed = JSON.parse(raw) || {};

    base.tasks       = Array.isArray(parsed.tasks)       ? parsed.tasks       : [];
    base.completions = Array.isArray(parsed.completions) ? parsed.completions : [];
    base.habits      = Array.isArray(parsed.habits)      ? parsed.habits      : [];
    base.players     = Array.isArray(parsed.players)     ? parsed.players     : [];
    base.flexActions = Array.isArray(parsed.flexActions) ? parsed.flexActions : [];
    base.gameHistory = Array.isArray(parsed.gameHistory) ? parsed.gameHistory : [];
    base.matchups    = Array.isArray(parsed.matchups)    ? parsed.matchups    : [];
    base.schedule    = Array.isArray(parsed.schedule)    ? parsed.schedule    : [];
    base.opponentDripSchedules = Array.isArray(parsed.opponentDripSchedules)
      ? parsed.opponentDripSchedules
      : [];
    base.youImageId = typeof parsed.youImageId === "string" ? parsed.youImageId : "";
  } catch (e) {
    console.error("Failed to load state in game.html", e);
  }

  return base;
}

function normalizeHexColor(value) {
  if (!value) return null;
  let hex = String(value).trim();
  if (!hex) return null;
  if (!hex.startsWith('#')) hex = `#${hex}`;
  if (!/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(hex)) return null;
  if (hex.length === 4) {
    hex = `#${hex.slice(1).split('').map((c) => c + c).join('')}`;
  }
  return hex.toLowerCase();
}

function normalizeHabitTagColors(value) {
  if (!value || typeof value !== 'object') return {};
  const next = {};
  Object.entries(value).forEach(([tag, color]) => {
    const normalized = normalizeHexColor(color);
    if (normalized) next[String(tag)] = normalized;
  });
  return next;
}

function normalizeHabit(habit) {
  if (!habit || typeof habit !== 'object') return habit;
  return {
    ...habit,
    tag: typeof habit.tag === 'string' ? habit.tag.trim() : ''
  };
}

function normalizeState(s) {
  return {
    tasks:       Array.isArray(s.tasks)       ? s.tasks       : [],
    completions: Array.isArray(s.completions) ? s.completions : [],
    habits:      Array.isArray(s.habits)      ? s.habits.map(normalizeHabit)      : [],
    players:     Array.isArray(s.players)     ? s.players     : [],
    flexActions: Array.isArray(s.flexActions) ? s.flexActions : [],
    gameHistory: Array.isArray(s.gameHistory) ? s.gameHistory : [],
    matchups:    Array.isArray(s.matchups)    ? s.matchups    : [],
    schedule:    Array.isArray(s.schedule)    ? s.schedule    : [],
    opponentDripSchedules: Array.isArray(s.opponentDripSchedules) ? s.opponentDripSchedules : [],
    youImageId:  typeof s.youImageId === "string" ? s.youImageId : "",
    habitTagColors: normalizeHabitTagColors(s.habitTagColors)
  };
}

function saveState(nextState, options = {}) {
  try {
    if (window.TaskPointsCore?.saveAppState) {
      const { state: merged, trimmed } = TaskPointsCore.saveAppState(nextState, options);
      if (trimmed) {
        console.warn('Storage nearing capacity. Older history items were trimmed to keep saves working.');
      }
      return merged;
    }
    if (window.TaskPointsCore?.mergeAndSaveState) {
      const { state: merged, trimmed } = TaskPointsCore.mergeAndSaveState(nextState, options);
      if (trimmed) {
        console.warn('Storage nearing capacity. Older history items were trimmed to keep saves working.');
      }
      return merged;
    }
    const raw = localStorage.getItem(STORAGE_KEY);
    const existing = raw ? (JSON.parse(raw) || {}) : {};
    const merged = { ...existing, ...nextState };
    console.warn("game saveState skipped localStorage write; TaskPointsCore missing.");
    return merged;
  } catch (e) {
    console.error("Failed to save state in game.html", e);
    return nextState;
  }
}

function syncStateWithMatchups(baseState) {
  let nextState = baseState;
  let changed = false;

  if (window.TaskPointsCore?.syncDerivedPoints) {
    const derivedSync = TaskPointsCore.syncDerivedPoints(nextState);
    nextState = derivedSync.state;
    changed = changed || derivedSync.changed;
  }

  if (window.TaskPointsCore?.syncYouMatchups) {
    const matchupSync = TaskPointsCore.syncYouMatchups(nextState);
    nextState = matchupSync.state;
    changed = changed || matchupSync.changed;
  }

  if (changed) {
    return saveState(nextState);
  }
  return nextState;
}


let state = syncStateWithMatchups(loadState());
    console.log("STORAGE_KEY =", STORAGE_KEY);
console.log("state.players =", state.players, "count =", (state.players || []).length);

const imageUrlCache = new Map();
const imageLoadPromises = new Map();
let renderPlayersNonce = 0;

function dataUrlToBlobFallback(dataUrl) {
  if (typeof dataUrl !== "string") return null;
  const match = dataUrl.match(/^data:([^;,]+)(;base64)?,(.*)$/);
  if (!match) return null;
  const mime = match[1] || "application/octet-stream";
  const isBase64 = Boolean(match[2]);
  const data = match[3] || "";

  if (isBase64) {
    const binary = atob(data);
    const len = binary.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i += 1) {
      bytes[i] = binary.charCodeAt(i);
    }
    return new Blob([bytes], { type: mime });
  }

  return new Blob([decodeURIComponent(data)], { type: mime });
}

function getImageHelper() {
  return window.TaskPointsCore || {};
}

function getCachedImageUrl(imageId) {
  return imageUrlCache.get(imageId) || "";
}

function revokeImageUrl(imageId) {
  const url = imageUrlCache.get(imageId);
  if (url) {
    URL.revokeObjectURL(url);
    imageUrlCache.delete(imageId);
  }
}

async function loadImageUrl(imageId) {
  if (!imageId) return "";
  if (imageUrlCache.has(imageId)) return imageUrlCache.get(imageId);
  if (imageLoadPromises.has(imageId)) return imageLoadPromises.get(imageId);

  const { getImageBlob } = getImageHelper();
  if (typeof getImageBlob !== "function") return "";

  const promise = (async () => {
    const blob = await getImageBlob(imageId);
    if (!blob) return "";
    const url = URL.createObjectURL(blob);
    imageUrlCache.set(imageId, url);
    return url;
  })();

  imageLoadPromises.set(imageId, promise);
  const url = await promise;
  imageLoadPromises.delete(imageId);
  return url;
}

async function preloadImageUrls(imageIds) {
  const unique = Array.from(new Set(imageIds.filter(Boolean)));
  await Promise.all(unique.map((imageId) => loadImageUrl(imageId)));
}

async function saveImageFromDataUrl(dataUrl, existingImageId) {
  if (!dataUrl) return existingImageId || "";
  const { dataUrlToBlob, generateImageId, saveImageBlob, deleteImageBlob } = getImageHelper();
  const toBlob = typeof dataUrlToBlob === "function" ? dataUrlToBlob : dataUrlToBlobFallback;
  const blob = toBlob(dataUrl);
  if (!blob) return existingImageId || "";

  const imageId = typeof generateImageId === "function" ? generateImageId() : `img_${Date.now()}_${Math.random().toString(16).slice(2)}`;
  if (typeof saveImageBlob === "function") {
    await saveImageBlob(imageId, blob);
  }

  if (existingImageId && existingImageId !== imageId) {
    if (typeof deleteImageBlob === "function") {
      await deleteImageBlob(existingImageId);
    }
    revokeImageUrl(existingImageId);
  }

  return imageId;
}

async function deleteImageById(imageId) {
  if (!imageId) return;
  const { deleteImageBlob } = getImageHelper();
  if (typeof deleteImageBlob === "function") {
    await deleteImageBlob(imageId);
  }
  revokeImageUrl(imageId);
}

async function migrateLegacyImagesIfNeeded() {
  if (!window.TaskPointsCore?.migrateLegacyImagesInStorage) return;
  try {
    const result = await TaskPointsCore.migrateLegacyImagesInStorage();
    if (result?.migrated) {
      state = syncStateWithMatchups(result.state || state);
      renderPlayers();
    }
  } catch (e) {
    console.error("Image migration failed", e);
  }
}

if (rebuildGameHistoryFromMatchupsIfNeeded()) {
  state = saveState(state);
}
    
let editingPlayerId = null;
let viewMode = "card"; // "card" | "gallery"
const GALLERY_COLUMNS_STORAGE_KEY = "taskpoints_gallery_columns";
let galleryColumns = loadGalleryColumns();
const PLAYER_SORT_STORAGE_KEY = "taskpoints_player_sort_mode";
const GROUP_ACTIVE_PLAYERS_STORAGE_KEY = "taskpoints_group_active_players";
const PLAYER_SORT_OPTIONS = [
  "name-asc",
  "name-desc",
  "avg-desc",
  "baseline-desc",
  "created-desc",
  "created-asc"
];
let playerSortMode = loadSortMode();
let groupActivePlayers = loadGroupActivePlayers();

function loadGalleryColumns() {
  try {
    const stored = localStorage.getItem(GALLERY_COLUMNS_STORAGE_KEY);
    if (!stored) return { portrait: 2, landscape: 3 };
    const parsed = JSON.parse(stored);
    const portrait = Number(parsed?.portrait);
    const landscape = Number(parsed?.landscape);
    return {
      portrait: portrait === 2 || portrait === 3 ? portrait : 2,
      landscape: landscape === 3 || landscape === 4 ? landscape : 3
    };
  } catch (e) {
    return { portrait: 2, landscape: 3 };
  }
}

function persistGalleryColumns(next) {
  if (!next) return;
  galleryColumns = {
    portrait: next.portrait === 2 || next.portrait === 3 ? next.portrait : 2,
    landscape: next.landscape === 3 || next.landscape === 4 ? next.landscape : 3
  };
  localStorage.setItem(GALLERY_COLUMNS_STORAGE_KEY, JSON.stringify(galleryColumns));
}

function loadGroupActivePlayers() {
  try {
    return localStorage.getItem(GROUP_ACTIVE_PLAYERS_STORAGE_KEY) === "true";
  } catch (e) {
    return false;
  }
}

function persistGroupActivePlayers(nextValue) {
  groupActivePlayers = !!nextValue;
  localStorage.setItem(GROUP_ACTIVE_PLAYERS_STORAGE_KEY, String(groupActivePlayers));
}

function loadSortMode() {
  const stored = localStorage.getItem(PLAYER_SORT_STORAGE_KEY);
  if (stored && PLAYER_SORT_OPTIONS.includes(stored)) return stored;
  return "name-asc";
}

function persistSortMode(mode) {
  if (!PLAYER_SORT_OPTIONS.includes(mode)) return;
  playerSortMode = mode;
  localStorage.setItem(PLAYER_SORT_STORAGE_KEY, mode);
}

if (ensureUpcomingSchedule()) {
  state = saveState(state);
}

migrateLegacyImagesIfNeeded();



    // --- Image cropper state ---
    let cropState = null;
    let cropCanvasEl = null;
    let cropCtx = null;
    let cropModalEl = null;
    let cropZoomEl = null;
    let cropZoomLabelEl = null;
    let cropAspectButtons = [];

    function initCropperElements(){
      if (cropCanvasEl) return;
      cropCanvasEl = document.getElementById("cropCanvas");
      cropCtx = cropCanvasEl.getContext("2d");
      cropModalEl = document.getElementById("cropModal");
      cropZoomEl = document.getElementById("cropZoom");
      cropZoomLabelEl = document.getElementById("cropZoomLabel");
      cropAspectButtons = Array.from(document.querySelectorAll("#cropModal [data-aspect]"));

      cropAspectButtons.forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const val = btn.getAttribute("data-aspect");
          setCropAspect(val);
        });
      });

      cropZoomEl.addEventListener("input", ()=>{
        if (!cropState) return;
        const raw = Number(cropZoomEl.value)||100;
        const scale = Math.max(cropState.minScale, raw/100);
        cropState.scale = scale;
        updateZoomLabel();
        drawCrop();
      });

      const applyBtn = document.getElementById("cropApplyBtn");
      const cancelBtn = document.getElementById("cropCancelBtn");
      applyBtn.addEventListener("click", applyCrop);
      cancelBtn.addEventListener("click", cancelCrop);

      // Dragging
      let isDragging = false;
      let lastX = 0, lastY = 0;

      function pointerDown(clientX, clientY){
        if (!cropState) return;
        isDragging = true;
        lastX = clientX;
        lastY = clientY;
      }
      function pointerMove(clientX, clientY){
        if (!isDragging || !cropState) return;
        const dx = clientX - lastX;
        const dy = clientY - lastY;
        lastX = clientX;
        lastY = clientY;
        cropState.offsetX += dx;
        cropState.offsetY += dy;
        drawCrop();
      }
      function pointerUp(){
        isDragging = false;
      }

      cropCanvasEl.addEventListener("mousedown", (e)=>{
        e.preventDefault();
        pointerDown(e.clientX, e.clientY);
      });
      window.addEventListener("mousemove", (e)=>{
        if (!isDragging) return;
        pointerMove(e.clientX, e.clientY);
      });
      window.addEventListener("mouseup", pointerUp);

      // Touch support
      cropCanvasEl.addEventListener("touchstart", (e)=>{
        const t = e.touches[0];
        if (!t) return;
        pointerDown(t.clientX, t.clientY);
      }, {passive:true});
      window.addEventListener("touchmove", (e)=>{
        if (!isDragging) return;
        const t = e.touches[0];
        if (!t) return;
        pointerMove(t.clientX, t.clientY);
      }, {passive:true});
      window.addEventListener("touchend", pointerUp);
    }

    function openImageCropperFromFile(file, callback){
      initCropperElements();
      if (!file){
        callback(undefined);
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          startCropSession(img, callback);
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    }

    function openImageCropperFromUrl(url, callback, cleanup){
      initCropperElements();
      if (!url){
        callback(undefined);
        return;
      }
      const img = new Image();
      img.onload = () => {
        startCropSession(img, callback, cleanup);
      };
      img.src = url;
    }

    function openImageCropperFromBlob(blob, callback){
      if (!blob) {
        callback(undefined);
        return;
      }
      const url = URL.createObjectURL(blob);
      openImageCropperFromUrl(url, callback, () => URL.revokeObjectURL(url));
    }

    function startCropSession(img, callback, cleanup){
      initCropperElements();
      cropState = {
        img,
        callback,
        cleanup,
        aspectValue: "3:4",
        aspectRatio: 3/4,
        scale: 1,
        minScale: 1,
        offsetX: 0,
        offsetY: 0
      };
      cropModalEl.classList.remove("hidden");
      window.lockScrollForModal?.();
      setCropAspect("3:4");
    }

    function setCropAspect(val){
      if (!cropState || !cropCanvasEl) return;
      cropState.aspectValue = val;

      let ratio = 1; // width / height
      if (val === "2:3") ratio = 2/3;
      else if (val === "3:4") ratio = 3/4;
      else ratio = 1;

      cropState.aspectRatio = ratio;

// smaller base size
const baseWidth = 260; // or even 220 if you want to be aggressive
const width = baseWidth;
const height = Math.round(baseWidth / ratio);

      cropCanvasEl.width = width;
      cropCanvasEl.height = height;

      const img = cropState.img;
      const scaleX = width / img.width;
      const scaleY = height / img.height;
      const minScale = Math.max(scaleX, scaleY);

      cropState.minScale = minScale;
      cropState.scale = minScale;
      cropState.offsetX = width / 2;
      cropState.offsetY = height / 2;

cropZoomEl.min = String(Math.round(minScale * 100));
cropZoomEl.value = cropZoomEl.min;
cropZoomEl.max = String(Math.round(minScale * 150)); // caps at 150% of minScale

      updateZoomLabel();
      updateAspectButtons();
      drawCrop();
    }

    function updateAspectButtons(){
      if (!cropAspectButtons) return;
      cropAspectButtons.forEach(btn=>{
        const val = btn.getAttribute("data-aspect");
        if (val === cropState.aspectValue){
          btn.classList.add("bg-zinc-800");
        } else {
          btn.classList.remove("bg-zinc-800");
        }
      });
    }

    function updateZoomLabel(){
      if (!cropZoomLabelEl || !cropState) return;
      const percent = Math.round((cropState.scale / cropState.minScale) * 100);
      cropZoomLabelEl.textContent = `${percent}%`;
    }

    function drawCrop(){
      if (!cropState || !cropCanvasEl || !cropCtx) return;
      const ctx = cropCtx;
      const { img, scale, offsetX, offsetY } = cropState;
      const cw = cropCanvasEl.width;
      const ch = cropCanvasEl.height;

      ctx.save();
      ctx.clearRect(0,0,cw,ch);
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,cw,ch);

      const drawW = img.width * scale;
      const drawH = img.height * scale;
      const dx = offsetX - drawW/2;
      const dy = offsetY - drawH/2;

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(img, dx, dy, drawW, drawH);

      ctx.restore();
    }

    function cancelCrop(){
      if (!cropModalEl) return;
      cropModalEl.classList.add("hidden");
      if (cropState?.cleanup) cropState.cleanup();
      cropState = null;
      window.unlockScrollForModal?.();
    }

    function applyCrop(){
      if (!cropState || !cropCanvasEl) return;
      const dataUrl = cropCanvasEl.toDataURL("image/jpeg", 0.7);
      const cb = cropState.callback;
      cancelCrop();
      if (typeof cb === "function"){
        cb(dataUrl);
      }
    }

function simulateAiScoreForPlayer(player, todayKey){
  if (!player || !player.baseline) return 0;

  const baseline = Number(player.baseline);
  const variance = Number(player.variance);
  const varianceTiltRaw = Number(
    typeof player.varianceTilt === "number" ? player.varianceTilt : (player.varianceTilt || 50)
  );
  const varianceTilt = Math.min(100, Math.max(0, varianceTiltRaw)) / 100;
  const momentum = Number(player.momentum);

  let riskyRating = Number(player.risky);
  if (isNaN(riskyRating)) riskyRating = 0;
  const riskyNormalized = riskyRating > 10 ? riskyRating / 10 : riskyRating;

  const variationMagnitude = Math.random() * variance;
  const variationSign = Math.random() < varianceTilt ? 1 : -1;
  const variation = variationMagnitude * variationSign;

  let momentumBonus = 0;
  if (momentum && state.gameHistory.length) {
    const prev = state.gameHistory
      .filter(g => g.playerId === player.id)
      .sort((a,b) => b.date.localeCompare(a.date))[0];

    if (prev && prev.date !== todayKey) {
      momentumBonus = (prev.score * (momentum / 100)) * 0.1;
    }
  }

  let riskyMod = 0;
  if (Math.random() < riskyNormalized / 10) {
    const boom = Math.random() < 0.5;
    const riskyScale = 0.5 + Math.random() * 2.5;
    riskyMod = boom
      ? variance * riskyScale
      : -variance * riskyScale;
  }

  const score = baseline + variation + momentumBonus + riskyMod;
  const roundedScore = Number(score.toFixed(1));
  const safeScore = Number.isFinite(roundedScore) ? roundedScore : 0;
  return Math.max(0, safeScore);
}

function makeId() {
  if (window.crypto && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  return "id_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2);
}


    
    function rebuildGameHistoryFromMatchupsIfNeeded() {
  const mh = Array.isArray(state.matchups) ? state.matchups : [];
  const gh = Array.isArray(state.gameHistory) ? state.gameHistory : [];

  // If we have lots of matchups but tiny gameHistory, rebuild.
  // (Each matchup yields up to 2 AI score entries; "YOU" is excluded.)
  if (!mh.length) return false;
  if (gh.length >= Math.floor(mh.length * 1.5)) return false;

  const rebuilt = [];
  const seen = new Set(); // date|playerId

  for (const m of mh) {
    if (!m) continue;
    const date = m.dateKey || m.date || (m.dateISO ? String(m.dateISO).slice(0, 10) : "");
    if (!date) continue;

    const aId = m.playerAId;
    const bId = m.playerBId;

    const aScore = Number(m.scoreA);
    const bScore = Number(m.scoreB);

    if (aId && aId !== "YOU" && Number.isFinite(aScore)) {
      const k = `${date}|${aId}`;
      if (!seen.has(k)) {
        rebuilt.push({ id: makeId(), date, playerId: aId, score: aScore });
        seen.add(k);
      }
    }

    if (bId && bId !== "YOU" && Number.isFinite(bScore)) {
      const k = `${date}|${bId}`;
      if (!seen.has(k)) {
        rebuilt.push({ id: makeId(), date, playerId: bId, score: bScore });
        seen.add(k);
      }
    }
  }

  rebuilt.sort((x, y) => x.date.localeCompare(y.date));
  state.gameHistory = rebuilt;
  return true;
}

    

    function dayProgress(now = new Date()) {
  // e.g. progress from 6:00 AM to 2:00 AM next day
  const start = new Date(now); start.setHours(6,0,0,0);
  const end   = new Date(now); end.setHours(26,0,0,0); // 2am next day
  const t = now.getTime();
  const p = (t - start.getTime()) / (end.getTime() - start.getTime());
  return Math.max(0, Math.min(1, p));
}

function visibleNPCScore(finalScore) {
  const p = dayProgress(new Date());
  const scoreValue = Number(finalScore);
  const safeScore = Number.isFinite(scoreValue) ? scoreValue : 0;
  return Math.max(0, Math.floor(safeScore * p));
}


function generateOpponentDripSchedule(dateKeyStr, playerId, totalPoints){
  const totalRounded = Math.max(0, Math.round((Number(totalPoints) || 0) * 10) / 10);
  const totalUnits   = Math.round(totalRounded * 10);

  const startHour = 6;
  const endHour   = 23;
  const count     = Math.max(12, Math.min(40, Math.round(Math.random() * 20) + 15));

  const baseDate = new Date(`${dateKeyStr}T00:00:00`);

  const hourBuckets = [];
  for (let h = startHour; h <= endHour; h++) {
    let weight = 1;
    if (h >= 6 && h <= 11) weight += 1.6;
    if (h >= 12 && h <= 15) weight += 0.6;
    if (h >= 18 && h <= 23) weight -= 0.2;
    if (Math.random() < 0.15) weight *= 0.4;
    hourBuckets.push({ hour: h, weight: Math.max(0.2, weight) });
  }

  const totalHourWeight = hourBuckets.reduce((s, h) => s + h.weight, 0) || 1;

  function pickTime(){
    let r = Math.random() * totalHourWeight;
    let chosenHour = startHour;
    for (const h of hourBuckets) {
      if (r <= h.weight) { chosenHour = h.hour; break; }
      r -= h.weight;
    }

    const m = Math.floor(Math.random() * 60);
    const s = Math.floor(Math.random() * 60);
    const d = new Date(baseDate.getTime());
    d.setHours(chosenHour, m, s, 0);
    return d;
  }

  const weights = [];
  for (let i = 0; i < count; i++) {
    const base = Math.pow(Math.random(), 1.4);
    const burst = Math.random() < 0.35 ? Math.random() * 1.2 : 0;
    weights.push(base + burst);
  }

  const weightSum = weights.reduce((s, n) => s + n, 0) || 1;

  let remaining = totalUnits;
  const pointUnits = [];
  for (let i = 0; i < count; i++) {
    if (i === count - 1) {
      pointUnits.push(Math.max(0, remaining));
    } else {
      const share = Math.min(
        remaining,
        Math.max(0, Math.round((weights[i] / weightSum) * totalUnits))
      );
      pointUnits.push(share);
      remaining -= share;
    }
  }

  if (remaining > 0 && pointUnits.length) {
    pointUnits[pointUnits.length - 1] += remaining;
  }

  const times = pointUnits.map(() => pickTime()).sort((a, b) => a - b);
  const sizedUnits = pointUnits.slice().sort((a, b) => b - a);

  const events = sizedUnits
    .map((units, idx) => ({ t: times[idx].toISOString(), pts: units / 10 }))
    .filter(e => e.pts > 0)
    .sort((a, b) => new Date(a.t) - new Date(b.t));

  return {
    date: dateKeyStr,
    playerId,
    total: totalRounded,
    events
  };
}

function ensureOpponentDripSchedule(dateKeyStr, playerId, totalPoints){
  if (!dateKeyStr || !playerId) return null;

  const list = Array.isArray(state.opponentDripSchedules) ? state.opponentDripSchedules : [];
  const totalRounded = Math.max(0, Math.round((Number(totalPoints) || 0) * 10) / 10);
  const existingIdx = list.findIndex(s => s && s.date === dateKeyStr && s.playerId === playerId);

  if (existingIdx !== -1) {
    const existing = list[existingIdx];
    if (existing && Math.abs((existing.total || 0) - totalRounded) < 0.001 && Array.isArray(existing.events) && existing.events.length) {
      return existing;
    }
  }

  const next = generateOpponentDripSchedule(dateKeyStr, playerId, totalRounded);
  const updated = list.filter(s => !(s && s.date === dateKeyStr && s.playerId === playerId));
  updated.push(next);

  state.opponentDripSchedules = updated;
  state = saveState(state);
  return next;
}


function simulateToday() {
  const todayKey = getGameDayKey(new Date());

  state.gameHistory = state.gameHistory || [];
  state.matchups    = state.matchups    || [];
  state.schedule    = state.schedule    || [];

  ensureUpcomingSchedule();

  // Remove any existing scores + matchups for today so re-running is clean
  state.gameHistory = state.gameHistory.filter(g => g.date !== todayKey);
  state.matchups    = state.matchups.filter(m => m.date !== todayKey);

  const todaysSchedule = state.schedule.find(d => d && d.date === todayKey);
  const todaysPairs = todaysSchedule && Array.isArray(todaysSchedule.matchups)
    ? todaysSchedule.matchups
    : [];
  const byeIds = todaysSchedule && Array.isArray(todaysSchedule.byeIds)
    ? todaysSchedule.byeIds
    : [];

  const namesById = {};
  const playerMap = new Map();
  (state.players || []).forEach(p => {
    if (!p || !p.id) return;
    playerMap.set(p.id, p);
    namesById[p.id] = p.name || "Unnamed";
  });
  namesById["YOU"] = "You";

  if (!todaysPairs.length) {
    state = saveState(state);
    const byeText = byeIds.length
      ? byeIds.map(id => `${namesById[id] || 'Unknown'} has no matchup scheduled.`).join('<br>')
      : 'No matchups scheduled for today.';

    $('simResults').innerHTML = `
      <h3 class="font-semibold mb-1">Matchups for ${todayKey}</h3>
      <div>${byeText}</div>
    `;
    renderPlayers();
    return;
  }

  const participantIds = Array.from(new Set(
    todaysPairs.flatMap(m => [m.playerAId, m.playerBId])
  ));

  const scoresById = {};

  const youScore = computeTodayPoints();
  if (participantIds.includes('YOU') && !isNaN(youScore)) {
    scoresById['YOU'] = youScore;
  }

  participantIds.forEach(id => {
    if (id === 'YOU') return;
    const player = playerMap.get(id);
    if (!player) return;
    const score = simulateAiScoreForPlayer(player, todayKey);
    scoresById[id] = score;
    ensureOpponentDripSchedule(todayKey, id, score);
    state.gameHistory.push({
      id: makeId(),
      date: todayKey,
      playerId: id,
      score
    });
  });

  const todaysMatchups = [];

  todaysPairs.forEach(pair => {
    const matchup = {
      id: makeId(),
      date: todayKey,
      playerAId: pair.playerAId,
      playerBId: pair.playerBId,
      playerAName: namesById[pair.playerAId] || "Unknown",
      playerBName: namesById[pair.playerBId] || "Unknown",
      scoreA: scoresById[pair.playerAId] ?? 0,
      scoreB: scoresById[pair.playerBId] ?? 0
    };

    state.matchups.push(matchup);
    todaysMatchups.push(matchup);
  });

  state = saveState(state);

  const lines = todaysMatchups.map(m => {
    const aId = m.playerAId;
    const bId = m.playerBId;
    const aName = namesById[aId] || aId;
    const bName = namesById[bId] || bId;
    const aScore = m.scoreA;
    const bScore = m.scoreB;
    const aIsYou = aId === "YOU";
    const bIsYou = bId === "YOU";

    if (aIsYou || bIsYou) {
      const youScoreVal = aIsYou ? aScore : bScore;
      const oppScore   = aIsYou ? bScore : aScore;
      const oppName    = aIsYou ? bName  : aName;

      if (youScoreVal > oppScore) {
        return `You beat ${oppName}, ${youScoreVal}–${oppScore}`;
      } else if (youScoreVal < oppScore) {
        return `You lost to ${oppName}, ${youScoreVal}–${oppScore}`;
      } else {
        return `You tied ${oppName}, ${youScoreVal}–${oppScore}`;
      }
    }

    if (aScore > bScore) {
      return `${aName} beat ${bName}, ${aScore}–${bScore}`;
    } else if (bScore > aScore) {
      return `${bName} beat ${aName}, ${bScore}–${aScore}`;
    } else {
      return `${aName} and ${bName} tied, ${aScore}–${bScore}`;
    }
  });

  const byeLines = byeIds.map(id => `${namesById[id] || 'Unknown'} has no matchup scheduled.`);
  const combined = [...lines, ...byeLines];

  const outHtml = combined.length
    ? combined.map(l => `<div>• ${l}</div>`).join("")
    : `<div>No matchups created.</div>`;

  $('simResults').innerHTML = `
    <h3 class="font-semibold mb-1">Matchups for ${todayKey}</h3>
    ${outHtml}
  `;

  renderPlayers();
}



function maybeAutoSimToday(){
  const now = new Date();
  const todayKey = getGameDayKey(now);


  // Only after 8am local time (your EST)
  if (now.getHours() < 8) return;

  // Need at least one player
  if (!Array.isArray(state.players) || state.players.length === 0) return;

  state.gameHistory = state.gameHistory || [];

  // If ANY scores already exist for today, don't auto-sim again
  const hasToday = state.gameHistory.some(g => g.date === todayKey);
  if (hasToday) return;

  // Run one sim for today (this will also update #simResults)
  simulateToday();
}

function dateKey(d){
  if (!(d instanceof Date)) d = new Date(d);
  if (!d || isNaN(d.getTime())) return 'invalid';
  const y  = d.getFullYear();
  const m  = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${dd}`;
}

function getGameDayKey(now = new Date()) {
  const dt = new Date(now);
  dt.setHours(0,0,0,0);
  return dateKey(dt);
}

function getMatchupDateKey(matchup){
  if (!matchup) return '';
  return matchup.dateKey || matchup.date || (matchup.dateISO ? dateKey(matchup.dateISO) : '');
}

function isMatchupRevealed(matchup){
  const key = getMatchupDateKey(matchup);
  if (window.TaskPointsCore?.isMatchupRevealed) {
    return TaskPointsCore.isMatchupRevealed(key, { includeToday: false });
  }
  if (!key) return false;
  const today = window.TaskPointsCore?.todayKey ? TaskPointsCore.todayKey() : dateKey(new Date());
  return key < today;
}

function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function isPlayerActive(player){
  return !!player && player.active !== false;
}

function getAllParticipantIds(){
  const ids = ['YOU'];
  (state.players || []).forEach(p => {
    if (p && p.id && isPlayerActive(p)) ids.push(p.id);
  });
  return ids;
}

function participantSignature(ids){
  return ids.slice().sort().join('|');
}

function buildDailySchedule(dateKeyStr, participantIds, signature){
  const pool = participantIds.slice();
  shuffle(pool);

  const matchups = [];
  const byeIds = [];

  for (let i = 0; i + 1 < pool.length; i += 2) {
    matchups.push({
      playerAId: pool[i],
      playerBId: pool[i+1]
    });
  }

  if (pool.length % 2 === 1) {
    byeIds.push(pool[pool.length - 1]);
  }

  return {
    date: dateKeyStr,
    matchups,
    byeIds,
    participantSignature: signature
  };
}

function ensureUpcomingSchedule(days = 7){
  const today = new Date();
  today.setHours(0,0,0,0);
  const todayKey = dateKey(today);

  const participants = getAllParticipantIds();
  const signature = participantSignature(participants);

  let schedule = Array.isArray(state.schedule) ? state.schedule.filter(d => d && d.date >= todayKey) : [];
  let changed = false;

  if (!schedule.every(d => d.participantSignature === signature)) {
    schedule = [];
    changed = true;
  }

  const neededDates = [];
  for (let i = 0; i < days; i++) {
    const dt = new Date(today);
    dt.setDate(dt.getDate() + i);
    neededDates.push(dateKey(dt));
  }

  const byDate = new Map();
  schedule.forEach((d) => {
    if (d && d.date) byDate.set(d.date, d);
  });

  const rebuilt = neededDates.map((key) => {
    const existing = byDate.get(key);
    if (existing) return existing;
    changed = true;
    return buildDailySchedule(key, participants, signature);
  });

  if (rebuilt.length !== schedule.length) changed = true;

  state.schedule = rebuilt;
  return changed;
}

function refreshScheduleAfterRosterChange(){
  const changed = ensureUpcomingSchedule();
  if (changed) {
    state = saveState(state);
  }
}

function computeTodayPoints() {
  const today = new Date();
  today.setHours(0,0,0,0);
  const todayKey = dateKey(today);

  if (window.TaskPointsCore && typeof TaskPointsCore.buildDaySnapshot === "function" && typeof TaskPointsCore.computeDayTotals === "function") {
    const snapshot = TaskPointsCore.buildDaySnapshot(todayKey, state);
    const totals = TaskPointsCore.computeDayTotals(snapshot);
    return Number((totals.total || 0).toFixed(1));
  }

  const comps = Array.isArray(state.completions) ? state.completions : [];
  if (!comps.length) return 0;

  let total = 0;

  for (const c of comps) {
    if (!c || !c.completedAtISO) continue;

    const dk = dateKey(c.completedAtISO);
    if (dk === todayKey) {
      total += Number(c.points || 0);
    }
  }

  return Number(total.toFixed(1));
}


function buildPlayerHistoryStats() {
  const map = new Map();
  const history = Array.isArray(state.gameHistory) ? state.gameHistory : [];
  const todayKey = getGameDayKey(new Date());

  for (const g of history) {
    if (!g || !g.playerId) continue;
    const gameKey = g.date || (g.dateISO ? dateKey(g.dateISO) : "");
    if (gameKey === todayKey) continue;
    const score = typeof g.score === "number" ? g.score : Number(g.score);
    if (!Number.isFinite(score)) continue;

    const entry = map.get(g.playerId) || { games: 0, totalPoints: 0, scores: [] };
    entry.games += 1;
    entry.totalPoints += score;
    entry.scores.push(score);
    map.set(g.playerId, entry);
  }

  return map;
}


function calcYouStats() {
  const record = window.TaskPointsCore?.computeRecord
    ? TaskPointsCore.computeRecord(state, "YOU", { includeToday: false, allowFallback: false })
    : { wins: 0, losses: 0, ties: 0, games: 0, source: "unknown" };

  const comps = state.completions || [];
  if (!comps.length && record.source !== "matchups") {
    return {
      record: "0-0",
      avgPPD: 0,
      games: 0,
      wins: 0,
      losses: 0
    };
  }

  if (record.source === "matchups") {
    const matchups = Array.isArray(state.matchups) ? state.matchups : [];
    const youGames = matchups.filter(m => m && (m.playerAId === "YOU" || m.playerBId === "YOU"));
    let totalPoints = 0;
    let games = 0;

    for (const m of youGames) {
      const aScore = Number(m.scoreA);
      const bScore = Number(m.scoreB);
      if (!Number.isFinite(aScore) || !Number.isFinite(bScore)) continue;
      if (!isMatchupRevealed(m)) continue;

      const yourScore = (m.playerAId === "YOU") ? aScore : bScore;
      totalPoints += yourScore;
      games++;
    }

    const avgPPD = games ? (totalPoints / games) : 0;
    return {
      record: `${record.wins}-${record.losses}`,
      avgPPD,
      games,
      wins: record.wins,
      losses: record.losses
    };
  }

  const dayMap = {};
  for (const c of comps) {
    if (!c || !c.completedAtISO) continue;
    const day = dateKey(c.completedAtISO);
    if (!dayMap[day]) dayMap[day] = 0;
    const pts = window.TaskPointsCore?.pointsForCompletion
      ? TaskPointsCore.pointsForCompletion(c)
      : Number(c.points || 0);
    dayMap[day] += pts;
  }

  const dailyTotals = Object.values(dayMap);
  const avgPPD =
    dailyTotals.reduce((a, b) => a + b, 0) / dailyTotals.length || 0;

  const games = dailyTotals.length;

  return {
    record: `${record.wins}-${record.losses}`,
    avgPPD: avgPPD,
    games,
    wins: record.wins,
    losses: record.losses
  };
}

function applyGalleryColumnsToContainer(container) {
  if (!container) return;
  container.style.setProperty("--gallery-cols", galleryColumns.portrait);
  container.style.setProperty("--gallery-cols-landscape", galleryColumns.landscape);
}

function getGalleryOrientation() {
  return window.matchMedia("(orientation: landscape)").matches ? "landscape" : "portrait";
}

function applyPlayersGridLayout(grid) {
  if (!grid) return;
  if (viewMode === "gallery") {
    grid.className = "players-grid grid gap-4 gallery-view sm:grid-cols-3 md:grid-cols-5";
    applyGalleryColumnsToContainer(grid);
  } else {
    grid.className = "players-grid grid gap-3 card-view grid-cols-1 md:grid-cols-2 xl:grid-cols-3";
    grid.style.removeProperty("--gallery-cols");
    grid.style.removeProperty("--gallery-cols-landscape");
  }
}


async function renderPlayers() {
  const container = $("playersList");
  if (!container) return;

  updateSortSelectUI();
  container.innerHTML = "";

  if (groupActivePlayers) {
    container.className = "flex flex-col gap-6";
    container.style.removeProperty("--gallery-cols");
    container.style.removeProperty("--gallery-cols-landscape");
  } else {
    applyPlayersGridLayout(container);
  }




  // --- compute your real TaskPoints score for today ---
  const todayPoints = computeTodayPoints();
  const youStats = calcYouStats();
  const historyStats = buildPlayerHistoryStats();

  historyStats.set("YOU", {
    games: youStats.games || 0,
    totalPoints: (youStats.avgPPD || 0) * (youStats.games || 0),
    scores: [],
    avgPPD: youStats.avgPPD || 0,
    wins: youStats.wins || 0,
    losses: youStats.losses || 0
  });

  // --- special virtual avatar player ---
  const youPlayer = {
    id: "YOU",
    name: "You",
    imageId: state.youImageId || "",
    todayPoints: todayPoints.toFixed(1),
    isYou: true
  };

  // --- normal players ---
  const normalPlayers = Array.isArray(state.players)
  ? state.players.filter(p => p && typeof p === "object")
  : [];


  const players = [youPlayer, ...normalPlayers];

  const imageIds = players
    .map((player) => player?.imageId)
    .filter(Boolean);
  const renderToken = ++renderPlayersNonce;
  await preloadImageUrls(imageIds);
  if (renderToken !== renderPlayersNonce) return;

  // Update count (does NOT count YOU as a player)
  $("playerCount").textContent =
    normalPlayers.length
      ? `${normalPlayers.length} player${normalPlayers.length === 1 ? "" : "s"}`
      : "";

  if (!players.length) {
    $("noPlayersMsg").classList.remove("hidden");
    return;
  } else {
    $("noPlayersMsg").classList.add("hidden");
  }

  const getAverageForPlayer = (playerId) => {
    const stat = historyStats.get(playerId);
    if (!stat) return null;
    if (typeof stat.avgPPD === "number") return stat.avgPPD;
    if (stat.games) return stat.totalPoints / stat.games;
    return null;
  };

  const getCreatedTs = (player) => {
    if (player.isYou) return -Infinity;
    const ts = new Date(player.createdAtISO || "").getTime();
    return Number.isFinite(ts) ? ts : 0;
  };

  const comparePlayers = (a, b) => {
    const youPriorityModes = new Set(["baseline-desc", "created-asc"]);
    if (youPriorityModes.has(playerSortMode)) {
      if (a.isYou && !b.isYou) return -1;
      if (b.isYou && !a.isYou) return 1;
    }
    if (playerSortMode === "created-desc") {
      if (a.isYou && !b.isYou) return 1;
      if (b.isYou && !a.isYou) return -1;
    }

    const nameA = (a.isYou ? "You" : a.name || "").toLowerCase();
    const nameB = (b.isYou ? "You" : b.name || "").toLowerCase();
    const avgA = getAverageForPlayer(a.id);
    const avgB = getAverageForPlayer(b.id);
    const baselineA = Number.isFinite(a.baseline) ? a.baseline : -Infinity;
    const baselineB = Number.isFinite(b.baseline) ? b.baseline : -Infinity;
    const createdA = getCreatedTs(a);
    const createdB = getCreatedTs(b);

    switch (playerSortMode) {
      case "name-desc":
        return nameB.localeCompare(nameA);
      case "avg-desc": {
        const activeA = a.isYou ? true : isPlayerActive(a);
        const activeB = b.isYou ? true : isPlayerActive(b);
        if (activeA !== activeB) return activeA ? -1 : 1;
        const aVal = Number.isFinite(avgA) ? avgA : -Infinity;
        const bVal = Number.isFinite(avgB) ? avgB : -Infinity;
        if (aVal !== bVal) return bVal - aVal;
        break;
      }
      case "baseline-desc": {
        if (baselineA !== baselineB) return baselineB - baselineA;
        break;
      }
      case "created-desc": {
        if (createdA !== createdB) return createdB - createdA;
        break;
      }
      case "created-asc": {
        if (createdA !== createdB) return createdA - createdB;
        break;
      }
      default:
        // name-asc
        break;
    }

    return nameA.localeCompare(nameB);
  };

  const sortedPlayers = players.slice().sort(comparePlayers);

  const appendPlayerCard = (p, targetContainer) => {
    const card = document.createElement("div");
    card.dataset.playerId = p.id;
    const isActive = p.isYou ? true : isPlayerActive(p);

    // ----- GALLERY VIEW (image + name only) -----
    if (viewMode === "gallery") {
      card.className = "playerCard rounded-xl p-2 glass flex flex-col items-center";

      const displayName = p.isYou ? "You" : (p.name || "");
      const imageUrl = p.imageId ? getCachedImageUrl(p.imageId) : "";

      card.innerHTML = `
        <div class="w-full md:w-44 aspect-[3/4] player-img-frame">
          <div class="player-img-inner w-full h-full">
            ${
              imageUrl
                ? `<img src="${escapeHtml(imageUrl)}"
                         alt="${escapeHtml(displayName)} photo"
                         class="w-full h-full object-cover">`
                : `<div class="text-xs opacity-70 p-4 text-center flex items-center justify-center h-full bg-black">
                     No photo
                   </div>`
            }
          </div>
        </div>
        <p class="mt-1 text-xs sm:text-sm font-medium text-center break-words leading-snug ${!isActive ? "player-inactive-text" : ""}">
          ${escapeHtml(displayName)}
        </p>
      `;

      // NEW: clicking the image in gallery view opens edit mode for that player
      const imgArea = card.querySelector(".player-img-inner");
      if (imgArea) {
        imgArea.style.cursor = "pointer";
        imgArea.addEventListener("click", () => {
          viewMode = "card";
          editingPlayerId = p.id;          // same as hitting the Edit button

          renderPlayers();
          if (typeof updateViewToggleUI === "function") {
            updateViewToggleUI();
          }

          // After re-render, scroll their card into view
          requestAnimationFrame(() => {
            const target = document.querySelector(
              `.playerCard[data-player-id="${p.id}"]`
            );
            if (target) {
              target.scrollIntoView({ behavior: "smooth", block: "center" });
            }
          });
        });
      }

      targetContainer.appendChild(card);
      return; // skip card-mode logic

    }

    // ----- CARD VIEW (existing behavior) -----
    card.className = "playerCard rounded-xl p-3 glass flex flex-col gap-2";

    // ---------- YOU CARD ----------
    if (p.isYou) {

  // 🔹 EDIT MODE for YOU (photo-only)
  if (editingPlayerId === "YOU") {
    const youImageUrl = p.imageId ? getCachedImageUrl(p.imageId) : "";
    card.innerHTML = `
      <div class="w-full md:w-44 aspect-[3/4] player-img-frame">
        <div class="player-img-inner w-full h-full">
          ${
            youImageUrl
              ? `<img src="${escapeHtml(youImageUrl)}" alt="Your photo"
                     class="w-full h-full object-cover">`
              : `<div class="text-xs opacity-70 p-4 text-center flex items-center justify-center h-full bg-black">
                   No photo
                 </div>`
          }
        </div>
      </div>

      <div class="flex-1 flex flex-col gap-2">
        <div class="flex flex-wrap items-center justify-between gap-2">
          <h3 class="font-semibold text-base md:text-lg break-words">You</h3>
          <div class="flex gap-2 flex-wrap">
            <button data-act="change-you-photo" data-id="YOU"
              class="rounded-xl border px-3 py-1.5 text-sm">
              Add / Change Photo
            </button>
            <button data-act="clear-you-photo" data-id="YOU"
              class="rounded-xl border px-3 py-1.5 text-sm">
              Remove Photo
            </button>
            <button data-act="done-you" data-id="YOU"
              class="rounded-xl border px-3 py-1.5 text-sm">
              Done
            </button>
          </div>
        </div>

        <div class="text-xs opacity-80 leading-[1.0] space-y-[2px] mt-1">
          <p>Record: ${youStats.record}</p>
          <p>PPD: ${youStats.avgPPD.toFixed(1)}</p>
         
        </div>
      </div>
    `;

    targetContainer.appendChild(card);
    return;
  }

// 🔹 VIEW MODE for YOU – matches other cards
const youImageUrl = p.imageId ? getCachedImageUrl(p.imageId) : "";
card.innerHTML = `
  <div class="flex flex-col gap-3 w-full">
    <div class="flex items-start justify-between gap-3">
      <h3 class="font-semibold text-base md:text-lg break-words">You</h3>
    </div>

    <div class="flex flex-col md:flex-row items-start gap-3">
      <div class="w-full md:w-44 aspect-[3/4] player-img-frame">
        <div class="player-img-inner w-full h-full">
          ${
            youImageUrl
              ? `<img src="${escapeHtml(youImageUrl)}" alt="Your photo"
                     class="w-full h-full object-cover">`
              : `<div class="text-xs opacity-70 p-4 text-center flex items-center justify-center h-full bg-black">
                   No photo
                 </div>`
          }
        </div>
      </div>

      <div class="flex-1 min-w-0">
        <div class="text-xs opacity-80 leading-[1.0] space-y-[2px] mt-1">
          <p>Record: ${youStats.record}</p>
          <p>PPD: ${youStats.avgPPD.toFixed(1)}</p>
        </div>
      </div>

      <div class="flex w-full md:w-auto justify-end md:justify-start">
        <button data-act="edit" data-id="YOU"
          class="rounded-xl border px-3 py-1.5 text-sm">
          Edit
        </button>
      </div>
    </div>
  </div>
`;


  targetContainer.appendChild(card);
  return;
}


    // ---------- NORMAL PLAYERS ----------
    if (editingPlayerId === p.id) {
      const playerImageUrl = p.imageId ? getCachedImageUrl(p.imageId) : "";
      // Edit mode
      card.innerHTML = `
        <div class="w-full md:w-56 flex flex-col items-center gap-2">
          <div class="w-full flex items-center justify-center bg-black/40 rounded-2xl overflow-hidden border border-zinc-700">
            ${
              playerImageUrl
                ? `<img src="${escapeHtml(playerImageUrl)}" alt="${escapeHtml(p.name)} photo"
                       class="max-h-56 w-full object-contain bg-black">`
                : `<div class="text-xs opacity-70 p-4 text-center">No photo</div>`
            }
          </div>
          ${
            playerImageUrl
              ? `
                <button data-act="recrop" data-id="${p.id}"
                  class="mt-1 rounded-xl border border-zinc-500 px-3 py-1 text-xs">
                  Re-crop current photo
                </button>
              `
              : ``
          }
        </div>
        <div class="flex-1 space-y-3">
          <input
            data-field="name"
            class="w-full px-3 py-2 rounded-xl border"
            value="${escapeHtmlAttr(p.name)}"
          />
          <textarea
            data-field="notes"
            class="w-full px-3 py-2 rounded-xl border"
            rows="3"
          >${escapeHtml(p.notes || "")}</textarea>

          <div class="flex items-center gap-2 text-xs">
            <input
              data-field="active"
              type="checkbox"
              class="toggle-switch"
              ${isActive ? "checked" : ""}
            />
            <span class="opacity-80">Active</span>
          </div>

          <!-- New: editable stats -->
          <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
            <div>
              <label class="opacity-70 block mb-1">Baseline</label>
              <input
                data-field="baseline"
                type="number"
                min="0"
                max="100"
                class="w-full px-3 py-2 rounded-xl border text-sm"
                value="${typeof p.baseline === "number" ? p.baseline : 60}"
              />
            </div>
            <div>
              <label class="opacity-70 block mb-1">Variance</label>
              <input
                data-field="variance"
                type="number"
                min="0"
                max="100"
                class="w-full px-3 py-2 rounded-xl border text-sm"
                value="${typeof p.variance === "number" ? p.variance : 40}"
              />
            </div>
            <div>
              <label class="opacity-70 block mb-1">Variance Tilt (0–100)</label>
              <input
                data-field="varianceTilt"
                type="number"
                min="0"
                max="100"
                class="w-full px-3 py-2 rounded-xl border text-sm"
                value="${Number.isFinite(p.varianceTilt) ? p.varianceTilt : 50}"
              />
            </div>
            <div>
              <label class="opacity-70 block mb-1">Momentum</label>
              <input
                data-field="momentum"
                type="number"
                min="0"
                max="100"
                class="w-full px-3 py-2 rounded-xl border text-sm"
                value="${typeof p.momentum === "number" ? p.momentum : 50}"
              />
            </div>
            <div>
              <label class="opacity-70 block mb-1">Risky</label>
              <input
                data-field="risky"
                type="number"
                min="0"
                max="100"
                class="w-full px-3 py-2 rounded-xl border text-sm"
                value="${
                  typeof p.risky === "number"
                    ? (p.risky <= 10 ? (p.risky * 10).toFixed(0) : p.risky.toFixed(0))
                    : 30
                }"
              />
            </div>
            <div class="md:col-span-4">
              <label class="opacity-70 block mb-1">Style</label>
              <input
                data-field="style"
                class="w-full px-3 py-2 rounded-xl border text-sm"
                value="${escapeHtmlAttr(p.style || "")}"
              />
            </div>
          </div>

          <div>
            <label class="text-xs opacity-70 block mb-1">Change photo (optional)</label>
            <input
              data-field="image"
              type="file"
              accept="image/png,image/jpeg,image/jpg,image/gif"
              class="w-full text-sm"
            />
          </div>

          <div class="flex flex-wrap gap-2">
            <button data-act="save" data-id="${p.id}"
              class="rounded-xl bg-emerald-500 hover:bg-emerald-600 text-white text-sm px-3 py-1.5">
              Save
            </button>
            <button data-act="cancel" data-id="${p.id}"
              class="rounded-xl border text-sm px-3 py-1.5">
              Cancel
            </button>
          </div>

          <div class="flex flex-wrap gap-2 mt-3">
            <button class="rounded-xl border px-3 py-1.5 text-sm"
                    data-act="clear-photo"
                    data-id="${p.id}">
              Remove photo
            </button>

            <button class="rounded-xl border px-3 py-1.5 text-sm bg-red-600 text-white"
                    data-act="delete"
                    data-id="${p.id}">
              Delete
            </button>
          </div>



        </div>
      `;
    } else {
      // View mode

      const stats = historyStats.get(p.id) || { games: 0, totalPoints: 0, scores: [] };
      const games = stats.games || 0;
      const avgVal = games ? (stats.totalPoints / games) : null;
      const avgPpd = Number.isFinite(avgVal) ? avgVal.toFixed(1) : "—";
      const baselineVal = Number.isFinite(p.baseline) ? p.baseline : 0;
      const wins = (stats.scores || []).filter(score => score >= baselineVal).length;
      const losses = games ? Math.max(0, games - wins) : 0;
      const recordText = games ? `${wins}-${losses}` : "0-0";
      const playerImageUrl = p.imageId ? getCachedImageUrl(p.imageId) : "";

card.innerHTML = `
  <div class="flex flex-col gap-3 w-full">
    <div class="flex items-start justify-between gap-3">
      <h3 class="font-semibold text-base md:text-lg break-words ${!isActive ? "player-inactive-text" : ""}">
        ${escapeHtml(p.name || "")}
      </h3>
    </div>

    <div class="flex flex-col md:flex-row items-start gap-3">
      <div class="w-full md:w-44 aspect-[3/4] player-img-frame">
        <div class="player-img-inner w-full h-full">
          ${
            playerImageUrl
              ? `<img src="${escapeHtml(playerImageUrl)}" alt="${escapeHtml(p.name || "Player")} photo"
                     class="w-full h-full object-cover">`
              : `<div class="text-xs opacity-70 p-4 text-center flex items-center justify-center h-full bg-black">
                   No photo
                 </div>`
          }
        </div>
      </div>

      <div class="flex-1 min-w-0 ${!isActive ? "player-inactive-text" : ""}">
        <div class="text-xs opacity-80 leading-[1.0] space-y-[2px]">
          <p>Record: ${recordText}</p>
          <p>PPD: ${avgPpd}</p>
          <p>Baseline: ${p.baseline ?? "—"}</p>
          <p>Variance: ${p.variance ?? "—"}</p>
          <p>Momentum: ${p.momentum ?? "—"}</p>
          <p>Variance Tilt: ${Number.isFinite(p.varianceTilt) ? `${p.varianceTilt}%` : "50%"}</p>
          <p>Risky: ${
            typeof p.risky === "number"
              ? (p.risky <= 10 ? p.risky.toFixed(1) : (p.risky / 10).toFixed(1))
              : "—"
          }</p>
          <p>Style: ${escapeHtml(p.style || "—")}</p>
        </div>

        <p class="mt-2 text-sm opacity-80 italic">
          ${p.notes ? escapeHtml(p.notes) : "No notes yet."}
        </p>
      </div>

      <div class="flex w-full md:w-auto justify-end md:justify-start">
        <button data-act="edit" data-id="${p.id}"
          class="rounded-xl border px-3 py-1.5 text-sm">
          Edit
        </button>
      </div>
    </div>
  </div>
`;
    }

    targetContainer.appendChild(card);
  };

  if (groupActivePlayers) {
    const activePlayers = sortedPlayers.filter((p) => (p.isYou ? true : isPlayerActive(p)));
    const inactivePlayers = sortedPlayers.filter((p) => !(p.isYou ? true : isPlayerActive(p)));

    const buildGroup = (title, list) => {
      if (!list.length) return;
      const group = document.createElement("div");
      group.className = "player-group";

      const header = document.createElement("div");
      header.className = "player-group-title mb-3";
      header.textContent = title;
      group.appendChild(header);

      const grid = document.createElement("div");
      applyPlayersGridLayout(grid);
      group.appendChild(grid);

      list.forEach((p) => appendPlayerCard(p, grid));
      container.appendChild(group);
    };

    buildGroup("Active players", activePlayers);
    buildGroup("Inactive players", inactivePlayers);
  } else {
    sortedPlayers.forEach((p) => appendPlayerCard(p, container));
  }

  container.querySelectorAll("button[data-act]").forEach(btn => {
    btn.addEventListener("click", handlePlayerAction);
  });

}
    async function handlePlayerAction(e){
      const btn = e.currentTarget;
      const id = btn.getAttribute("data-id");
      const act = btn.getAttribute("data-act");
      if (!id || !act) return;

      if (act === "edit"){
        editingPlayerId = id;
        renderPlayers();
        return;
      }

      if (act === "cancel"){
        editingPlayerId = null;
        renderPlayers();
        return;
      }

      if (act === "delete"){
        const player = state.players.find(p => p.id === id);
        const name = player && player.name ? `"${player.name}"` : "this player";
        if (!confirm(`Delete ${name}? This cannot be undone.`)) return;
        const idx = state.players.findIndex(p => p.id === id);
        if (idx !== -1){
          const lastKnownName = player && player.name ? player.name : "Unnamed";
          const matchups = Array.isArray(state.matchups) ? state.matchups : [];
          matchups.forEach(m => {
            if (!m) return;
            if (m.playerAId === id) m.playerAName = m.playerAName || lastKnownName;
            if (m.playerBId === id) m.playerBName = m.playerBName || lastKnownName;
          });
          await deleteImageById(player?.imageId);
          state.players.splice(idx,1);
          refreshScheduleAfterRosterChange();
          state = saveState(state);
        }
        if (editingPlayerId === id) editingPlayerId = null;
        renderPlayers();
        return;
      }

      if (act === "recrop"){
        const player = state.players.find(p => p.id === id);
        if (!player || !player.imageId) return;
        const { getImageBlob } = getImageHelper();
        if (typeof getImageBlob !== "function") return;
        const blob = await getImageBlob(player.imageId);
        if (!blob) return;
        openImageCropperFromBlob(blob, async (dataUrl)=>{
          if (dataUrl){
            const nextImageId = await saveImageFromDataUrl(dataUrl, player.imageId);
            player.imageId = nextImageId || "";
            state = saveState(state);
          }
          renderPlayers();
        });
        return;
      }

      if (act === "clear-photo"){
        const player = state.players.find(p => p.id === id);
        if (!player || !player.imageId) return;

        if (!confirm("Remove this player's photo? You can add a new one later.")) return;

        await deleteImageById(player.imageId);
        player.imageId = "";
        state = saveState(state);
        renderPlayers();
        return;
      }

  // --- Change YOU photo ---
  if (act === "change-you-photo") {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "image/png,image/jpeg,image/jpg,image/gif";

    input.onchange = async () => {
      const file = input.files[0];
      if (!file) return;

      openImageCropperFromFile(file, async (dataUrl) => {
        if (!dataUrl) return;
        const nextImageId = await saveImageFromDataUrl(dataUrl, state.youImageId);
        state.youImageId = nextImageId || "";
        state = saveState(state, { allowStickyOverwriteKeys: ["youImageId"] });
        renderPlayers();
      });
    };

    input.click();
    return;
  }

  // --- Clear YOU photo ---
  if (act === "clear-you-photo") {
    await deleteImageById(state.youImageId);
    state.youImageId = "";
    state = saveState(state, { allowStickyOverwriteKeys: ["youImageId"] });
    renderPlayers();
    return;
  }

  // --- Done editing YOU ---
  if (act === "done-you") {
    editingPlayerId = null;
    renderPlayers();
    return;
  }



      if (act === "save"){
        const card = btn.closest(".playerCard");
        if (!card) return;
        const nameInput = card.querySelector('input[data-field="name"]');
        const notesInput = card.querySelector('textarea[data-field="notes"]');
        const fileInput = card.querySelector('input[data-field="image"]');
        const activeInput = card.querySelector('input[data-field="active"]');
  const baselineInput  = card.querySelector('input[data-field="baseline"]');
  const varianceInput  = card.querySelector('input[data-field="variance"]');
  const varianceTiltInput = card.querySelector('input[data-field="varianceTilt"]');
  const momentumInput  = card.querySelector('input[data-field="momentum"]');
  const riskyInput     = card.querySelector('input[data-field="risky"]');
  const styleInput     = card.querySelector('input[data-field="style"]');

        const player = state.players.find(p => p.id === id);
        if (!player) return;

        const wasActive = isPlayerActive(player);

        const newName = (nameInput.value || "").trim();
        if (!newName){
          alert("Player name is required.");
          return;
        }

        const newNotes = (notesInput.value || "").trim();
  const nextActive = activeInput ? activeInput.checked : wasActive;
  const baseline = baselineInput
    ? Number(baselineInput.value || 60)
    : (typeof player.baseline === "number" ? player.baseline : 60);

  const variance = varianceInput
    ? Number(varianceInput.value || 40)
    : (typeof player.variance === "number" ? player.variance : 40);

  const varianceTilt = varianceTiltInput
    ? Number(varianceTiltInput.value || 50)
    : (typeof player.varianceTilt === "number" ? player.varianceTilt : 50);

  const momentum = momentumInput
    ? Number(momentumInput.value || 50)
    : (typeof player.momentum === "number" ? player.momentum : 50);

  // Risky: always treat input as whole number, store as /10
  const risky = riskyInput
    ? Number(riskyInput.value || 30) / 10
    : (typeof player.risky === "number" ? player.risky : 3);

  const style = styleInput
    ? (styleInput.value || "").trim()
    : (player.style || "");

  const applyUpdate = async (imageData) => {
    player.name = newName;
    player.notes = newNotes;
    player.active = nextActive;

    player.baseline = isNaN(baseline) ? 60 : baseline;
    player.variance = isNaN(variance) ? 40 : variance;
    player.varianceTilt = Math.min(100, Math.max(0, isNaN(varianceTilt) ? 50 : varianceTilt));
    player.momentum = isNaN(momentum) ? 50 : momentum;
    player.risky    = isNaN(risky) ? 3 : risky;
    player.style    = style || "balanced";


    if (imageData){
      const nextImageId = await saveImageFromDataUrl(imageData, player.imageId);
      player.imageId = nextImageId || "";
    }
    if (wasActive !== nextActive) {
      refreshScheduleAfterRosterChange();
    }
    state = saveState(state);
    editingPlayerId = null;
    renderPlayers();
  };


        const file = fileInput.files && fileInput.files[0];
        if (file){
          openImageCropperFromFile(file, (dataUrl) => {
            applyUpdate(dataUrl);
          });
        } else {
          applyUpdate(undefined);
        }
      }
    }

    function escapeHtml(str){
      if (!str && str !== 0) return "";
      return String(str).replace(/[&<>"']/g, m => ({
        "&":"&amp;",
        "<":"&lt;",
        ">":"&gt;",
        '"':"&quot;",
        "'":"&#039;"
      }[m]));
    }
    function escapeHtmlAttr(str){
      if (!str) return "";
      return String(str).replace(/["']/g, m => ({
        '"':"&quot;",
        "'":"&#039;"
      }[m]));
    }

// Create player form
$("createPlayerForm").addEventListener("submit", (e)=>{
  e.preventDefault();
  const name = ($("playerName").value || "").trim();
  const notes = ($("playerNotes").value || "").trim();
  const file = $("playerImage").files && $("playerImage").files[0];
  const isActive = $("playerActive").checked;

  const baseline = Number($("playerBaseline").value || 60);
  const variance = Number($("playerVariance").value || 40);
  const varianceTilt = Number($("playerVarianceTilt").value || 50);
  const momentum = Number($("playerMomentum").value || 50);

  // NEW: Risky is stored as decimal (input / 10)
  const riskyInputRaw = Number($("playerRisky").value || 30);
  const risky = riskyInputRaw / 10;

  const style = ($("playerStyle").value || "").trim();


  if (!name){
    alert("Player name is required.");
    return;
  }

  const addPlayer = async (imageData) => {
    const imageId = imageData ? await saveImageFromDataUrl(imageData) : "";

    state.players.push({
      id: makeId(),
      name,
      notes,
      imageId: imageId || "",
      createdAtISO: new Date().toISOString(),
      active: isActive,

      baseline: isNaN(baseline) ? 35 : baseline,
      variance: isNaN(variance) ? 9 : variance,
      varianceTilt: Math.min(100, Math.max(0, isNaN(varianceTilt) ? 50 : varianceTilt)),
      momentum: isNaN(momentum) ? 5 : momentum,

      // Default Risky = 3.0 (i.e. user sees 30)
      risky: isNaN(risky) ? 3 : risky,

      style: style || "balanced"

    });
    refreshScheduleAfterRosterChange();
    state = saveState(state);
    $("playerName").value = "";
    $("playerNotes").value = "";
    $("playerImage").value = "";
    $("playerBaseline").value = "60";
    $("playerVariance").value = "40";
    $("playerVarianceTilt").value = "50";
    $("playerMomentum").value = "50";
    $("playerRisky").value = "30";
    $("playerStyle").value = "";
    $("playerActive").checked = true;
    renderPlayers();
  };

  if (file){
    openImageCropperFromFile(file, (dataUrl) => {
      addPlayer(dataUrl);
    });
  } else {
    addPlayer(null);
  }
});


// Export / Import / Paste / Reset
// (Handled on the main page now; Game view is read-only for backup controls.)


// ----- Sort dropdown -----
const playerSortSelect = document.getElementById("playerSort");

function updateSortSelectUI() {
  if (!playerSortSelect) return;
  playerSortSelect.value = playerSortMode;
}

if (playerSortSelect) {
  playerSortSelect.addEventListener("change", (e) => {
    const mode = e.target.value;
    if (!PLAYER_SORT_OPTIONS.includes(mode)) return;
    persistSortMode(mode);
    renderPlayers();
  });
}


// Auto-sim once per day after 8am, then render
renderPlayers(); // always render even if auto-sim dies

try {
  maybeAutoSimToday();
} catch (e) {
  console.error("Auto-sim failed; leaving UI rendered", e);
}

// If auto-sim succeeded, it already calls renderPlayers() internally,
// but calling again is harmless:
renderPlayers();


// ----- View mode toggle (Card vs Gallery) -----
const viewCardBtn = document.getElementById("viewCardBtn");
const viewGalleryBtn = document.getElementById("viewGalleryBtn");
const groupActiveToggle = document.getElementById("groupActiveToggle");
const galleryColumnsControl = document.getElementById("galleryColumnsControl");
const galleryColumnsSelect = document.getElementById("galleryColumnsSelect");

function updateGalleryColumnsControl() {
  if (!galleryColumnsSelect) return;
  const orientation = getGalleryOrientation();
  const options = orientation === "landscape" ? [3, 4] : [2, 3];
  const desired = galleryColumns[orientation];
  const nextOptions = options.map((value) => ({
    value,
    label: `${value} columns`
  }));

  galleryColumnsSelect.innerHTML = nextOptions
    .map((opt) => `<option value="${opt.value}">${opt.label}</option>`)
    .join("");

  if (options.includes(desired)) {
    galleryColumnsSelect.value = String(desired);
  } else {
    galleryColumnsSelect.value = String(options[0]);
  }
}

function updateViewToggleUI() {
  if (!viewCardBtn || !viewGalleryBtn) return;

  if (viewMode === "card") {
    viewCardBtn.classList.add("bg-zinc-800", "text-white");
    viewGalleryBtn.classList.remove("bg-zinc-800", "text-white");
    viewGalleryBtn.classList.add("bg-zinc-900/40");
  } else {
    viewGalleryBtn.classList.add("bg-zinc-800", "text-white");
    viewCardBtn.classList.remove("bg-zinc-800", "text-white");
    viewCardBtn.classList.add("bg-zinc-900/40");
  }

  if (galleryColumnsControl) {
    galleryColumnsControl.classList.toggle("hidden", viewMode !== "gallery");
    galleryColumnsControl.classList.toggle("flex", viewMode === "gallery");
  }

  if (viewMode === "gallery") {
    updateGalleryColumnsControl();
  }
}

function updateGroupToggleUI() {
  if (!groupActiveToggle) return;
  groupActiveToggle.checked = groupActivePlayers;
}

if (viewCardBtn) {
  viewCardBtn.addEventListener("click", () => {
    viewMode = "card";
    editingPlayerId = null; // leave edit mode when switching
    renderPlayers();
    updateViewToggleUI();
  });
}

if (viewGalleryBtn) {
  viewGalleryBtn.addEventListener("click", () => {
    viewMode = "gallery";
    editingPlayerId = null;
    renderPlayers();
    updateViewToggleUI();
  });
}

if (groupActiveToggle) {
  groupActiveToggle.addEventListener("change", (e) => {
    persistGroupActivePlayers(e.target.checked);
    renderPlayers();
  });
}

if (galleryColumnsSelect) {
  galleryColumnsSelect.addEventListener("change", (e) => {
    const value = Number(e.target.value);
    const orientation = getGalleryOrientation();
    if (orientation === "portrait" && (value === 2 || value === 3)) {
      persistGalleryColumns({ ...galleryColumns, portrait: value });
    }
    if (orientation === "landscape" && (value === 3 || value === 4)) {
      persistGalleryColumns({ ...galleryColumns, landscape: value });
    }
    document
      .querySelectorAll(".players-grid")
      .forEach((grid) => applyGalleryColumnsToContainer(grid));
  });
}

const galleryOrientationQuery = window.matchMedia("(orientation: landscape)");
galleryOrientationQuery.addEventListener("change", () => {
  updateGalleryColumnsControl();
  document
    .querySelectorAll(".players-grid")
    .forEach((grid) => applyGalleryColumnsToContainer(grid));
});

// Initialize toggle styling
updateViewToggleUI();
updateGroupToggleUI();

// ----- Collapsible panels (Create Player + Player Stats Guide) -----
function setupMobileCollapsibles() {
  const sections = document.querySelectorAll(".mobile-collapsible");

  function syncForViewport() {
    const isMobile = window.matchMedia("(max-width: 640px)").matches;

    sections.forEach((sec) => {
      // Wire header click once
      if (!sec.dataset.init) {
        const header = sec.querySelector(".mobile-collapsible-header");
        if (header) {
          header.addEventListener("click", () => {
            // Toggle on ALL viewports
            const collapsed = sec.dataset.collapsed === "true";
            sec.dataset.collapsed = collapsed ? "false" : "true";
          });
        }
        sec.dataset.init = "true";
      }

      const isStatsGuide = sec.id === "playerStatsGuide";

      // Default per viewport:
      // mobile → collapsed for all
      // desktop → Stats Guide collapsed, others expanded
      if (isMobile) {
        sec.dataset.collapsed = "true";
      } else {
        sec.dataset.collapsed = isStatsGuide ? "true" : "false";
      }
    });
  }

  syncForViewport();
  window.addEventListener("resize", syncForViewport);
}


setupMobileCollapsibles();


async function fileToDataUrl(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.readAsDataURL(file);
  });
}

  </script>

  <button
    class="hidden md:hidden fixed top-3 right-3 z-40 btn btn-teal rounded-full shadow-lg px-4 py-2 text-sm flex items-center gap-1"
    type="button"
    data-scroll-top
  >
    <span>⬆️</span>
    <span>Top</span>
  </button>
</body>
</html>
