<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TaskPoints — Daily Scores</title>

  <!-- Simple TP favicon so this page still looks legit -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%230a2f2f'/><text x='50' y='60' font-size='48' text-anchor='middle' fill='white'>TP</text></svg>">

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles.css">
  <script src="scoring_core.js"></script>
  <script src="toolbar.js" defer></script>
</head>
<body class="min-h-screen">
  <div class="mx-auto max-w-6xl p-4 sm:p-6">

    <div class="flex items-center justify-between gap-3 mb-3 md:hidden">
      <a href="index.html" class="flex items-center gap-3">
        <img src="assets/taskpoints-logo.png" alt="TaskPoints logo" class="w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm">
        <h1 class="text-2xl font-extrabold tracking-tight leading-tight">
          <span style="color:#fb923c;">Task</span><span style="color:#1e666d;">Points</span>
        </h1>
      </a>
      <div class="flex items-center gap-2">
        <button type="button" class="btn btn-ghost btn-toolbar" data-export-button>Export</button>
        <label class="btn btn-ghost btn-toolbar cursor-pointer">
          <span>Import</span>
          <input type="file" accept="application/json" class="hidden" data-import-input/>
        </label>
      </div>
    </div>

    <header class="flex items-center justify-between mb-4 gap-3 flex-wrap">
      <h1 class="text-2xl font-extrabold page-title">Daily Scores</h1>
      <div class="toolbar header-nav">
        <a href="index.html"         class="btn btn-teal btn-toolbar nav-btn">Main</a>
        <a href="today.html" class="btn btn-teal btn-toolbar nav-btn">Today</a>
        <a href="daily_sources.html" class="btn btn-teal btn-toolbar nav-btn">Sources</a>
        <a href="log.html"           class="btn btn-teal btn-toolbar nav-btn">Log</a>
        <a href="week.html"          class="btn btn-teal btn-toolbar nav-btn">Week</a>
        <div class="dropdown">
          <button type="button" class="btn btn-teal btn-toolbar nav-btn dropdown-toggle" data-dropdown-toggle aria-expanded="false">Game <span class="caret">▾</span></button>
          <div class="dropdown-menu">
            <a href="gamehub.html" class="btn btn-teal btn-toolbar nav-btn">Game Hub</a>
            <a href="game.html"         class="btn btn-teal btn-toolbar nav-btn">Players</a>
            <a href="standings.html"    class="btn btn-teal btn-toolbar nav-btn">Standings</a>
            <a href="matchups.html"     class="btn btn-teal btn-toolbar nav-btn">Matchups</a>
            <a href="schedule.html"     class="btn btn-teal btn-toolbar nav-btn">Schedule</a>
            <a href="game_ratings.html" class="btn btn-teal btn-toolbar nav-btn">Ratings</a>
            <a href="records.html"      class="btn btn-teal btn-toolbar nav-btn">Records</a>
          </div>
        </div>
        <a href="projects.html" class="btn btn-teal btn-toolbar nav-btn">Projects</a>
        <a href="settings.html" class="btn btn-teal btn-toolbar nav-btn">Settings</a>
      </div>
    </header>

    <main class="space-y-4">
      <div class="glass">
        <h2 class="font-semibold mb-1">All Daily Scores</h2>
        <p class="muted text-xs mb-3">
          One row per day with any activity, from your first day onward.
        </p>
        <div id="dailySummary" class="text-xs mb-2 muted"></div>
        <div id="scoresList" class="text-xs max-h-[70vh] overflow-y-auto space-y-1"></div>
      </div>
    </main>

  </div>

  <button
    class="hidden md:hidden fixed top-3 right-3 z-40 btn btn-teal rounded-full shadow-lg px-4 py-2 text-sm flex items-center gap-1"
    type="button"
    data-scroll-top
  >
    <span>⬆️</span>
    <span>Top</span>
  </button>

  <script>
    const STORAGE_KEY = "taskpoints_v1";
    const $ = id => document.getElementById(id);

    // Same bonus rules as main app
    function sleepBonus(score) {
      if (window.TaskPointsCore?.sleepBonus) {
        return TaskPointsCore.sleepBonus(score, state);
      }
      if (score >= 100) return 3;
      if (score >= 98) return 2;
      if (score >= 95) return 1;
      return 0;
    }

    function getSleepInfo(entry) {
      const match = entry?.title?.match(/\((\d+)\)/);
      const score = match ? Number(match[1]) : null;

      const restedRaw = entry && Object.prototype.hasOwnProperty.call(entry, 'sleepRested')
        ? Number(entry.sleepRested)
        : 0;
      const rested = Number.isFinite(restedRaw) ? restedRaw : 0;

      return { score, rested };
    }

    function sleepPoints(score, rested = 0) {
      if (window.TaskPointsCore?.sleepPoints) {
        return TaskPointsCore.sleepPoints(score, rested, state);
      }
      if (!Number.isFinite(score)) return 0;
      const base  = score / 10;
      const bonus = sleepBonus(score);
      return base + bonus + (Number.isFinite(rested) ? rested : 0);
    }

    function getWorkInfo(entry) {
      const match = entry?.title?.match(/\(([^)]+)\)/);
      const score = match ? Number(match[1]) : null;

      const hoursRaw = entry && Object.prototype.hasOwnProperty.call(entry, 'workHours')
        ? Number(entry.workHours)
        : 0;
      const hours = Number.isFinite(hoursRaw) ? hoursRaw : 0;

      return { score, hours };
    }

    function workHoursBonus(hours = 0) {
      if (window.TaskPointsCore?.workHoursBonus) {
        return TaskPointsCore.workHoursBonus(hours, state);
      }
      if (!Number.isFinite(hours)) return 0;
      return Math.max(0, hours) * 10;
    }

    function workPoints(score, hours = 0) {
      if (window.TaskPointsCore?.workPoints) {
        return TaskPointsCore.workPoints(score, hours, state);
      }
      if (!Number.isFinite(score)) return 0;
      return score + workHoursBonus(hours);
    }

    function load() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          return {
            tasks: [],
            completions: [],
            players: [],
            habits: [],
            flexActions: [],
            gameHistory: [],
            matchups: [],
            schedule: [],
            opponentDripSchedules: [],
            scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
              ? TaskPointsCore.normalizeScoringSettings({})
              : {}
          };
        }

        const parsed = JSON.parse(raw) || {};
        return {
          tasks:       Array.isArray(parsed.tasks)       ? parsed.tasks       : [],
          completions: Array.isArray(parsed.completions) ? parsed.completions : [],
          players:     Array.isArray(parsed.players)     ? parsed.players     : [],
          habits:      Array.isArray(parsed.habits)      ? parsed.habits      : [],
          flexActions: Array.isArray(parsed.flexActions) ? parsed.flexActions : [],
          gameHistory: Array.isArray(parsed.gameHistory) ? parsed.gameHistory : [],
          matchups:    Array.isArray(parsed.matchups)    ? parsed.matchups    : [],
          schedule:    Array.isArray(parsed.schedule)    ? parsed.schedule    : [],
          opponentDripSchedules: Array.isArray(parsed.opponentDripSchedules) ? parsed.opponentDripSchedules : [],
          scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
            ? TaskPointsCore.normalizeScoringSettings(parsed.scoringSettings || {})
            : (parsed.scoringSettings || {})
        };
      } catch (e) {
        console.error("Failed to load TaskPoints state", e);
        return {
          tasks: [],
          completions: [],
          players: [],
          habits: [],
          flexActions: [],
          gameHistory: [],
          matchups: [],
          schedule: [],
          opponentDripSchedules: [],
          scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
            ? TaskPointsCore.normalizeScoringSettings({})
            : {}
        };
      }
    }

let state = load();

function normalizeHexColor(value) {
  if (!value) return null;
  let hex = String(value).trim();
  if (!hex) return null;
  if (!hex.startsWith('#')) hex = `#${hex}`;
  if (!/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(hex)) return null;
  if (hex.length === 4) {
    hex = `#${hex.slice(1).split('').map((c) => c + c).join('')}`;
  }
  return hex.toLowerCase();
}

function normalizeHabitTagColors(value) {
  if (!value || typeof value !== 'object') return {};
  const next = {};
  Object.entries(value).forEach(([tag, color]) => {
    const normalized = normalizeHexColor(color);
    if (normalized) next[String(tag)] = normalized;
  });
  return next;
}

function normalizeHabit(habit) {
  if (!habit || typeof habit !== 'object') return habit;
  return {
    ...habit,
    tag: typeof habit.tag === 'string' ? habit.tag.trim() : ''
  };
}

function normalizeState(s) {
  return {
    tasks:       Array.isArray(s.tasks)       ? s.tasks       : [],
    completions: Array.isArray(s.completions) ? s.completions : [],
    players:     Array.isArray(s.players)     ? s.players     : [],
    habits:      Array.isArray(s.habits)      ? s.habits.map(normalizeHabit)      : [],
    flexActions: Array.isArray(s.flexActions) ? s.flexActions : [],
    gameHistory: Array.isArray(s.gameHistory) ? s.gameHistory : [],
    matchups:    Array.isArray(s.matchups)    ? s.matchups    : [],
    schedule:    Array.isArray(s.schedule)    ? s.schedule    : [],
    opponentDripSchedules: Array.isArray(s.opponentDripSchedules) ? s.opponentDripSchedules : [],
    workHistory: Array.isArray(s.workHistory) ? s.workHistory : [],
    youImageId:  typeof s.youImageId === "string" ? s.youImageId : "",
    habitTagColors: normalizeHabitTagColors(s.habitTagColors),
    scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
      ? TaskPointsCore.normalizeScoringSettings(s.scoringSettings || {})
      : (s.scoringSettings || {})
  };
}

function saveMerged(partial) {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    const existing = raw ? (JSON.parse(raw) || {}) : {};
    if (window.TaskPointsCore?.saveAppState) {
      return TaskPointsCore.saveAppState({ ...existing, ...partial }, { storageKey: STORAGE_KEY }).state;
    }
    if (window.TaskPointsCore?.mergeAndSaveState) {
      return TaskPointsCore.mergeAndSaveState({ ...existing, ...partial }, { storageKey: STORAGE_KEY }).state;
    }
    const merged = { ...existing, ...partial };
    console.warn("saveMerged skipped localStorage write; TaskPointsCore missing.");
    return merged;
  } catch (e) {
    console.error("saveMerged failed (daily.html)", e);
    return partial;
  }
}

function getCompletionPoints(entry) {
  if (window.TaskPointsCore?.pointsForCompletion) {
    return TaskPointsCore.pointsForCompletion(entry);
  }
  return Number(entry?.points) || 0;
}

function syncDerivedPointsIfNeeded() {
  if (!window.TaskPointsCore?.syncDerivedPoints) return;
  const derivedSync = TaskPointsCore.syncDerivedPoints(state);
  state = derivedSync.state;
  if (!derivedSync.changed) return;
  if (window.TaskPointsCore?.saveAppState) {
    state = TaskPointsCore.saveAppState(state).state;
  } else if (window.TaskPointsCore?.mergeAndSaveState) {
    state = TaskPointsCore.mergeAndSaveState(state).state;
  } else {
    state = saveMerged(state);
  }
}

    
    // Run the same sleep migration here so this page is safe even if opened first
    function migrateSleepEntriesForBonus() {
      if (!state || !Array.isArray(state.completions)) return;

      let changed = false;

      state.completions.forEach(c => {
        if (!c || !c.title || !c.title.startsWith("Sleep Score")) return;

        const { score, rested } = getSleepInfo(c);
        if (!Number.isFinite(score)) return;

        const restVal = Number.isFinite(rested) ? rested : 0;
        const newPts = sleepPoints(score, restVal);

        if (!Number.isFinite(c.sleepRested)) {
          c.sleepRested = restVal;
          changed = true;
        }

        if (Math.abs((Number(c.points) || 0) - newPts) > 0.0001) {
          c.points = newPts;
          changed = true;
        }
      });

if (changed) {
  state = saveMerged(state);
}

    }

    function migrateWorkEntriesForHours() {
      if (!state || !Array.isArray(state.completions)) return;

      let changed = false;

      state.completions.forEach(c => {
        if (!c || !c.title || !c.title.startsWith('Work Score')) return;

        const { score, hours } = getWorkInfo(c);
        const safeHours = Number.isFinite(hours) ? Math.max(0, hours) : 0;
        const safeScore = Number.isFinite(score) ? score : Number(c.points) || 0;
        const newPts = workPoints(safeScore, safeHours);

        if (!Number.isFinite(c.workHours) || c.workHours !== safeHours) {
          c.workHours = safeHours;
          changed = true;
        }

        if (c.source !== 'work') {
          c.source = 'work';
          changed = true;
        }

        const desiredTitle = Number.isFinite(score)
          ? `Work Score (${score}) — Hours ${safeHours}`
          : c.title;
        if (desiredTitle !== c.title) {
          c.title = desiredTitle;
          changed = true;
        }

        if (Math.abs((Number(c.points) || 0) - newPts) > 0.0001) {
          c.points = newPts;
          changed = true;
        }
      });

      if (changed) {
        state = saveMerged(state);
      }
    }

    migrateWorkEntriesForHours();

    function dateKey(d) {
      if (!(d instanceof Date)) d = new Date(d);
      if (!d || isNaN(d.getTime())) return "invalid";
      const y  = d.getFullYear();
      const m  = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${dd}`;
    }

    function fromKey(k) {
      if (!k || typeof k !== "string") return new Date(NaN);
      const parts = k.split("-");
      if (parts.length < 3) return new Date(NaN);
      const [yStr, mStr, dStr] = parts;
      const y = parseInt(yStr, 10);
      const m = parseInt(mStr, 10);
      const d = parseInt(dStr, 10);
      if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) {
        return new Date(NaN);
      }
      const dt = new Date(y, m - 1, d);
      dt.setHours(0, 0, 0, 0);
      return dt;
    }

    function niceDate(d) {
      if (!(d instanceof Date)) d = new Date(d);
      if (!d || isNaN(d.getTime())) return "Invalid date";
      return d.toLocaleDateString(undefined, {
        year:  "numeric",
        month: "short",
        day:   "numeric"
      });
    }

    function buildDailyTotals() {
      const daily = {};
      const comps = Array.isArray(state.completions) ? state.completions : [];

      comps.forEach(c => {
        if (!c || !c.completedAtISO) return;
        const d = new Date(c.completedAtISO);
        if (!d || isNaN(d.getTime())) return;
        d.setHours(0, 0, 0, 0);
        const key = dateKey(d);
      if (!daily[key]) daily[key] = 0;
        daily[key] += getCompletionPoints(c);
      });

      return daily;
    }

    function renderDailyScores() {
      const listEl = $("scoresList");
      const summaryEl = $("dailySummary");
      if (!listEl) return;

      const daily = buildDailyTotals();
      const keys = Object.keys(daily).sort(); // earliest → latest

      if (!keys.length) {
        listEl.innerHTML = '<div class="muted">No days logged yet.</div>';
        if (summaryEl) summaryEl.textContent = "";
        return;
      }

      const totalDays = keys.length;
      const totalPts = keys.reduce((sum, k) => sum + (daily[k] || 0), 0);
      const avg = totalPts / totalDays;

      if (summaryEl) {
        summaryEl.textContent = `${totalDays} days tracked • Average ${avg.toFixed(1)} pts/day`;
      }

listEl.innerHTML = keys.map(k => {
  const d = fromKey(k);
  const label = niceDate(d);
  const pts = daily[k] || 0;
  return `
    <div class="flex items-center gap-6">
      <span>${label}</span>
      <span class="font-mono">${pts.toFixed(1)}</span>
    </div>
  `;
}).join("");
}

    // Boot
    migrateSleepEntriesForBonus();
    syncDerivedPointsIfNeeded();
    renderDailyScores();
  </script>
  <div id="bottomToolbarMount"></div>
</body>
</html>
