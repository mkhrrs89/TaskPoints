<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TaskPoints — Matchups Log</title>

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="TaskPoints" />

  <!-- TP icon -->
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' rx='120' fill='black'/><text x='50%' y='55%' dominant-baseline='middle' text-anchor='middle' font-size='150' fill='white'>TP</text></svg>">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><rect width='128' height='128' rx='30' fill='black'/><text x='50%' y='55%' dominant-baseline='middle' text-anchor='middle' font-size='60' fill='white'>TP</text></svg>">

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="scoring_core.js"></script>
  <link rel="stylesheet" href="styles.css">
  <script src="toolbar.js" defer></script>

  <style>
    /* Match game.html body style so everything feels unified  */
    body{
      background:#fafafa;
      color:#111827;
    }
    @media (prefers-color-scheme: dark) {
      body{
        background:#0a0a0a;
        color:#fafafa;
      }
    }

    /* Heading for each day group */
    .matchup-day {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 0.35rem;
    }

    .matchup-player {
      font-size: 1.05rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .matchup-missing {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(148,163,184,0.35);
    }

    /* Individual matchup line, inside a glass-style section */
    .matchup-item {
      background: rgba(15,23,42,0.35);
      padding: 0.45rem 0.7rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(15,23,42,0.7);
      font-size: 0.9rem;
    }

    /* Highlight rows that involve YOU using a teal-ish accent */
    .matchup-item.you {
      background: rgba(34,197,94,0.15);
      border-color: rgba(34,197,94,0.55);
    }
  </style>
</head>
<body class="min-h-screen">
  <div class="mx-auto max-w-6xl p-4 sm:p-6">

    <div class="flex items-center justify-between gap-3 mb-3 md:hidden">
      <a href="index.html" class="flex items-center gap-3">
        <img src="assets/taskpoints-logo.png" alt="TaskPoints logo" class="w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm">
        <h1 class="text-2xl font-extrabold tracking-tight leading-tight">
          <span style="color:#fb923c;">Task</span><span style="color:#1e666d;">Points</span>
        </h1>
      </a>
      <div class="flex items-center gap-2">
        <button type="button" class="btn btn-ghost btn-toolbar" data-export-button>Export</button>
        <label class="btn btn-ghost btn-toolbar cursor-pointer">
          <span>Import</span>
          <input type="file" accept="application/json" class="hidden" data-import-input/>
        </label>
      </div>
    </div>

    <!-- Header / nav: same structure + teal buttons as game.html  -->
    <header class="flex flex-wrap items-center justify-between gap-3 mb-4">
      <a href="index.html" class="hidden md:flex items-center gap-3">
        <img src="assets/taskpoints-logo.svg" alt="TaskPoints logo" class="w-9 h-9 rounded-2xl object-cover shadow-sm">
        <div>
          <h1 class="text-2xl sm:text-3xl font-extrabold tracking-tight">TaskPoints</h1>
          <p class="text-xs opacity-70">Game — Matchups Log</p>
        </div>
      </a>
      <div class="toolbar header-nav">
        <a href="index.html"         class="btn btn-teal btn-toolbar nav-btn">Main</a>
        <a href="today.html" class="btn btn-teal btn-toolbar nav-btn">Today</a>
        <a href="daily_sources.html" class="btn btn-teal btn-toolbar nav-btn">Sources</a>
        <a href="log.html"           class="btn btn-teal btn-toolbar nav-btn">Log</a>
        <a href="week.html"          class="btn btn-teal btn-toolbar nav-btn">Week</a>
        <div class="dropdown">
          <button type="button" class="btn btn-teal btn-toolbar nav-btn dropdown-toggle active" data-dropdown-toggle aria-expanded="false">Game <span class="caret">▾</span></button>
          <div class="dropdown-menu">
            <a href="gamehub.html" class="btn btn-teal btn-toolbar nav-btn">Game Hub</a>
            <a href="game.html"         class="btn btn-teal btn-toolbar nav-btn">Players</a>
            <a href="standings.html"    class="btn btn-teal btn-toolbar nav-btn">Standings</a>
            <a href="matchups.html"     class="btn btn-teal btn-toolbar nav-btn active" aria-current="page">Matchups</a>
            <a href="schedule.html"     class="btn btn-teal btn-toolbar nav-btn">Schedule</a>
            <a href="game_ratings.html" class="btn btn-teal btn-toolbar nav-btn">Ratings</a>
            <a href="records.html"      class="btn btn-teal btn-toolbar nav-btn">Records</a>
          </div>
        </div>
        <a href="projects.html" class="btn btn-teal btn-toolbar nav-btn">Projects</a>
        <a href="settings.html" class="btn btn-teal btn-toolbar nav-btn">Settings</a>
      </div>
    </header>

    <!-- Top explainer panel: reuse your glass panel look from main/index  -->
    <section class="glass mb-4">
      <h2 class="font-semibold text-lg mb-1">Matchups Log</h2>
      <p class="text-sm muted">
        Every simulated head-to-head result, grouped by day or player. You are listed as <strong>You</strong>.
      </p>
    </section>

    <div class="flex flex-wrap gap-2 mb-4" id="matchupTabs">
      <button type="button" class="btn btn-teal btn-toolbar" data-tab="chronological">By Date</button>
      <button type="button" class="btn btn-ghost btn-toolbar" data-tab="player">By Player</button>
    </div>

    <!-- Where we render daily matchup groups -->
    <section id="matchupsChronological" class="space-y-4"></section>
    <section id="matchupsByPlayer" class="space-y-4 hidden"></section>
  </div>

  <script>
    const STORAGE_KEY = "taskpoints_v1";
    const $ = (id) => document.getElementById(id);

function load() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      return { tasks:[], completions:[], players:[], habits:[], flexActions:[], gameHistory:[], matchups:[], schedule:[], opponentDripSchedules: [] };
    }

    const p = JSON.parse(raw) || {};

    return {
      tasks:       Array.isArray(p.tasks)       ? p.tasks       : [],
      completions: Array.isArray(p.completions) ? p.completions : [],
      players:     Array.isArray(p.players)     ? p.players     : [],
      habits:      Array.isArray(p.habits)      ? p.habits      : [],
      flexActions: Array.isArray(p.flexActions) ? p.flexActions : [],
      gameHistory: Array.isArray(p.gameHistory) ? p.gameHistory : [],
      matchups:    Array.isArray(p.matchups)    ? p.matchups    : [],
      schedule:    Array.isArray(p.schedule)    ? p.schedule    : [],
      opponentDripSchedules: Array.isArray(p.opponentDripSchedules) ? p.opponentDripSchedules : []
    };

  } catch (e) {
    console.error("Failed to load TaskPoints state", e);
    return { tasks:[], completions:[], players:[], habits:[], flexActions:[], gameHistory:[], matchups:[], schedule:[], opponentDripSchedules: [] };
  }
}

    // Turn a Date (or ISO string) into "YYYY-MM-DD" like the rest of the app
    function dateKey(d) {
      const dt = d instanceof Date ? d : new Date(d);
      if (!dt || Number.isNaN(dt.getTime())) return "";
      const y = dt.getFullYear();
      const m = String(dt.getMonth() + 1).padStart(2, "0");
      const day = String(dt.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    function makeId() {
      if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID();
      }
      return `id_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    }

    function isPlayerActive(player) {
      return !!player && player.active !== false;
    }

    function syncYouMatchupsWithCompletions(state) {
      if (!window.TaskPointsCore || typeof TaskPointsCore.syncYouMatchups !== "function") {
        return state;
      }

      const { state: nextState, changed } = TaskPointsCore.syncYouMatchups(state);
      if (changed) {
        save(nextState);
      }
      return nextState;
    }


    function ordinal(n){
      const s=["th","st","nd","rd"], v=n%100;
      return n + (s[(v-20)%10] || s[v] || s[0]);
    }

    function formatLongDate(key){
      // key: "YYYY-MM-DD"
      const [y,m,d] = key.split("-").map(x => parseInt(x,10));
      const dt = new Date(y, m-1, d);
      const weekday = dt.toLocaleDateString(undefined, { weekday:"long" });
      const month   = dt.toLocaleDateString(undefined, { month:"short" });
      return `${weekday}, ${month} ${ordinal(d)}, ${y}`;
    }

    function formatShortDate(key){
      if (!key) return "Unknown date";
      const parts = key.split("-").map(x => parseInt(x,10));
      if (parts.length !== 3 || parts.some(n => Number.isNaN(n))) return "Unknown date";
      const [y,m,d] = parts;
      const dt = new Date(y, m-1, d);
      if (!dt || Number.isNaN(dt.getTime())) return "Unknown date";
      const month = dt.toLocaleDateString(undefined, { month:"short" });
      return `${month} ${ordinal(d)}, ${y}`;
    }

    function getMatchupDateKey(matchup){
      return matchup.dateKey || matchup.date || (matchup.dateISO ? dateKey(matchup.dateISO) : "");
    }

    function isMatchupRevealed(matchup, includeToday){
      const key = getMatchupDateKey(matchup);
      if (window.TaskPointsCore?.isMatchupRevealed) {
        return TaskPointsCore.isMatchupRevealed(key, { includeToday });
      }
      if (!key) return false;
      const today = window.TaskPointsCore?.todayKey ? TaskPointsCore.todayKey() : "";
      return includeToday ? key <= today : key < today;
    }

    function shouldRevealMatchup(matchup){
      if (!matchup) return false;
      return isMatchupRevealed(matchup, false);
    }

    function activePlayerIds(state) {
      const ids = new Set(["YOU"]);
      (state.players || []).forEach(player => {
        if (player && player.id && isPlayerActive(player)) ids.add(player.id);
      });
      return ids;
    }

    function removeOpponentDripSchedule(state, dateKeyStr, playerId) {
      const schedules = Array.isArray(state.opponentDripSchedules) ? state.opponentDripSchedules : [];
      state.opponentDripSchedules = schedules.filter(s => !(s && s.date === dateKeyStr && s.playerId === playerId));
    }

    function shuffle(arr){
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function computeYouScoreForDate(dateKeyStr, state){
      if (!dateKeyStr) return 0;
      if (window.TaskPointsCore && typeof TaskPointsCore.buildDaySnapshot === "function" && typeof TaskPointsCore.computeDayTotals === "function") {
        const snapshot = TaskPointsCore.buildDaySnapshot(dateKeyStr, state);
        const totals = TaskPointsCore.computeDayTotals(snapshot);
        return Number((totals.total || 0).toFixed(1));
      }

      const comps = Array.isArray(state?.completions) ? state.completions : [];
      if (!comps.length) return 0;
      let total = 0;
      comps.forEach(c => {
        if (!c || !c.completedAtISO) return;
        const key = dateKey(c.completedAtISO);
        if (key === dateKeyStr) {
          total += Number(c.points || 0);
        }
      });
      return Number(total.toFixed(1));
    }

    function simulateAiScoreForPlayer(player, dateKeyStr, state){
      if (!player || !player.baseline) return 0;

      const baseline = Number(player.baseline);
      const variance = Number(player.variance);
      const varianceTiltRaw = Number(
        typeof player.varianceTilt === "number" ? player.varianceTilt : (player.varianceTilt || 50)
      );
      const varianceTilt = Math.min(100, Math.max(0, varianceTiltRaw)) / 100;
      const momentum = Number(player.momentum);

      let riskyRating = Number(player.risky);
      if (isNaN(riskyRating)) riskyRating = 0;
      const riskyNormalized = riskyRating > 10 ? riskyRating / 10 : riskyRating;

      const variationMagnitude = Math.random() * variance;
      const variationSign = Math.random() < varianceTilt ? 1 : -1;
      const variation = variationMagnitude * variationSign;

      let momentumBonus = 0;
      if (momentum && Array.isArray(state?.gameHistory) && state.gameHistory.length) {
        const prev = state.gameHistory
          .filter(g => g.playerId === player.id)
          .sort((a,b) => b.date.localeCompare(a.date))[0];

        if (prev && prev.date !== dateKeyStr) {
          momentumBonus = (prev.score * (momentum / 100)) * 0.1;
        }
      }

      let riskyMod = 0;
      if (Math.random() < riskyNormalized / 10) {
        const boom = Math.random() < 0.5;
        const riskyScale = 0.5 + Math.random() * 2.5;
        riskyMod = boom
          ? variance * riskyScale
          : -variance * riskyScale;
      }

      const score = baseline + variation + momentumBonus + riskyMod;
      const roundedScore = Number(score.toFixed(1));
      return Math.max(0, roundedScore);
    }

    function generateOpponentDripSchedule(dateKeyStr, playerId, totalPoints){
      const totalRounded = Math.max(0, Math.round((Number(totalPoints) || 0) * 10) / 10);
      const totalUnits   = Math.round(totalRounded * 10);

      const startHour = 6;
      const endHour   = 23;
      const count     = Math.max(12, Math.min(40, Math.round(Math.random() * 20) + 15));

      const baseDate = new Date(`${dateKeyStr}T00:00:00`);

      const hourBuckets = [];
      for (let h = startHour; h <= endHour; h++) {
        let weight = 1;
        if ((h >= 7 && h <= 10) || (h >= 17 && h <= 21)) weight += 1.2;
        if (Math.random() < 0.15) weight *= 0.4;
        hourBuckets.push({ hour: h, weight });
      }

      const totalHourWeight = hourBuckets.reduce((s, h) => s + h.weight, 0) || 1;

      function pickTime(){
        let r = Math.random() * totalHourWeight;
        let chosenHour = startHour;
        for (const h of hourBuckets) {
          if (r <= h.weight) { chosenHour = h.hour; break; }
          r -= h.weight;
        }

        const m = Math.floor(Math.random() * 60);
        const s = Math.floor(Math.random() * 60);
        const d = new Date(baseDate.getTime());
        d.setHours(chosenHour, m, s, 0);
        return d;
      }

      const weights = [];
      for (let i = 0; i < count; i++) {
        const base = Math.pow(Math.random(), 1.4);
        const burst = Math.random() < 0.35 ? Math.random() * 1.2 : 0;
        weights.push(base + burst);
      }

      const weightSum = weights.reduce((s, n) => s + n, 0) || 1;

      let remaining = totalUnits;
      const pointUnits = [];
      for (let i = 0; i < count; i++) {
        if (i === count - 1) {
          pointUnits.push(Math.max(0, remaining));
        } else {
          const share = Math.min(
            remaining,
            Math.max(0, Math.round((weights[i] / weightSum) * totalUnits))
          );
          pointUnits.push(share);
          remaining -= share;
        }
      }

      if (remaining > 0 && pointUnits.length) {
        pointUnits[pointUnits.length - 1] += remaining;
      }

      const times = pointUnits.map(() => pickTime());
      times.sort((a, b) => a - b);

      const events = pointUnits
        .map((units, idx) => ({ t: times[idx].toISOString(), pts: units / 10 }))
        .filter(e => e.pts > 0)
        .sort((a, b) => new Date(a.t) - new Date(b.t));

      return {
        date: dateKeyStr,
        playerId,
        total: totalRounded,
        events
      };
    }

    function ensureOpponentDripSchedule(state, dateKeyStr, playerId, totalPoints){
      if (!dateKeyStr || !playerId) return null;

      const list = Array.isArray(state.opponentDripSchedules) ? state.opponentDripSchedules : [];
      const totalRounded = Math.max(0, Math.round((Number(totalPoints) || 0) * 10) / 10);
      const existingIdx = list.findIndex(s => s && s.date === dateKeyStr && s.playerId === playerId);

      if (existingIdx !== -1) {
        const existing = list[existingIdx];
        if (existing && Math.abs((existing.total || 0) - totalRounded) < 0.001 && Array.isArray(existing.events) && existing.events.length) {
          return existing;
        }
      }

      const next = generateOpponentDripSchedule(dateKeyStr, playerId, totalRounded);
      const updated = list.filter(s => !(s && s.date === dateKeyStr && s.playerId === playerId));
      updated.push(next);

      state.opponentDripSchedules = updated;
      return next;
    }

    function upsertGameHistoryEntry(state, dateKeyStr, playerId, score) {
      if (!playerId || playerId === "YOU") return;
      const history = Array.isArray(state.gameHistory) ? state.gameHistory : [];
      const existing = history.find(entry => entry && entry.playerId === playerId && entry.date === dateKeyStr);
      if (existing) {
        existing.score = score;
      } else {
        history.push({
          id: makeId(),
          date: dateKeyStr,
          playerId,
          score
        });
      }
      state.gameHistory = history;
    }

    function requestScoreInput(label, currentScore) {
      const current = Number(currentScore);
      const fallback = Number.isFinite(current) ? current : 0;
      while (true) {
        const input = prompt(`Edit ${label} score:`, formatScore(fallback));
        if (input === null) return null;
        const next = Number(input);
        if (Number.isFinite(next)) return next;
        alert("Please enter a valid numeric score.");
      }
    }

    function renderMatchups(){
      let state = load();

// sync may write back; keep local state updated
state = syncYouMatchupsWithCompletions(state);

      const chronoContainer = $("matchupsChronological");
      const playerContainer = $("matchupsByPlayer");
      chronoContainer.innerHTML = "";
      playerContainer.innerHTML = "";

      const matchups = Array.isArray(state.matchups) ? state.matchups : [];
      const activeIds = activePlayerIds(state);
      const visibleMatchups = matchups.filter(m =>
        m && activeIds.has(m.playerAId) && activeIds.has(m.playerBId)
      );
      if (!visibleMatchups.length) {
        const empty = document.createElement("section");
        empty.className = "glass";
        empty.innerHTML = "<div class='text-sm muted'>No matchups have been simulated yet.</div>";
        chronoContainer.appendChild(empty.cloneNode(true));
        playerContainer.appendChild(empty);
        return;
      }

      // Map player IDs to names (You is special)
      const nameById = {};
      const playerById = new Map();
      (state.players || []).forEach(p => {
        if (!p || !p.id) return;
        nameById[p.id] = p.name || "Unnamed";
        playerById.set(p.id, p);
      });

      function getName(id, matchup){
        if (id === "YOU") return "You";
        if (nameById[id]) return nameById[id];
        if (matchup) {
          if (matchup.playerAId === id && matchup.playerAName) return matchup.playerAName;
          if (matchup.playerBId === id && matchup.playerBName) return matchup.playerBName;
        }
        return "Unknown";
      }

      function formatScore(score){
        const num = Number(score);
        if (!Number.isFinite(num)) return "0";
        return Number.isInteger(num) ? String(num) : num.toFixed(1);
      }

      function missingIdsForDate(dateKeyStr, sourceState) {
        const ids = activePlayerIds(sourceState);
        const participants = new Set();
        (sourceState.matchups || []).forEach(m => {
          if (!m) return;
          if (getMatchupDateKey(m) !== dateKeyStr) return;
          if (m.playerAId) participants.add(m.playerAId);
          if (m.playerBId) participants.add(m.playerBId);
        });
        return Array.from(ids).filter(id => !participants.has(id));
      }

      function generateRetroMatchupsForDate(dateKeyStr) {
        let nextState = load();
        nextState = syncYouMatchupsWithCompletions(nextState);

        const missingIds = missingIdsForDate(dateKeyStr, nextState);
        if (missingIds.length < 2) {
          alert("Not enough players without matchups for that day.");
          return;
        }

        const namesById = {};
        const playerMap = new Map();
        (nextState.players || []).forEach(p => {
          if (!p || !p.id) return;
          namesById[p.id] = p.name || "Unnamed";
          playerMap.set(p.id, p);
        });
        namesById["YOU"] = "You";

        const pool = missingIds.slice();
        shuffle(pool);
        let byeId = null;
        if (pool.length % 2 === 1) {
          byeId = pool.pop();
        }

        const history = Array.isArray(nextState.gameHistory) ? nextState.gameHistory : [];

        function scoreForPlayer(playerId) {
          if (playerId === "YOU") {
            return computeYouScoreForDate(dateKeyStr, nextState);
          }
          const existing = history.find(entry => entry && entry.playerId === playerId && entry.date === dateKeyStr);
          if (existing && Number.isFinite(Number(existing.score))) {
            const score = Number(existing.score);
            ensureOpponentDripSchedule(nextState, dateKeyStr, playerId, score);
            return score;
          }
          const player = playerMap.get(playerId);
          const score = simulateAiScoreForPlayer(player, dateKeyStr, nextState);
          upsertGameHistoryEntry(nextState, dateKeyStr, playerId, score);
          ensureOpponentDripSchedule(nextState, dateKeyStr, playerId, score);
          return score;
        }

        for (let i = 0; i + 1 < pool.length; i += 2) {
          const aId = pool[i];
          const bId = pool[i + 1];
          const matchup = {
            id: makeId(),
            date: dateKeyStr,
            playerAId: aId,
            playerBId: bId,
            playerAName: namesById[aId] || "Unknown",
            playerBName: namesById[bId] || "Unknown",
            scoreA: scoreForPlayer(aId),
            scoreB: scoreForPlayer(bId)
          };
          nextState.matchups = Array.isArray(nextState.matchups) ? nextState.matchups : [];
          nextState.matchups.push(matchup);
        }

        if (byeId) {
          // Leave byeId without matchup for the day.
        }

        nextState = save(nextState);
        renderMatchups();
      }

      function editMatchupScores(matchup) {
        if (!matchup) return;
        const key = getMatchupDateKey(matchup);
        if (!key) {
          alert("This matchup is missing a date.");
          return;
        }

        const aId = matchup.playerAId;
        const bId = matchup.playerBId;
        const aIsYou = aId === "YOU";
        const bIsYou = bId === "YOU";
        const aName = getName(aId, matchup);
        const bName = getName(bId, matchup);

        const updates = [];

        if (!aIsYou) {
          const nextScore = requestScoreInput(aName, matchup.scoreA);
          if (nextScore === null) return;
          matchup.scoreA = nextScore;
          updates.push({ playerId: aId, score: nextScore });
        }

        if (!bIsYou) {
          const nextScore = requestScoreInput(bName, matchup.scoreB);
          if (nextScore === null) return;
          matchup.scoreB = nextScore;
          updates.push({ playerId: bId, score: nextScore });
        }

        if (!updates.length) return;

        updates.forEach(update => {
          upsertGameHistoryEntry(state, key, update.playerId, update.score);
          removeOpponentDripSchedule(state, key, update.playerId);
        });

        state = save(state);
        renderMatchups();
      }

      function describeMatchup(m){
        if (!shouldRevealMatchup(m)) {
          const aName = getName(m.playerAId, m);
          const bName = getName(m.playerBId, m);
          return `${aName} vs ${bName} — Matchup pending (—–—)`;
        }
        const aId = m.playerAId;
        const bId = m.playerBId;
        const aScore = Number(m.scoreA);
        const bScore = Number(m.scoreB);
        const aName = getName(aId, m);
        const bName = getName(bId, m);

        const aIsYou = aId === "YOU";
        const bIsYou = bId === "YOU";

        if (aIsYou || bIsYou) {
          const youScore = aIsYou ? aScore : bScore;
          const oppScore = aIsYou ? bScore : aScore;
          const oppName  = aIsYou ? bName  : aName;

          const youScoreLabel = formatScore(youScore);
          const oppScoreLabel = formatScore(oppScore);
          if (youScore > oppScore) {
            return `You beat ${oppName}, ${youScoreLabel}–${oppScoreLabel}`;
          } else if (youScore < oppScore) {
            return `You lost to ${oppName}, ${youScoreLabel}–${oppScoreLabel}`;
          } else {
            return `You tied ${oppName}, ${youScoreLabel}–${oppScoreLabel}`;
          }
        }

        if (aScore > bScore) {
          return `${aName} beat ${bName}, ${formatScore(aScore)}–${formatScore(bScore)}`;
        } else if (bScore > aScore) {
          return `${bName} beat ${aName}, ${formatScore(bScore)}–${formatScore(aScore)}`;
        } else {
          return `${aName} and ${bName} tied, ${formatScore(aScore)}–${formatScore(bScore)}`;
        }
      }

      function describeMatchupForPlayer(m, playerId){
        const aId = m.playerAId;
        const bId = m.playerBId;
        const aScore = Number(m.scoreA);
        const bScore = Number(m.scoreB);
        const playerIsA = playerId === aId;
        const playerIsB = playerId === bId;
        if (!playerIsA && !playerIsB) return "";
        if (!shouldRevealMatchup(m)) {
          const oppId = playerIsA ? bId : aId;
          const oppName = getName(oppId, m);
          return `Matchup pending vs ${oppName} (—–—)`;
        }

        const playerScore = playerIsA ? aScore : bScore;
        const oppScore = playerIsA ? bScore : aScore;
        const oppId = playerIsA ? bId : aId;
        const oppName = getName(oppId, m);

        const playerLabel = formatScore(playerScore);
        const oppLabel = formatScore(oppScore);
        if (playerScore > oppScore) {
          return `def ${oppName}, ${playerLabel}–${oppLabel}`;
        } else if (playerScore < oppScore) {
          return `lost to ${oppName}, ${playerLabel}–${oppLabel}`;
        } else {
          return `tied ${oppName}, ${playerLabel}–${oppLabel}`;
        }
      }

      // Group by date key
      const groups = new Map();
      visibleMatchups.forEach(m => {
        const key = getMatchupDateKey(m);
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(m);
      });

      // Sort dates descending
      const dateKeys = Array.from(groups.keys()).sort((a,b) => b.localeCompare(a));

      dateKeys.forEach(key => {
        const section = document.createElement("section");
        section.className = "glass mb-4";

        const heading = document.createElement("h2");
        heading.className = "matchup-day";
        heading.textContent = formatLongDate(key);
        section.appendChild(heading);

        const list = document.createElement("ul");
        list.className = "space-y-1";

        groups.get(key)
          .slice()
          .sort((a,b) => (a.id || "").localeCompare(b.id || ""))
          .forEach(m => {
            const li = document.createElement("li");
            li.className = "matchup-item flex items-center justify-between gap-3";
            if (m.playerAId === "YOU" || m.playerBId === "YOU") {
              li.classList.add("you");
            }
            const summary = document.createElement("span");
            summary.className = "flex-1";
            summary.textContent = describeMatchup(m);
            li.appendChild(summary);

            if (m.playerAId !== "YOU" || m.playerBId !== "YOU") {
              const editBtn = document.createElement("button");
              editBtn.type = "button";
              editBtn.className = "btn btn-ghost btn-toolbar text-xs";
              editBtn.textContent = "Edit scores";
              editBtn.addEventListener("click", () => editMatchupScores(m));
              li.appendChild(editBtn);
            }
            list.appendChild(li);
          });

        section.appendChild(list);

        const missingIds = missingIdsForDate(key, state);
        if (missingIds.length) {
          const missingWrap = document.createElement("div");
          missingWrap.className = "matchup-missing text-sm";

          const missingHeading = document.createElement("div");
          missingHeading.className = "font-semibold mb-1";
          missingHeading.textContent = "No matchup scheduled:";
          missingWrap.appendChild(missingHeading);

          const missingList = document.createElement("ul");
          missingList.className = "space-y-1";
          missingIds
            .slice()
            .sort((a,b) => getName(a).localeCompare(getName(b)))
            .forEach(id => {
              const li = document.createElement("li");
              li.className = "text-sm";
              li.textContent = `• ${getName(id)}`;
              missingList.appendChild(li);
            });
          missingWrap.appendChild(missingList);

          const actionWrap = document.createElement("div");
          actionWrap.className = "mt-2";

          const retroBtn = document.createElement("button");
          retroBtn.type = "button";
          retroBtn.className = "btn btn-teal btn-toolbar text-xs";
          retroBtn.textContent = "Generate retro matchups";
          retroBtn.disabled = missingIds.length < 2;
          retroBtn.addEventListener("click", () => generateRetroMatchupsForDate(key));
          actionWrap.appendChild(retroBtn);

          if (missingIds.length < 2) {
            const helper = document.createElement("div");
            helper.className = "text-xs muted mt-1";
            helper.textContent = "Need at least two players without matchups to generate retro games.";
            actionWrap.appendChild(helper);
          }

          missingWrap.appendChild(actionWrap);
          section.appendChild(missingWrap);
        }
        chronoContainer.appendChild(section);
      });

      const playerGroups = new Map();
      visibleMatchups.forEach(m => {
        [m.playerAId, m.playerBId].forEach(playerId => {
          if (!playerId) return;
          if (!playerGroups.has(playerId)) playerGroups.set(playerId, []);
          playerGroups.get(playerId).push(m);
        });
      });

      const playerIds = Array.from(playerGroups.keys()).sort((a,b) => {
        const nameA = getName(a);
        const nameB = getName(b);
        return nameA.localeCompare(nameB);
      });

      playerIds.forEach(playerId => {
        const section = document.createElement("section");
        section.className = "glass mb-4";

        const heading = document.createElement("h2");
        heading.className = "matchup-player";
        heading.textContent = getName(playerId);
        section.appendChild(heading);

        const list = document.createElement("ul");
        list.className = "space-y-1";

        playerGroups.get(playerId)
          .slice()
          .sort((a,b) => getMatchupDateKey(b).localeCompare(getMatchupDateKey(a)))
          .forEach(m => {
            const li = document.createElement("li");
            li.className = "matchup-item flex items-center justify-between gap-3";
            if (playerId === "YOU") {
              li.classList.add("you");
            }
            const dateLabel = formatShortDate(getMatchupDateKey(m));
            const summary = describeMatchupForPlayer(m, playerId);
            const label = document.createElement("span");
            label.className = "flex-1";
            label.textContent = `${dateLabel} - ${summary}`;
            li.appendChild(label);
            if (m.playerAId !== "YOU" || m.playerBId !== "YOU") {
              const editBtn = document.createElement("button");
              editBtn.type = "button";
              editBtn.className = "btn btn-ghost btn-toolbar text-xs";
              editBtn.textContent = "Edit scores";
              editBtn.addEventListener("click", () => editMatchupScores(m));
              li.appendChild(editBtn);
            }
            list.appendChild(li);
          });

        section.appendChild(list);
        playerContainer.appendChild(section);
      });
    }

function normalizeHexColor(value) {
  if (!value) return null;
  let hex = String(value).trim();
  if (!hex) return null;
  if (!hex.startsWith('#')) hex = `#${hex}`;
  if (!/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(hex)) return null;
  if (hex.length === 4) {
    hex = `#${hex.slice(1).split('').map((c) => c + c).join('')}`;
  }
  return hex.toLowerCase();
}

function normalizeHabitTagColors(value) {
  if (!value || typeof value !== 'object') return {};
  const next = {};
  Object.entries(value).forEach(([tag, color]) => {
    const normalized = normalizeHexColor(color);
    if (normalized) next[String(tag)] = normalized;
  });
  return next;
}

function normalizeHabit(habit) {
  if (!habit || typeof habit !== 'object') return habit;
  return {
    ...habit,
    tag: typeof habit.tag === 'string' ? habit.tag.trim() : ''
  };
}

function normalizeState(s) {
  return {
    tasks:       Array.isArray(s.tasks)       ? s.tasks       : [],
    completions: Array.isArray(s.completions) ? s.completions : [],
    players:     Array.isArray(s.players)     ? s.players     : [],
    habits:      Array.isArray(s.habits)      ? s.habits.map(normalizeHabit)      : [],
    flexActions: Array.isArray(s.flexActions) ? s.flexActions : [],
    gameHistory: Array.isArray(s.gameHistory) ? s.gameHistory : [],
    matchups:    Array.isArray(s.matchups)    ? s.matchups    : [],
    schedule:    Array.isArray(s.schedule)    ? s.schedule    : [],
    opponentDripSchedules: Array.isArray(s.opponentDripSchedules) ? s.opponentDripSchedules : [],
    habitTagColors: normalizeHabitTagColors(s.habitTagColors)
  };
}

function save(nextState) {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    const existing = raw ? (JSON.parse(raw) || {}) : {};
    const merged = normalizeState({ ...existing, ...nextState });
    localStorage.setItem(STORAGE_KEY, JSON.stringify(merged));
    return merged;
  } catch (e) {
    console.error("Failed to save TaskPoints state", e);
    return nextState;
  }
}


      
    document.addEventListener("DOMContentLoaded", renderMatchups);
    document.addEventListener("DOMContentLoaded", () => {
      const tabs = document.querySelectorAll("#matchupTabs [data-tab]");
      const chrono = $("matchupsChronological");
      const player = $("matchupsByPlayer");

      tabs.forEach(tab => {
        tab.addEventListener("click", () => {
          const target = tab.getAttribute("data-tab");
          const isChrono = target === "chronological";
          chrono.classList.toggle("hidden", !isChrono);
          player.classList.toggle("hidden", isChrono);
          tabs.forEach(btn => {
            btn.classList.toggle("btn-teal", btn === tab);
            btn.classList.toggle("btn-ghost", btn !== tab);
          });
        });
      });
    });
  </script>

  <button
    class="hidden md:hidden fixed top-3 right-3 z-40 btn btn-teal rounded-full shadow-lg px-4 py-2 text-sm flex items-center gap-1"
    type="button"
    data-scroll-top
  >
    <span>⬆️</span>
    <span>Top</span>
  </button>
</body>
</html>


