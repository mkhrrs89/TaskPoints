<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TaskPoints ‚Äî Log</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='48' fill='%230b0d10'/><text x='50' y='62' font-size='60' text-anchor='middle' fill='white'>TP</text></svg>">
<script src="https://cdn.tailwindcss.com"></script>


<link rel="stylesheet" href="styles.css">
<script src="scoring_core.js"></script>
<script src="toolbar.js" defer></script>



  <style>
    :root{--bg:#0b0d10;--border:#202830;--muted:#8b98a5}
    body{background:var(--bg);color:#e6edf6}
    @media (prefers-color-scheme:light){body{background:#fafafa;color:#0b1220}}
    .glass{border:1px solid var(--border);background:rgba(255,255,255,.06);border-radius:16px;padding:16px}
    @media (prefers-color-scheme:light){.glass{background:#fff;border-color:#e5e7eb}}
    .btn {
  border:1px solid var(--border);
  border-radius:12px;
  padding:6px 8px;
  font-size:11px;
}
/* Smaller buttons ONLY inside the Actions column */
.row .btn {
  padding: 2px 4px !important;
  font-size: 10px !important;
  border-radius: 6px !important;
}

    .muted{color:var(--muted)}
.day-divider{
  display:flex;
  align-items:center;
  gap:.6rem;
  margin:12px 0 6px;
  font-size:11px;
  letter-spacing:.12em;
  text-transform:uppercase;
  color:var(--muted);
}
.day-divider::before,
.day-divider::after{
  content:"";
  flex:1 1 auto;
  height:1px;
  background:linear-gradient(90deg, transparent, rgba(148,163,184,0.5), transparent);
}
.day-divider span{
  padding:2px 8px;
  border:1px solid var(--border);
  border-radius:999px;
  background:rgba(15,23,42,0.55);
  font-weight:600;
}
@media (prefers-color-scheme: light){
  .day-divider span{
    background:#fff;
  }
}
.row{
  display:grid;

  /* Date | Title | Points | Source | Actions | ID */
  grid-template-columns:160px 1fr 65px 100px 115px 130px;

  gap:.35rem;
  align-items:center;

  padding:0;              /* no extra vertical padding */
  font-size:13px;
  line-height:1.1;
}

/* Don‚Äôt let the date wrap to a second line */
.row > div:first-child {
  white-space: nowrap;
  padding-right: 12px;
}



.row > div:nth-child(5){
  text-align:center;
}

/* Keep desktop layout, scroll horizontally if needed */
.row {
  min-width: 780px;     /* less wide = visually tighter */
}

    /* === Main Page Top Nav Button Styles === */
.top-nav-btn{
  border-radius:999px;
  padding:6px 10px;
  font-size:11px;
  border:1px solid rgba(75,85,99,0.7);
  background:linear-gradient(180deg, #0f4d4d, #0a2f2f)
  color:#fff
}

@media (prefers-color-scheme: light){
  .top-nav-btn{
    background:rgba(240,245,255,0.8);
    color:#1e293b;
    border-color:rgba(148,163,184,0.8);
  }
}

/* Mobile tweaks: prevent overlap + shrink text a bit */
@media (max-width: 640px) {
  .row{
    font-size:11px;      /* smaller text on phones */
    line-height:1.3;     /* more breathing room so lines don‚Äôt overlap */
    padding:2px 0;       /* tiny bit of vertical padding so it feels clean */
  }

  /* Allow date to wrap on mobile instead of cramming */
  .row > div:first-child {
    white-space: normal;
  }
}


  </style>


</head>

<body class="min-h-screen">
  <div class="mx-auto max-w-6xl p-4 sm:p-6">

<div class="flex items-center justify-between gap-3 mb-3 md:hidden">
  <a href="index.html" class="flex items-center gap-3">
    <img src="assets/taskpoints-logo.png" alt="TaskPoints logo" class="w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm">
    <h1 class="text-2xl font-extrabold tracking-tight leading-tight">
      <span style="color:#fb923c;">Task</span><span style="color:#1e666d;">Points</span>
    </h1>
  </a>
  <div class="flex items-center gap-2">
    <button type="button" class="btn btn-ghost btn-toolbar" data-export-button>Export</button>
    <label class="btn btn-ghost btn-toolbar cursor-pointer">
      <span>Import</span>
      <input type="file" accept="application/json" class="hidden" data-import-input/>
    </label>
  </div>
</div>

<header class="flex items-center justify-between mb-4 gap-3 flex-wrap">
  <h1 class="text-2xl font-extrabold page-title">Log</h1>
  <div class="toolbar header-nav">
    <a href="index.html"         class="btn btn-teal btn-toolbar nav-btn">Main</a>
    <a href="today.html" class="btn btn-teal btn-toolbar nav-btn">Today</a>
    <a href="daily_sources.html" class="btn btn-teal btn-toolbar nav-btn">Sources</a>
    <a href="log.html"           class="btn btn-teal btn-toolbar nav-btn active" aria-current="page">Log</a>
    <a href="week.html"          class="btn btn-teal btn-toolbar nav-btn">Week</a>
    <div class="dropdown">
      <button type="button" class="btn btn-teal btn-toolbar nav-btn dropdown-toggle" data-dropdown-toggle aria-expanded="false">Game <span class="caret">‚ñæ</span></button>
      <div class="dropdown-menu">
        <a href="gamehub.html" class="btn btn-teal btn-toolbar nav-btn">Game Hub</a>
        <a href="game.html"         class="btn btn-teal btn-toolbar nav-btn">Players</a>
        <a href="standings.html"    class="btn btn-teal btn-toolbar nav-btn">Standings</a>
        <a href="matchups.html"     class="btn btn-teal btn-toolbar nav-btn">Matchups</a>
        <a href="schedule.html"     class="btn btn-teal btn-toolbar nav-btn">Schedule</a>
        <a href="game_ratings.html" class="btn btn-teal btn-toolbar nav-btn">Ratings</a>
        <a href="records.html"      class="btn btn-teal btn-toolbar nav-btn">Records</a>
      </div>
    </div>
        <a href="projects.html" class="btn btn-teal btn-toolbar nav-btn">Projects</a>
        <a href="settings.html" class="btn btn-teal btn-toolbar nav-btn">Settings</a>
  </div>

</header>


<div class="glass overflow-x-auto">
<div class="row font-semibold mb-2">
  <div>Date</div>
  <div>Title</div>
  <div>Points</div>
  <div>Source</div>
  <div>Actions</div>
  <div>ID</div>
</div>


      <div id="logList" class="grid gap-0"></div>

      <div id="empty" class="muted text-sm">No completions yet.</div>
    </div>

    <footer class="mt-10 text-xs muted text-right">v0.24.3 ‚Äî 2025-11-25 12:35</footer>
  </div>

<script>
const STORAGE_KEY="taskpoints_v1";
const $=id=>document.getElementById(id);

function fromKey(key){
  if(!key || typeof key !== 'string') return null;
  const [y,m,d]=key.split('-').map(Number);
  if(!y||!m||!d) return null;
  const date=new Date(y,m-1,d);
  date.setHours(0,0,0,0);
  return isNaN(date)?null:date;
}

function dateKey(date){
  if(!(date instanceof Date) || isNaN(date)) return null;
  const y=date.getFullYear();
  const m=String(date.getMonth()+1).padStart(2,'0');
  const d=String(date.getDate()).padStart(2,'0');
  return `${y}-${m}-${d}`;
}

function todayKey(){
  const d=new Date();
  d.setHours(0,0,0,0);
  return dateKey(d);
}

function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); x.setHours(0,0,0,0); return x; }

function safeCompletionDateKey(completion){
  if(!completion || !completion.completedAtISO) return null;
  const when=new Date(completion.completedAtISO);
  if(isNaN(when)) return null;
  return dateKey(when);
}

function computePreviousDueDate(task, completionKey){
  if(!task) return null;
  const rec = task.recurrence || {};
  const mode = rec.mode || 'none';
  if (mode === 'none') return completionKey || task.dueDateISO || todayKey();

  const nextKey = task.dueDateISO || null;
  const anchorKey = nextKey || completionKey || todayKey();
  const anchorDate = fromKey(anchorKey);
  if(!anchorDate) return null;

  const count = Number.isFinite(rec.customCount) && rec.customCount > 0 ? rec.customCount : 1;
  let prevDate = null;

  if (mode === 'daily') {
    prevDate = addDays(anchorDate, -1);
  } else if (mode === 'everyWeekday') {
    prevDate = addDays(anchorDate, -1);
    while(prevDate.getDay() === 0 || prevDate.getDay() === 6){
      prevDate = addDays(prevDate, -1);
    }
  } else if (mode === 'weekly') {
    prevDate = addDays(anchorDate, -7);
  } else if (mode === 'monthly') {
    prevDate = new Date(anchorDate);
    prevDate.setMonth(prevDate.getMonth() - 1);
    prevDate.setHours(0,0,0,0);
  } else if (mode === 'yearly') {
    prevDate = new Date(anchorDate);
    prevDate.setFullYear(prevDate.getFullYear() - 1);
    prevDate.setHours(0,0,0,0);
  } else if (mode === 'custom') {
    const unit = rec.customUnit || 'day';
    if (unit === 'day') {
      prevDate = addDays(anchorDate, -count);
    } else if (unit === 'week') {
      prevDate = addDays(anchorDate, -count * 7);
    } else if (unit === 'month') {
      prevDate = new Date(anchorDate);
      prevDate.setMonth(prevDate.getMonth() - count);
      prevDate.setHours(0,0,0,0);
    } else if (unit === 'year') {
      prevDate = new Date(anchorDate);
      prevDate.setFullYear(prevDate.getFullYear() - count);
      prevDate.setHours(0,0,0,0);
    }
  }

  return prevDate ? dateKey(prevDate) : null;
}

function sleepBonus(score) {
  if (window.TaskPointsCore?.sleepBonus) {
    return TaskPointsCore.sleepBonus(score, state);
  }
  if (score >= 100) return 3;
  if (score >= 98) return 2;
  if (score >= 95) return 1;
  return 0;
}

function getSleepInfo(entry) {
  const match = entry?.title?.match(/\((\d+)\)/);
  const score = match ? Number(match[1]) : null;

  const restedRaw = entry && Object.prototype.hasOwnProperty.call(entry, 'sleepRested')
    ? Number(entry.sleepRested)
    : 0;
  const rested = Number.isFinite(restedRaw) ? restedRaw : 0;

  return { score, rested };
}

function sleepPoints(score, rested = 0) {
  if (window.TaskPointsCore?.sleepPoints) {
    return TaskPointsCore.sleepPoints(score, rested, state);
  }
  if (!Number.isFinite(score)) return 0;
  const base = score / 10;
  const bonus = sleepBonus(score);
  return base + bonus + (Number.isFinite(rested) ? rested : 0);
}

function getWorkInfo(entry) {
  const match = entry?.title?.match(/\(([^)]+)\)/);
  const score = match ? Number(match[1]) : null;

  const hoursRaw = entry && Object.prototype.hasOwnProperty.call(entry, 'workHours')
    ? Number(entry.workHours)
    : 0;
  const hours = Number.isFinite(hoursRaw) ? hoursRaw : 0;

  return { score, hours };
}

function workHoursBonus(hours = 0) {
  if (window.TaskPointsCore?.workHoursBonus) {
    return TaskPointsCore.workHoursBonus(hours, state);
  }
  if (!Number.isFinite(hours)) return 0;
  return Math.max(0, hours) * 10;
}

function workPoints(score, hours = 0) {
  if (window.TaskPointsCore?.workPoints) {
    return TaskPointsCore.workPoints(score, hours, state);
  }
  if (!Number.isFinite(score)) return 0;
  return score + workHoursBonus(hours);
}


function load(){ 
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      return {
        tasks:      [],
        completions:[],
        players:    [],
        habits:     [],
        flexActions:[],
        matchups:   [],
        gameHistory:[],
        schedule:   [],
        opponentDripSchedules: [],
        scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
          ? TaskPointsCore.normalizeScoringSettings({})
          : {}
      };
    }

    const p = JSON.parse(raw);
    return {
      tasks:       Array.isArray(p.tasks)       ? p.tasks       : [],
      completions: Array.isArray(p.completions) ? p.completions : [],
      players:     Array.isArray(p.players)     ? p.players     : [],
      habits:      Array.isArray(p.habits)      ? p.habits      : [],
      flexActions: Array.isArray(p.flexActions) ? p.flexActions : [],
      matchups:    Array.isArray(p.matchups)    ? p.matchups    : [],
      gameHistory: Array.isArray(p.gameHistory) ? p.gameHistory : [],
      schedule:    Array.isArray(p.schedule)    ? p.schedule    : [],
      opponentDripSchedules: Array.isArray(p.opponentDripSchedules) ? p.opponentDripSchedules : [],
      scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
        ? TaskPointsCore.normalizeScoringSettings(p.scoringSettings || {})
        : (p.scoringSettings || {})
    };
  } catch {
    return {
      tasks:      [],
      completions:[],
      players:    [],
      habits:     [],
      flexActions:[],
      matchups:   [],
      gameHistory:[],
      schedule:   [],
      opponentDripSchedules: [],
      scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
        ? TaskPointsCore.normalizeScoringSettings({})
        : {}
    };
  }
}


let state = load();
  
function normalizeHexColor(value) {
  if (!value) return null;
  let hex = String(value).trim();
  if (!hex) return null;
  if (!hex.startsWith('#')) hex = `#${hex}`;
  if (!/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(hex)) return null;
  if (hex.length === 4) {
    hex = `#${hex.slice(1).split('').map((c) => c + c).join('')}`;
  }
  return hex.toLowerCase();
}

function normalizeHabitTagColors(value) {
  if (!value || typeof value !== 'object') return {};
  const next = {};
  Object.entries(value).forEach(([tag, color]) => {
    const normalized = normalizeHexColor(color);
    if (normalized) next[String(tag)] = normalized;
  });
  return next;
}

function normalizeHabit(habit) {
  if (!habit || typeof habit !== 'object') return habit;
  return {
    ...habit,
    tag: typeof habit.tag === 'string' ? habit.tag.trim() : ''
  };
}

function normalizeState(s) {
  return {
    tasks:       Array.isArray(s.tasks)       ? s.tasks       : [],
    completions: Array.isArray(s.completions) ? s.completions : [],
    players:     Array.isArray(s.players)     ? s.players     : [],
    habits:      Array.isArray(s.habits)      ? s.habits.map(normalizeHabit)      : [],
    flexActions: Array.isArray(s.flexActions) ? s.flexActions : [],
    gameHistory: Array.isArray(s.gameHistory) ? s.gameHistory : [],
    matchups:    Array.isArray(s.matchups)    ? s.matchups    : [],
    schedule:    Array.isArray(s.schedule)    ? s.schedule    : [],
    opponentDripSchedules: Array.isArray(s.opponentDripSchedules) ? s.opponentDripSchedules : [],
    workHistory: Array.isArray(s.workHistory) ? s.workHistory : [],
    youImageId:  typeof s.youImageId === "string" ? s.youImageId : "",
    habitTagColors: normalizeHabitTagColors(s.habitTagColors)
  };
}

function saveMerged(partial) {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    const existing = raw ? (JSON.parse(raw) || {}) : {};
    if (window.TaskPointsCore?.saveAppState) {
      return TaskPointsCore.saveAppState({ ...existing, ...partial }, { storageKey: STORAGE_KEY }).state;
    }
    if (window.TaskPointsCore?.mergeAndSaveState) {
      return TaskPointsCore.mergeAndSaveState({ ...existing, ...partial }, { storageKey: STORAGE_KEY }).state;
    }
    const merged = { ...existing, ...partial };
    console.warn("saveMerged skipped localStorage write; TaskPointsCore missing.");
    return merged;
  } catch (e) {
    console.error("saveMerged failed", e);
    return partial;
  }
}

function getCompletionPoints(entry) {
  if (window.TaskPointsCore?.pointsForCompletion) {
    return TaskPointsCore.pointsForCompletion(entry);
  }
  return Number(entry?.points) || 0;
}

function buildInertiaLogEntries(completions) {
  if (!window.TaskPointsCore?.aggregateCompletionsByDate) return [];
  const { dailyTotals } = TaskPointsCore.aggregateCompletionsByDate(completions, state);
  return Object.keys(dailyTotals).flatMap(dateKeyStr => {
    const { inertia, average } = TaskPointsCore.computeInertia(dailyTotals, dateKeyStr, state);
    if (!Number.isFinite(inertia) || Math.abs(inertia) < 0.0001) return [];
    const date = fromKey(dateKeyStr);
    if (!date) return [];
    const iso = new Date(date.getTime() + 12 * 3600 * 1000).toISOString();
    const rounded = window.TaskPointsCore?.roundPoints
      ? TaskPointsCore.roundPoints(inertia, 2)
      : Math.round(inertia * 10) / 10;
    return [{
      id: `inertia:${dateKeyStr}`,
      title: `Inertia Bonus ‚Äî Avg ${Number(average || 0).toFixed(1)}`,
      points: rounded,
      completedAtISO: iso,
      source: 'inertia',
      category: 'inertia'
    }];
  });
}

function buildLogEntries(completions) {
  const base = Array.isArray(completions) ? completions.slice() : [];
  return base.concat(buildInertiaLogEntries(base));
}

function syncDerivedPointsIfNeeded() {
  if (!window.TaskPointsCore?.syncDerivedPoints) return;
  const derivedSync = TaskPointsCore.syncDerivedPoints(state);
  state = derivedSync.state;
  if (!derivedSync.changed) return;
  if (window.TaskPointsCore?.saveAppState) {
    state = TaskPointsCore.saveAppState(state).state;
  } else if (window.TaskPointsCore?.mergeAndSaveState) {
    state = TaskPointsCore.mergeAndSaveState(state).state;
  } else {
    state = saveMerged(state);
  }
}


function migrateSleepEntriesForBonus() {
  if (!state || !Array.isArray(state.completions)) return;

  let changed = false;

  state.completions.forEach(c => {
    if (!c || !c.title || !c.title.startsWith('Sleep Score')) return;

    const { score, rested } = getSleepInfo(c);
    if (!Number.isFinite(score)) return;

    const restVal = Number.isFinite(rested) ? rested : 0;
    const newPts = sleepPoints(score, restVal);

    if (!Number.isFinite(c.sleepRested)) {
      c.sleepRested = restVal;
      changed = true;
    }

    if (Math.abs((Number(c.points) || 0) - newPts) > 0.0001) {
      c.points = newPts;
      changed = true;
    }
  });

  if (changed) {
    save();
  }
}

migrateSleepEntriesForBonus();

function migrateWorkEntriesForHours() {
  if (!state || !Array.isArray(state.completions)) return;

  let changed = false;

  state.completions.forEach(c => {
    if (!c || !c.title || !c.title.startsWith('Work Score')) return;

    const { score, hours } = getWorkInfo(c);
    const safeHours = Number.isFinite(hours) ? Math.max(0, hours) : 0;
    const safeScore = Number.isFinite(score) ? score : Number(c.points) || 0;
    const newPts = workPoints(safeScore, safeHours);

    if (!Number.isFinite(c.workHours) || c.workHours !== safeHours) {
      c.workHours = safeHours;
      changed = true;
    }

    if (c.source !== 'work') {
      c.source = 'work';
      changed = true;
    }

    const desiredTitle = Number.isFinite(score)
      ? `Work Score (${score}) ‚Äî Hours ${safeHours}`
      : c.title;
    if (desiredTitle !== c.title) {
      c.title = desiredTitle;
      changed = true;
    }

    if (Math.abs((Number(c.points) || 0) - newPts) > 0.0001) {
      c.points = newPts;
      changed = true;
    }
  });

  if (changed) save();
}

migrateWorkEntriesForHours();

syncDerivedPointsIfNeeded();

function save() {
  state = saveMerged(state);
}


function render(){
  const list=$('logList'), empty=$('empty'); 
  list.innerHTML='';

  const comps = buildLogEntries(state.completions || []);

  if(!comps.length){
    empty.style.display='block';
    return;
  }
  empty.style.display='none';

  let lastDayKey = null;

  comps
    .slice()
    .sort((a,b)=> new Date(b.completedAtISO)-new Date(a.completedAtISO))
    .forEach(c=>{
      const completionDate = new Date(c.completedAtISO);
      const completionKey = dateKey(completionDate);
      if (completionKey && completionKey !== lastDayKey) {
        const divider = document.createElement('div');
        divider.className = 'day-divider';
        divider.innerHTML = `<span>${completionDate.toLocaleDateString(undefined, {
          weekday: 'short',
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        })}</span>`;
        list.appendChild(divider);
        lastDayKey = completionKey;
      }

      const row=document.createElement('div'); 
      row.className='row text-sm';

      const isHabit = (c.source === 'habit');
      const isVice  = (c.source === 'vice');
      const isFlex  = (c.source === 'flex');
      const isWork = c.source === 'work' || (c.title && c.title.startsWith('Work Score'));
      const isSleep = c.title && c.title.startsWith('Sleep Score');
      const isDiet = typeof c.title === 'string' && c.title.toLowerCase().startsWith('calories');
      const isMood = c.title && c.title.startsWith('Mood Score');
      const isInertia = c.source === 'inertia' || c.category === 'inertia';
      const baseSrc = isHabit ? 'Habit' : isVice ? 'Vice' : isFlex ? 'Flex' : isWork ? 'Work' : 'Task';
      const category = c.category
        || (isInertia ? 'inertia' : (window.TaskPointsCore?.categorizeCompletion ? TaskPointsCore.categorizeCompletion(c) : null));
      const srcMap = {
        sleep: 'Sleep',
        calories: 'Diet',
        mood: 'Mood',
        habits: 'Habit',
        vices: 'Vices',
        flex: 'Flex',
        work: 'Work',
        game: 'Game',
        inertia: 'Inertia',
        tasks: 'Task'
      };
      const src = srcMap[category] || baseSrc;
      const canDelete = (baseSrc === 'Task' || baseSrc === 'Flex'); // only tasks + flex get an X
      const canEditDate = (!isHabit && !isVice && !isInertia);      // allow date-edit for tasks + sleep + flex
      const displayPoints = getCompletionPoints(c);
      const displayTitle = (c.source === 'vice' && typeof c.title === 'string' && c.title.startsWith('[Habit]'))
        ? c.title.replace('[Habit]', '[Vice]')
        : c.title;


row.innerHTML = `
  <div>${new Date(c.completedAtISO).toLocaleString()}</div>
  <div>${escapeHtml(displayTitle)}</div>
  <div class="font-semibold">${displayPoints.toLocaleString()}</div>
  <div>${src}</div>
  <div class="flex gap-1 justify-center">
    ${canEditDate ? `<button class="btn" data-edit-date-id="${c.id}">üìÖ</button>` : ''}
    ${isSleep ? `<button class="btn" data-edit-sleep-id="${c.id}">‚úé</button>` : ''}
    ${canDelete ? `<button class="btn" data-del-id="${c.id}">‚úï</button>` : ''}
  </div>
  <div class="text-xs text-zinc-400 truncate">${c.id}</div>
`;



list.appendChild(row);

// Divider line between entries (very tight)
const divider = document.createElement('div');
divider.className = 'h-px bg-zinc-800 my-px opacity-40';
list.appendChild(divider);


    });

  // Hook up delete buttons
  list.querySelectorAll('button[data-del-id]').forEach(btn=>{
    btn.onclick = () => deleteCompletion(btn.getAttribute('data-del-id'));
  });

  // Hook up edit-sleep buttons
  list.querySelectorAll('button[data-edit-sleep-id]').forEach(btn=>{
    btn.onclick = () => editSleepScore(btn.getAttribute('data-edit-sleep-id'));
  });

  // Hook up edit-date buttons
  list.querySelectorAll('button[data-edit-date-id]').forEach(btn=>{
    btn.onclick = () => editCompletionDate(btn.getAttribute('data-edit-date-id'));
  });
}

function escapeHtml(s){ 
  return String(s).replace(/[&<>"']/g, m=>({
    '&':'&amp;',
    '<':'&lt;',
    '>':'&gt;',
    '"':'&quot;',
    "'":'&#039;'
  }[m]));
}

function deleteCompletion(id){
  const idx = state.completions.findIndex(c=>c.id===id);
  if(idx===-1) return;

  const c = state.completions[idx];
  const completionKey = safeCompletionDateKey(c);

  // We never show delete for habits or vices, but guard anyway
  if(c.source === 'habit' || c.source === 'vice') return;

  if(!confirm('Delete this completed task from the log and remove its points?')) return;

  // 1) Remove this completion from the log
  state.completions.splice(idx,1);

  // 2) If it was tied to a task, un-complete that task so it comes back
  if(c.taskId){
    const t = state.tasks.find(t=>t.id===c.taskId);
    if(t){
      t.completedAtISO = null;

      // If this was a repeating task, roll the due date back to the instance we just removed
      const prevDue = computePreviousDueDate(t, completionKey);
      if(prevDue) t.dueDateISO = prevDue;
    }
  }

  // 3) Save and re-render the log
  save();
  render();
}

function editCompletionDate(id){
  const entry = state.completions.find(c => c.id === id);
  if (!entry) return;

  const oldDate = new Date(entry.completedAtISO);
  if (isNaN(oldDate)) {
    alert('This entry has an invalid date.');
    return;
  }

  // Pre-fill with current completion date as YYYY-MM-DD
  const current = oldDate.toISOString().slice(0, 10);
  const input = prompt('Edit completion date (YYYY-MM-DD):', current);
  if (input === null) return; // user cancelled

  // Basic format check
  if (!/^\d{4}-\d{2}-\d{2}$/.test(input)) {
    alert('Please use the format YYYY-MM-DD (e.g. 2025-11-23).');
    return;
  }

  const newDate = new Date(input + 'T12:00:00');
  if (isNaN(newDate)) {
    alert('Invalid date.');
    return;
  }

  // Update completion timestamp (normalized to noon for safety)
  entry.completedAtISO = newDate.toISOString();

  // If linked to a task, keep that task's completedAtISO in sync
  if (entry.taskId) {
    const t = state.tasks.find(t => t.id === entry.taskId);
    if (t) {
      t.completedAtISO = entry.completedAtISO;
    }
  }

  save();
  render();
}

function editSleepScore(id){
  const entry = state.completions.find(c => c.id === id);
  if (!entry) return;

  const { score, rested } = getSleepInfo(entry);
  const currentScore = Number.isFinite(score) ? score : '';

  const newScore = prompt('Edit sleep score for this entry (0‚Äì100):', currentScore);
  if (newScore === null) return; // user pressed cancel

  const newRestedInput = prompt('Edit how rested you felt (number, blank = 0):', `${rested ?? 0}`);
  if (newRestedInput === null) return;

  const raw = Number(newScore);
  if (isNaN(raw) || raw < 0 || raw > 100) {
    alert('Invalid score. Please enter a number between 0 and 100.');
    return;
  }

  const newRested = newRestedInput.trim() === '' ? 0 : Number(newRestedInput);
  if (!Number.isFinite(newRested)) {
    alert('Invalid rested number.');
    return;
  }

  entry.title = `Sleep Score (${raw}) ‚Äî Rest ${newRested}`;
  entry.points = sleepPoints(raw, newRested); // keep in sync with main-page logic
  entry.sleepRested = newRested;


  save();
  render();
}


render();

</script>

<button
  class="hidden md:hidden fixed top-3 right-3 z-40 btn btn-teal rounded-full shadow-lg px-4 py-2 text-sm flex items-center gap-1"
  type="button"
  data-scroll-top
>
  <span>‚¨ÜÔ∏è</span>
  <span>Top</span>
</button>
</body>
</html>
