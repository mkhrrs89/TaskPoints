<!doctype html>
<html lang="en">
<!-- === DOCUMENT (START) This is the outer wrapper for the entire page. === -->
<head>
<!-- === HEAD (START)
"Head" = page setup: title, icons, fonts, scripts, CSS.
Nothing visible on the page is built here. === -->
  
  <!-- --- Basic page metadata (START) ------------------------- -->
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>TaskPoints ‚Äî To-Do + Points Tracker</title>
  <!-- --- Basic page metadata (END) --------------------------- -->

  <!-- iPhone / iOS PWA settings -->
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="default"/>
  <meta name="apple-mobile-web-app-title" content="TaskPoints"/>

  <!-- Favicon -->
  <link 
    rel="icon" 
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='48' fill='%230b0d10'/><text x='50' y='62' font-size='60' text-anchor='middle' fill='white'>TP</text></svg>">

  <!-- External libraries / fonts -->
    <link
    rel="stylesheet" 
    href="https://fonts.googleapis.com/css2?family=Teko:wght@500;600;700&display=swap">

  <!-- Your app scripts + CSS -->
  <script src="scoring_core.js"></script><link rel="stylesheet" href="assets/tailwind.css">

<link rel="stylesheet" href="styles.css">
  <link rel="preload" href="toolbar.js" as="script">
  <script src="toolbar.js" defer></script>

</head>
<!-- === HEAD (END) === -->


<!-- === BODY (START) === -->  
<body class="min-h-screen">

<!-- =========================================================================
           Everything visible on the page lives inside <body>.
========================================================================== -->

<!-- Floating toast notifications container -->
<div id="pointsToastContainer" class="points-toast-container"></div>

<!-- MAIN WRAPPER (START) ‚Äî this gives the whole app side padding + max width -->
<div class="mx-auto max-w-6xl p-4 sm:p-6 pb-20 md:pb-6">


<!-- HEADER (START) Top-of-page branding + navigation -->
<header class="mb-4">
  <!-- =========================================================
       MOBILE HEADER ROW (START)
       Visible on small screens only (md:hidden).
       ========================================================= -->
  <div class="flex items-center justify-between gap-3 mb-3 md:hidden">
    
    <!-- --- Logo + title (mobile) (START) ---------------------- -->
    <a href="index.html" class="flex items-center gap-3">
      <img
        src="assets/taskpoints-logo.png"
        alt="TaskPoints logo"
        class="w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm"
      />

      <h1 class="text-2xl font-extrabold tracking-tight leading-tight">
        <span style="color:#fb923c;">Task</span><span style="color:#1e666d;">Points</span>
      </h1>
    </a>
    <!-- --- Logo + title (mobile) (END) ------------------------ -->

    <!-- --- Import / Export (mobile) (START) ------------------- -->
    <div class="flex items-center gap-2">
      <button
        id="exportBtnMobile"
        type="button"
        class="btn btn-ghost btn-toolbar"
        data-export-button
      >
        Export
      </button>

      <label class="btn btn-ghost btn-toolbar cursor-pointer">
        <span>Import</span>
        <input
          id="importInputMobile"
          type="file"
          accept="application/json"
          class="hidden"
          data-import-input
        />
      </label>
    </div>
    <!-- --- Import / Export (mobile) (END) --------------------- -->
  </div>
  <!-- =========================================================
       MOBILE HEADER ROW (END)
       ========================================================= -->

  
  <!-- =========================================================
       DESKTOP HEADER ROW (START)
       Visible on md+ screens (logo left, nav on same row).
       ========================================================= -->
  <div class="row items-center">
    <!-- --- Logo + title (desktop) (START) --------------------- -->
    <div class="hidden md:flex items-center gap-3">
      <img
        src="assets/taskpoints-logo.png"
        alt="TaskPoints logo"
        class="w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm"
      />

      <h1 class="text-2xl sm:text-3xl font-extrabold tracking-tight">
        <span style="color:#fb923c;">Task</span><span style="color:#1e666d;">Points</span>
      </h1>
    </div>
    <!-- --- Logo + title (desktop) (END) ----------------------- -->


    <!-- =======================================================
         TOP NAV TOOLBAR (START)
         Desktop-only Export/Import + page navigation.
         ======================================================= -->
    <div class="toolbar header-nav">
      <!-- --- Export / Import (desktop) (START) ---------------- -->
      <button
        id="exportBtn"
        class="btn btn-ghost btn-toolbar hidden md:inline-flex"
        data-export-button
      >
        Export
      </button>
      <button
        type="button"
        class="btn btn-ghost btn-toolbar hidden md:inline-flex"
        data-export-images
      >
        Backup + Images
      </button>

      <label class="btn btn-ghost btn-toolbar cursor-pointer hidden md:inline-flex">
        Import
        <input
          id="importInput"
          type="file"
          accept="application/json"
          class="hidden"
          data-import-input
        />
      </label>
      <!-- --- Export / Import (desktop) (END) ------------------ -->


      <!-- --- Main nav links (START) --------------------------- -->
      <a
        href="index.html"
        class="btn btn-teal btn-toolbar nav-btn active"
        aria-current="page"
      >
        Main
      </a>
      <a href="today.html" class="btn btn-teal btn-toolbar nav-btn">Today</a>
      <a href="daily_sources.html" class="btn btn-teal btn-toolbar nav-btn">Sources</a>
      <a href="log.html" class="btn btn-teal btn-toolbar nav-btn">Log</a>
      <a href="week.html" class="btn btn-teal btn-toolbar nav-btn">Week</a>

      <!-- --- Game dropdown (START) ---------------------------- -->
      <div class="dropdown hidden md:block">
        <button
          type="button"
          class="btn btn-teal btn-toolbar nav-btn dropdown-toggle"
          data-dropdown-toggle
          aria-expanded="false"
        >
          Game <span class="caret">‚ñæ</span>
        </button>

        <div class="dropdown-menu">
          <a href="gamehub.html" class="btn btn-teal btn-toolbar nav-btn">Game Hub</a>
          <a href="game.html" class="btn btn-teal btn-toolbar nav-btn">Players</a>
          <a href="standings.html" class="btn btn-teal btn-toolbar nav-btn">Standings</a>
          <a href="matchups.html" class="btn btn-teal btn-toolbar nav-btn">Matchups</a>
          <a href="schedule.html" class="btn btn-teal btn-toolbar nav-btn">Schedule</a>
          <a href="game_ratings.html" class="btn btn-teal btn-toolbar nav-btn">Ratings</a>
          <a href="records.html" class="btn btn-teal btn-toolbar nav-btn">Records</a>
        </div>
      </div>
      <!-- --- Game dropdown (END) ------------------------------ -->

      <a href="projects.html" class="btn btn-teal btn-toolbar nav-btn">Projects</a>
      <a href="settings.html" class="btn btn-teal btn-toolbar nav-btn">Settings</a>
      <!-- --- Main nav links (END) ----------------------------- -->
      
    </div>  <!--  TOP NAV TOOLBAR (END)  -->
  </div>  <!-- DESKTOP HEADER ROW (END)  -->
</header>  <!--  HEADER (END)  -->

  
<!-- ========================================================================== -->  
<!--    TOP ROW (START) -->
<!--    This is the first ‚Äúmain content‚Äù block under the header. -->
<!--    ======================================================================= -->
  <div class="space-y-3 mb-6">
    <div class="grid gap-3 grid-cols-1 sm:grid-cols-2 lg:grid-cols-[2fr_1fr]">
      
      <!-- SCOREBOARD CARD (START) Shows You vs Opponent + score + diff. -->
      <div class="glass sm:col-span-2 lg:col-span-1">
        <div class="matchup-scoreboard">
          
          <!-- LEFT SIDE: YOU -->
          <div class="scoreboard-side">
            <div id="matchupYourName" class="scoreboard-name">You</div>
            <div id="matchupYourScore" class="scoreboard-score">‚Äî</div>
            <div id="matchupYourRecord" class="scoreboard-record">Record: 0-0</div>
            <div id="matchupYourAverages" class="scoreboard-meta">Daily Avg: ‚Äî ¬∑ PPD: ‚Äî</div>
          </div>

       <!-- MIDDLE: DIFF -->
          <div class="scoreboard-diff text-center">
            <div class="muted text-[11px] uppercase tracking-wide">The Diff</div>
            <div id="matchupDiffValue" class="scoreboard-diff-value">‚Äî</div>
            <div id="matchupDiff" class="muted text-xs mt-1">‚Äî</div>
          </div>
       

          <!-- RIGHT SIDE: OPPONENT -->
          <div class="scoreboard-side text-right">
            <div id="matchupOpponent" class="scoreboard-name text-right">‚Äî</div>
            <div id="matchupOpponentScore" class="scoreboard-score">‚Äî</div>
            <div id="matchupOpponentRecord" class="scoreboard-record">Record: 0-0</div>
            <div id="matchupOpponentAverages" class="scoreboard-meta text-right">Daily Avg: ‚Äî ¬∑ PPD: ‚Äî</div>
          </div>
       <!-- RIGHT SIDE: OPPONENT (END) -->
          
        </div>
      </div>
      
   <!--  =======================================================  -->
     <!--    SCOREBOARD CARD (END)     -->
   <!--  =======================================================  -->

      
      <!-- == CONTROLS CARD (START) Right-side card with quick action buttons. == -->
      <div class="glass sm:col-span-2 lg:col-span-1" id="matchupCard">
        <div class="flex items-start justify-end">
          <!-- Buttons stack differently depending on screen size -->
          <div class="flex flex-col gap-2 w-full sm:w-auto sm:flex-row lg:flex-col lg:w-auto">
            <button
              id="todayPointsAddTaskBtn"
              type="button"
              class="btn btn-teal w-full sm:w-auto"
              onclick="toggleAddTask()"
            >
              Add Task
            </button>
            
            <button
              type="button"
              class="btn btn-teal w-full sm:w-auto"
              onclick="scrollToTasks()"
            >
              Jump to Tasks
            </button>
          </div>
        </div>
      </div>
      <!-- ==  CONTROLS CARD (END)  == -->
      
    </div>

  <!-- ========================================================================== -->  
  <!-- ==  SECOND ROW (START) Inertia card (left) + daily trend chart (right)  == -->
  <!-- ========================================================================== -->   
    <div class="grid gap-3 grid-cols-1 lg:grid-cols-[0.7fr_1.3fr]">

      
      <!-- ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ  I N E R T I A   C A R D        ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò -->
      <div class="glass grid grid-cols-2 gap-4">
        <div class="flex flex-col items-center justify-center text-center gap-1.5">
          <div class="muted font-semibold uppercase tracking-wide text-[10px]">Inertia Score</div>
          <div class="text-4xl font-extrabold" id="inertiaValue">0.0</div>
          <div class="muted text-[11px] leading-tight" id="inertiaAverage">7-day avg: 0.0</div>
        </div>
        <div class="flex flex-col justify-center gap-1.5 border-l border-white/10 pl-4">
          <div class="muted font-semibold uppercase tracking-wide text-[10px]">Yesterday‚Äôs Results</div>
          <div class="flex items-center justify-between text-[11px]">
            <span class="muted">You</span>
            <span id="yesterdayYourScore" class="font-semibold">‚Äî</span>
          </div>
          <div class="flex items-center justify-between text-[11px]">
            <span id="yesterdayOpponent" class="font-semibold">Opponent</span>
            <span id="yesterdayOpponentScore" class="font-semibold">‚Äî</span>
          </div>
          <div class="flex items-center justify-between text-[11px]">
            <span class="muted">Result</span>
            <span id="yesterdayResult" class="font-semibold">‚Äî</span>
          </div>
        </div>
      </div>

      
      <!-- DAILY LINE GRAPH -->
      <div class="glass flex items-end">
        <canvas id="dailyTrend" class="w-full h-24"></canvas>
      </div>
    </div>
    <!--------------------------- SECOND ROW (END) --------------------------------->
  </div>
  <!-- ========================================================================== -->
                               <!-- TOP ROW (END) -->


  
  <!------------------------ TODAY'S POINTS BREAKDOWN BAR -------------------------->
  <div class="mb-6">
    <div class="flex items-center justify-between mb-1 text-[11px] muted">
      <span>Today‚Äôs Points Breakdown</span>
      <span id="todayBreakdownSummary" class="text-[11px]"></span>
    </div>
    <div class="today-breakdown-bar">
      <div id="todayBreakdownBar" class="h-full flex"></div>
    </div>
  </div>

  
  <!-- LEADERBOARDS -->
  <div class="grid sm:grid-cols-3 gap-3 mb-6">
    <!-- BEST DAYS -->
    <div class="glass">
      <h3 class="font-semibold mb-2">üèÜ Best Days</h3>
      <ul id="dailyBoard" class="text-xs space-y-1"></ul>
    </div>
    <!-- BEST WEEKS -->
    <div class="glass">
      <h3 class="font-semibold mb-2">üèÜ Best Weeks</h3>
      <ul id="weeklyBoard" class="text-xs space-y-1"></ul>
    </div>
    <!-- BEST MONTHS -->
    <div class="glass">
      <h3 class="font-semibold mb-2">üèÜ Best Months</h3>
      <ul id="monthlyBoard" class="text-xs space-y-1"></ul>
    </div>
  </div>
  <!-- LEADERBOARDS END -->

  
<!-- =================================== SLEEP + CALORIES ========================================= -->
<!-- ============================================================================================== -->
  
<!-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
     ‚ïë  S L E E P                                  ‚ïë
     ‚ïë  C A R D                                    ‚ïë
     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */ -->
  
<div class="grid sm:grid-cols-2 gap-3 mb-6">
  
  <!-- LEFT CARD: SLEEP SCORE (START) -->
  <div class="glass">
    <div class="flex items-stretch justify-between gap-6 flex-wrap stat-card-row">
      
      <!-- LEFT COLUMN: Big stat + input (Sleep) (START) -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-primary">
        <div class="sleep-today-card">
          <div class="stat-mobile-header">
            <!-- Compact row = title + inputs + (mobile) summary -->
            <div class="stat-compact-row">
              <!-- Title stack (Sleep) -->
              <div class="sleep-title-stack">
                <h2
                  id="sleepAnchor"
                  class="font-bold text-base sm:text-lg stat-title"
                >
                  Sleep
                </h2>
                
                <!-- Mobile-only: line under the title -->
                <div id="sleepImpactBelow" class="sleep-impact-below hidden"></div>
              </div>

              <!-- Inputs + mobile summary -->
              <div class="stat-compact-controls">
               <!-- Input row (before entry) -->   
               <div id="sleepInputRow" class="stat-input-row flex items-center gap-2 flex-wrap">
                 <input id="sleepScoreInput" class="input w-24 scoreInput" type="number" placeholder="0‚Äì100">
                 <input id="sleepRestedInput" class="input w-24 scoreInput" type="number" placeholder="Rested">
                 <button id="saveSleepScoreBtn" class="btn btn-plum">Add</button>
               </div>

    <!-- Mobile-only: right side summary (score + rest chip) -->
    <div id="sleepSummaryRow" class="stat-summary-row hidden" aria-live="polite">
      <span id="sleepSummaryValue" class="stat-summary-value"></span>
      <div id="sleepSummaryRest" class="sleep-rest-chip hidden">
        <span id="sleepSummaryRestValue"></span>
      </div>
    </div>
  </div>
</div>


  <div class="stat-compact-meta">
    <div class="muted text-xs">Today‚Äôs Sleep</div>
    <div class="flex items-center gap-2 flex-wrap">
      <div class="flex items-baseline gap-2">
        <div id="sleepTodayValue" class="text-4xl font-extrabold leading-tight stat-value">‚Äî</div>
        <div id="sleepTodayRest" class="sleep-rest-chip hidden"><span id="sleepTodayRestValue"></span></div>
      </div>
    </div>
    <div id="sleepTodayImpact" class="muted text-xs mt-1 stat-impact">Adds 0 pts to today</div>
  </div>
</div> <!-- closes .stat-mobile-header -->
</div> <!-- closes .sleep-today-card -->
</div> <!-- ‚úÖ ADD THIS: closes .stat-col-primary -->

<!-- RIGHT: History chips -->
<div class="flex-1 min-w-[220px] stat-col stat-col-secondary">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-semibold text-sm">Recent nights</h3>
          <button class="recent-toggle" type="button" data-target="sleepRecentWrap" aria-expanded="false">Show</button>
        </div>
        <div id="sleepRecentWrap" class="recentWrap hidden">
  <div id="sleepHistory" class="recentRow"></div>
</div>

      </div>
    </div>
  </div>


  
  <!------- RIGHT: Calories card ------->
<div class="glass calories-glass">
  <div class="flex items-stretch justify-between gap-6 flex-wrap stat-card-row">
      <!-- LEFT: Big stat + input -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-primary">
        <div class="calories-today-card">
          <div class="stat-mobile-header">
            <div class="stat-compact-row">
              <div class="cal-title-stack">
              <h2 class="font-bold text-lg stat-title">Calories</h2>
                <div id="caloriesImpactBelow" class="cal-impact-below hidden"></div>
              </div>

              <div class="stat-compact-controls">
                <div id="caloriesInputRow" class="stat-input-row caloriesEntryRow flex items-center gap-2 flex-nowrap">
                <input id="caloriesInput" class="input w-24" type="number" placeholder="0‚Äì3000">

                  <div class="datePickWrap" title="Pick date">
                  <button class="btn date-trigger dateTriggerBtn" type="button" aria-hidden="true" tabindex="-1">
                  </button>
                  <input id="caloriesDate" class="dateOverlay" type="date" aria-label="Pick a date for this calorie entry">
                  </div>

                <button id="saveCaloriesBtn" class="btn btn-teal">Add</button>
                </div>

                <div id="caloriesSummaryRow" class="stat-summary-row hidden" aria-live="polite">
                <span id="caloriesSummaryValue" class="stat-summary-value"></span>
                </div>
              </div>
            </div>
         
                      <div class="stat-compact-meta">
              <div class="muted text-xs">Today‚Äôs Calories</div>
              <div id="caloriesTodayValue" class="text-4xl font-extrabold leading-tight stat-value">‚Äî</div>
              <div id="caloriesTodayImpact" class="muted text-xs mt-1 stat-impact">Adds 0 pts to today</div>
              <div id="caloriesDateLabel" class="datePill"></div>
            </div>
      </div>
</div>  <!-- closes .stat-mobile-header -->
</div>  <!-- closes .calories-today-card -->
</div>  <!-- closes .stat-col-primary -->


      <!------- RIGHT: History chips ------->
      <div class="flex-1 min-w-[220px] stat-col stat-col-secondary">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-semibold text-sm">Recent days</h3>
          <button class="recent-toggle" type="button" data-target="caloriesRecentWrap" aria-expanded="false">Show</button>
        </div>
        <div id="caloriesRecentWrap" class="recentWrap hidden">
  <div id="caloriesHistory" class="recentRow"></div>
</div>

    </div>
  </div>
</div> <!-- end of SLEEP + CALORIES block -->

  
  
<!-- WORK SCORE + MOOD SCORE -->
<div class="grid sm:grid-cols-2 gap-3 mb-6">

  <!-- LEFT: Work Score -->
  <div class="glass">
    <div class="flex items-stretch justify-between gap-6 flex-wrap stat-card-row">

      <!-- LEFT SIDE: big stat + input -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-primary">
        <div class="work-today-card">
          <div class="stat-mobile-header">
            <div class="stat-compact-row">
  <div class="work-title-stack">
    <h2 id="workAnchor" class="font-semibold text-sm">Work</h2>
    <div id="workImpactBelow" class="work-impact-below hidden"></div>
  </div>

  <div class="stat-compact-controls">
    <!-- input row (before entry) -->
    <div id="workInputRow" class="stat-input-row">
      <input id="workScoreInput" class="input w-24" type="number" placeholder="0‚Äì10">
      <input id="workHoursInput" class="input w-24" type="number" placeholder="Hours">
      <button id="saveWorkScoreBtn" class="btn btn-work">Add</button>
    </div>

    <!-- summary row (after entry, mobile-only like Sleep/Calories) -->
    <div id="workSummaryRow" class="stat-summary-row hidden">
      <div class="flex items-center gap-2">
        <div id="workSummaryValue" class="stat-summary-value"></div>

        <div id="workSummaryHours" class="work-hours-chip hidden">
          <span id="workSummaryHoursValue"></span>
      </div>
    </div> <!-- closes inner flex -->
  </div> <!-- closes #workSummaryRow -->
</div> <!-- closes .stat-compact-controls -->

</div> <!-- closes .stat-compact-row -->

<!-- ‚úÖ ADD THIS meta block (still inside .stat-mobile-header) -->
<div class="stat-compact-meta">
  <div class="muted text-xs">Today‚Äôs Work</div>

  <div class="flex items-baseline gap-2 flex-wrap">
    <div id="workTodayValue" class="text-4xl font-extrabold leading-tight stat-value">‚Äî</div>

    <div id="workTodayHours" class="work-hours-chip hidden">
      <span id="workTodayHoursValue"></span>
    </div>
  </div>

  <div id="workTodayImpact" class="muted text-xs mt-1 stat-impact">Adds 0 pts to today</div>
</div>
<!-- ‚úÖ END meta block -->

</div> <!-- closes .stat-mobile-header -->
</div> <!-- closes .work-today-card -->
</div> <!-- closes .stat-col-primary -->



      <!-- RIGHT SIDE: history chips -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-secondary">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-semibold text-sm">Recent days</h3>
          <button class="recent-toggle" type="button" data-target="workRecentWrap" aria-expanded="false">Show</button>
        </div>
        <div id="workRecentWrap" class="recentWrap hidden">
         <div id="workHistory" class="recentRow"></div>
        </div>
      </div>
    </div> <!-- closes .stat-card-row -->
  </div> <!-- closes .glass -->

<!-- RIGHT: Mood Score -->
<div class="glass">
    <div class="flex items-stretch justify-between gap-6 flex-wrap stat-card-row">

    <!-- LEFT SIDE: big stat + input -->
    <div class="flex-1 min-w-[220px] stat-col stat-col-primary">
      <div class="mood-today-card">
        <div class="stat-mobile-header">
          <div class="stat-compact-row">
<div class="mood-title-stack">
  <h2 id="moodAnchor" class="font-semibold text-sm">Mood</h2>
  <div id="moodImpactBelow" class="mood-impact-below hidden"></div>
</div>

<div class="stat-compact-controls">
  <!-- input row (before entry) -->
  <div id="moodInputRow" class="stat-input-row">
    <input id="moodScoreInput" class="input w-24 scoreInput" type="number" placeholder="0‚Äì10">
    <button id="saveMoodScoreBtn" type="button" class="btn btn-mood">Add</button>
  </div>

  <!-- summary row (after entry, mobile-only like Work/Sleep/Calories) -->
  <div id="moodSummaryRow" class="stat-summary-row hidden">
    <div class="flex items-center gap-2">
      <div id="moodSummaryValue" class="stat-summary-value"></div>
    </div>
  </div>
</div>

          </div>

          <div class="stat-compact-meta">
            <div class="muted text-xs">Today‚Äôs Mood</div>
            <div id="moodTodayValue" class="text-4xl font-extrabold leading-tight stat-value">‚Äî</div>
            <div id="moodTodayImpact" class="muted text-xs mt-1 stat-impact">Adds 0 pts to today</div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT SIDE: history chips -->
    <div class="flex-1 min-w-[220px] stat-col stat-col-secondary">
      <div class="flex items-center justify-between mb-2">
        <h3 class="font-semibold text-sm">Recent days</h3>
        <button class="recent-toggle" type="button" data-target="moodRecentWrap" aria-expanded="false">Show</button>
      </div>
      <div id="moodRecentWrap" class="recentWrap hidden">
  <div id="moodHistory" class="recentRow"></div>
</div>

    </div>

  </div>
</div>


</div>



  <!-- HABITS -->
<div class="glass mb-6">
  <div class="flex items-center justify-between mb-3 gap-3 flex-wrap">
    <div class="flex items-center gap-3 flex-wrap">
      <h2 id="habitsAnchor" class="font-bold text-lg">Habits</h2>

      <select id="habitsSortSelect" class="input w-36">
        <option value="custom">Custom</option>
        <option value="points">Point value</option>
        <option value="streak">Current streak</option>
        <option value="completion">% completion</option>
      </select>
      <button id="addHabitBtn" class="btn btn-primary">Add Habit</button>
    </div>
  </div>

  <div class="grid gap-2 text-sm muted mb-2" id="habitWeekLabels"></div>
  <div id="habitsList" class="grid gap-2"></div>
  <div id="habitsEmpty" class="text-sm muted hidden">No habits yet.</div>
</div>

<!-- VICES -->
<div class="glass mb-6">
  <div class="flex items-center gap-3 flex-wrap mb-3">
    <h2 id="vicesAnchor" class="font-bold text-lg">Vices</h2>
    <button id="addViceBtn" class="btn btn-primary">Add Vice</button>
  </div>
  <div class="grid gap-2 text-sm muted mb-2" id="viceWeekLabels"></div>
  <div id="vicesList" class="grid gap-2"></div>
  <div id="vicesEmpty" class="text-sm muted hidden">No vices yet.</div>
</div>

  <!-- FLEX ACTIONS -->
  <div class="glass mb-6">
    <div class="flex items-center justify-between mb-3 gap-3 flex-wrap">
      <h2 id="flexAnchor" class="font-bold text-lg">Flex Actions</h2>
      <div class="flex gap-2 flex-wrap">
        <input id="flexName" class="input w-48" placeholder="Flex action">
        <input id="flexPts"  class="input w-28" type="number" step="any" placeholder="Pts/use">
        <button id="addFlexBtn" class="btn btn-primary">Add</button>
      </div>
    </div>
    <div id="flexList" class="grid gap-2 text-sm"></div>
    <div id="flexEmpty" class="text-sm muted hidden">No flex actions yet.</div>
  </div>

  <!-- TASKS grouped by day -->
  <div class="glass mb-6">
    <div class="flex justify-between items-center mb-3 gap-3 flex-wrap">
     <div class="flex items-center gap-3 flex-wrap">
       <h2 id="tasksAnchor" class="font-bold text-lg">Your Tasks</h2>
       <button id="openAddTaskBtn" class="btn btn-primary">Add Task</button>
     </div>
      <select id="sortSelect" class="input w-48">
        <option value="due">Sort by Due Date</option>
        <option value="importance">Sort by Importance</option>
        <option value="points">Sort by Points</option>
        <option value="alpha">Sort by Name</option>
      </select>
    </div>
    <div id="taskList" class="grid gap-2"></div>
    <div id="emptyList" class="text-sm muted hidden">No tasks yet.</div>
  </div>

  <footer class="mt-10 flex items-center justify-between">
    <p>Tip: On iPhone Safari ‚Üí <b>Add to Home Screen</b> for an app-like experience.</p>
    <p>v0.24.2 ‚Äî 2025-11-18</p>
  </footer>
</div>

<script>
const STORAGE_KEY="taskpoints_v1";
const OLD_PLAYERS_KEY="taskpoints_players";
const PROJECTS_STORAGE_KEY="tp_projects_v1";
const TODAY_STORE_KEY="taskpoints_today_view_v1";
const $=id=>document.getElementById(id);
const storageCache = { raw: null, parsed: null };
const bootStart = performance.now();
let state = normalizeState(load());
state = syncStateWithMatchups(state);
  // ---------- Derived cache (speeds up iOS renders) ----------
const _derived = {
  rev: 0,
  builtRev: -1,

  byDay: new Map(),       // key -> [completions]
  moodEntries: [],
  workEntries: [],
  caloriesEntries: [],
  sleepEntries: [],

  agg: null,               // { dailyTotals, weeklyTotals, monthlyTotals }
  lifetimePoints: 0
};

function markCompletionsDirty(){
  _derived.rev++;
}

function getDerived(){
  if (_derived.builtRev === _derived.rev) return _derived;

  const comps = Array.isArray(state?.completions) ? state.completions : [];

  // reset
  _derived.byDay = new Map();
  _derived.moodEntries = [];
  _derived.workEntries = [];
  _derived.caloriesEntries = [];
  _derived.sleepEntries = [];
  _derived.agg = null;
 _derived.lifetimePoints = 0;
  
  // one pass through completions
  for (const c of comps){
    if (!c || !c.completedAtISO) continue;

    _derived.lifetimePoints += Number(c.points) || 0;
    
    const d = new Date(c.completedAtISO);
    if (isNaN(d.getTime())) continue;

    // group by day key (for "today breakdown" etc)
    d.setHours(0,0,0,0);
    const k = dateKey(d);
    let arr = _derived.byDay.get(k);
    if (!arr){
      arr = [];
      _derived.byDay.set(k, arr);
    }
    arr.push(c);

    // category lists (match your existing history filters)
      const t = typeof c.title === 'string' ? c.title : '';

      if (t.startsWith('Mood Score')) _derived.moodEntries.push(c);
      if (t.startsWith('Work Score')) _derived.workEntries.push(c);
      if (t.startsWith('Sleep Score')) _derived.sleepEntries.push(c);
      if (t.startsWith('Calories')) _derived.caloriesEntries.push(c);


  }

  // sort once (instead of per-render per-history)
  const byNewest = (a, b) => new Date(b.completedAtISO) - new Date(a.completedAtISO);
  _derived.moodEntries.sort(byNewest);
  _derived.workEntries.sort(byNewest);
  _derived.caloriesEntries.sort(byNewest);
  _derived.sleepEntries.sort(byNewest);

  // aggregate once
  _derived.agg = aggregateCompletionsByDate(comps);

  _derived.builtRev = _derived.rev;
  return _derived;
}
// ---------- /Derived cache ----------

  const HABITS_SORT_KEY = "taskpoints_habits_sort";

async function migrateLegacyImagesIfNeeded() {
  if (!window.TaskPointsCore?.migrateLegacyImagesInStorage) return;
  try {
    const result = await TaskPointsCore.migrateLegacyImagesInStorage();
    if (result?.migrated) {
      state = syncStateWithMatchups(result.state || state);
      save();
      scheduleRender(renderAll);
      renderHabits();
      renderHabitWeekLabels();
      renderVices();
      renderViceWeekLabels();
    }
  } catch (e) {
    console.error("Image migration failed", e);
  }
}

migrateLegacyImagesIfNeeded();

function normalizeTask(task){
  if(!task || typeof task !== 'object') return task;
  const t = { ...task };
  if (typeof t.postponedDays !== 'number' || Number.isNaN(t.postponedDays)) {
    t.postponedDays = 0;
  }
  if (!t.originalDueDateISO && t.dueDateISO) {
    t.originalDueDateISO = t.dueDateISO;
  }
  return t;
}

function normalizeCompletion(entry) {
  if (!entry || typeof entry !== 'object') return entry;
  const c = { ...entry };
  const title = typeof c.title === 'string' ? c.title : '';
  const isMetric = title.startsWith('Sleep Score')
    || title.startsWith('Mood Score')
    || title.toLowerCase().startsWith('calories');
  if (isMetric && (!c.source || c.source === 'task')) {
    c.source = 'metric';
  }
  return c;
}

function normalizeHexColor(value) {
  if (!value) return null;
  let hex = String(value).trim();
  if (!hex) return null;
  if (!hex.startsWith('#')) hex = `#${hex}`;
  if (!/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(hex)) return null;
  if (hex.length === 4) {
    hex = `#${hex.slice(1).split('').map((c) => c + c).join('')}`;
  }
  return hex.toLowerCase();
}

function normalizeHabitTagColors(value) {
  if (!value || typeof value !== 'object') return {};
  const next = {};
  Object.entries(value).forEach(([tag, color]) => {
    const normalized = normalizeHexColor(color);
    if (normalized) next[String(tag)] = normalized;
  });
  return next;
}

function normalizeHabit(habit) {
  if (!habit || typeof habit !== 'object') return habit;
  return {
    ...habit,
    tag: typeof habit.tag === 'string' ? habit.tag.trim() : ''
  };
}

function hexToRgb(hex) {
  const normalized = normalizeHexColor(hex);
  if (!normalized) return null;
  const raw = normalized.replace('#', '');
  const r = parseInt(raw.slice(0, 2), 16);
  const g = parseInt(raw.slice(2, 4), 16);
  const b = parseInt(raw.slice(4, 6), 16);
  return { r, g, b };
}

function darkenHex(hex, amount = 0.35) {
  const rgb = hexToRgb(hex);
  if (!rgb) return null;
  const clamp = (value) => Math.max(0, Math.min(255, Math.round(value)));
  const factor = 1 - amount;
  return `#${[
    clamp(rgb.r * factor),
    clamp(rgb.g * factor),
    clamp(rgb.b * factor)
  ].map((val) => val.toString(16).padStart(2, '0')).join('')}`;
}

function getContrastText(hex) {
  const rgb = hexToRgb(hex);
  if (!rgb) return '#f8fafc';
  const toLinear = (c) => {
    const v = c / 255;
    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  };
  const luminance = 0.2126 * toLinear(rgb.r) + 0.7152 * toLinear(rgb.g) + 0.0722 * toLinear(rgb.b);
  return luminance > 0.6 ? '#0b0f14' : '#f8fafc';
}

function getHabitTagColor(tag) {
  if (!tag) return null;
  const colors = state.habitTagColors || {};
  return normalizeHexColor(colors[tag]);
}

function getHabitBubbleStyleAttr(tag, status) {
  if (!tag) return '';
  if (status !== 'on' && status !== 'failed') return '';
  const color = getHabitTagColor(tag);
  if (!color) return '';
  const dark = darkenHex(color, 0.35) || color;
  const textColor = getContrastText(color);
  return ` style="background:linear-gradient(135deg, ${color} 0%, ${dark} 100%);border-color:${dark};color:${textColor};"`;
}

function getHabitGroupStyleAttr(tag) {
  if (!tag) return '';
  const color = getHabitTagColor(tag);
  if (!color) return '';
  const dark = darkenHex(color, 0.35) || color;
  const textColor = getContrastText(color);
  return ` style="background:linear-gradient(135deg, ${color} 0%, ${dark} 100%);border-color:${dark};color:${textColor};"`;
}

function getHabitSortMode(){
  return ($('habitsSortSelect')?.value)
    || localStorage.getItem(HABITS_SORT_KEY)
    || 'custom';
}

function initHabitSortControl(){
  const sel = $('habitsSortSelect');
  if(!sel) return;

  const saved = localStorage.getItem(HABITS_SORT_KEY);
  if(saved && Array.from(sel.options).some(o => o.value === saved)){
    sel.value = saved;
  }

  sel.addEventListener('change', () => {
    localStorage.setItem(HABITS_SORT_KEY, sel.value);
    renderHabits();
  });
}

let editingTaskId = null;
let editingHabitId = null;
let editingFlexId = null;
let lastFlexCompletion = null;


function sleepBonus(score) {
  if (window.TaskPointsCore?.sleepBonus) {
    return TaskPointsCore.sleepBonus(score, state);
  }
  if (score >= 100) return 3;
  if (score >= 98) return 2;
  if (score >= 95) return 1;
  return 0;
}

function getSleepInfo(entry) {
  const match = entry?.title?.match(/\((\d+)\)/);
  const score = match ? Number(match[1]) : null;

  const restedRaw = entry && Object.prototype.hasOwnProperty.call(entry, 'sleepRested')
    ? Number(entry.sleepRested)
    : 0;
  const rested = Number.isFinite(restedRaw) ? restedRaw : 0;

  return { score, rested };
}

function sleepPoints(score, rested = 0) {
  if (window.TaskPointsCore?.sleepPoints) {
    return TaskPointsCore.sleepPoints(score, rested, state);
  }
  if (!Number.isFinite(score)) return 0;
  const base  = score / 10;
  const bonus = sleepBonus(score);
  return base + bonus + (Number.isFinite(rested) ? rested : 0);
}

function getWorkInfo(entry) {
  const match = entry?.title?.match(/\(([^)]+)\)/);
  const score = match ? Number(match[1]) : null;

  const hoursRaw = entry && Object.prototype.hasOwnProperty.call(entry, 'workHours')
    ? Number(entry.workHours)
    : 0;
  const hours = Number.isFinite(hoursRaw) ? hoursRaw : 0;

  return { score, hours };
}

function workHoursBonus(hours = 0) {
  if (window.TaskPointsCore?.workHoursBonus) {
    return TaskPointsCore.workHoursBonus(hours, state);
  }
  if (!Number.isFinite(hours)) return 0;
  return Math.max(0, hours) * 10;
}

function workPoints(score, hours = 0) {
  if (window.TaskPointsCore?.workPoints) {
    return TaskPointsCore.workPoints(score, hours, state);
  }
  if (!Number.isFinite(score)) return 0;
  return score + workHoursBonus(hours);
}

function getTodaySleepEntry() {
  const today = new Date();
  const todayKey = dateKey(today);

  for (const entry of state.completions) {
    if (!entry?.title?.startsWith('Sleep Score')) continue;
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayKey) return entry;
  }

  return null;
}

function getTodayCaloriesEntry() {
  const todayKey = dateKey(new Date());
  for (const entry of state.completions) {
    if (!entry?.title?.startsWith('Calories')) continue;
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayKey) return entry;
  }
  return null;
}

function editTodayCalories() {
  const entry = getTodayCaloriesEntry();
  if (!entry) return alert("You haven't entered today's calories yet.");

  const current = entry.title.match(/\((\d+)\)/)?.[1] ?? '';
  const newVal = prompt("Edit today's calories:", String(current));
  if (newVal === null) return; // user cancelled

  const raw = Number(String(newVal).trim());
  if (Number.isNaN(raw) || raw < 0) return alert("Invalid calories.");

  // keep it pinned to *today* so it stays a ‚Äútoday‚Äù entry
  const d = new Date();
  d.setHours(12, 0, 0, 0);

  entry.title = `Calories (${raw})`;
  entry.points = caloriesToPoints(raw);
  entry.completedAtISO = d.toISOString();

  markCompletionsDirty();
  
  save();
  scheduleRender(renderAll);
}

let sleepEditContext = null;

function promptEditSleepEntry(entry) {
  if (!entry) return;

  sleepEditContext = entry;

  const { score, rested } = getSleepInfo(entry);

  const modal = $('sleepEditModal');
  const scoreInput = $('sleepEditScoreInput');
  const restInput  = $('sleepEditRestedInput');
  const dateLabel  = $('sleepEditDateLabel');

  if (!modal || !scoreInput || !restInput) return;

  const scoreDisplay = Number.isFinite(score) ? score : '';
  const restDisplay  = Number.isFinite(rested) ? rested : '';

  scoreInput.value = scoreDisplay;
  restInput.value  = restDisplay;

  if (dateLabel) {
    const date = new Date(entry.completedAtISO);
    dateLabel.textContent = date.toLocaleDateString('en-US', {
      weekday: 'short', month: 'short', day: 'numeric'
    });
  }

  modal.classList.remove('hidden');
  modal.classList.add('flex');

  window.lockScrollForModal?.();

  scoreInput.focus();
  scoreInput.select();
}

function closeSleepEditModal() {
  const modal = $('sleepEditModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.classList.remove('flex');
  sleepEditContext = null;
  window.unlockScrollForModal?.();
}

function submitSleepEditModal() {
  if (!sleepEditContext) return closeSleepEditModal();

  const scoreInput = $('sleepEditScoreInput');
  const restInput  = $('sleepEditRestedInput');
  if (!scoreInput || !restInput) return;

  const scoreVal = Number(scoreInput.value);
  if (Number.isNaN(scoreVal) || scoreVal < 0 || scoreVal > 100) {
    alert('Enter a sleep score between 0 and 100.');
    return;
  }

  const restStr = restInput.value.trim();
  const restVal = restStr === '' ? 0 : Number(restStr);
  if (!Number.isFinite(restVal)) {
    alert('Rested value must be a number.');
    return;
  }

  sleepEditContext.title = `Sleep Score (${scoreVal}) ‚Äî Rest ${restVal}`;
  sleepEditContext.points = sleepPoints(scoreVal, restVal);
  sleepEditContext.sleepRested = restVal;

  markCompletionsDirty();
  save();
  scheduleRender(renderAll);
  closeSleepEditModal();
}

let workEditContext = null;
let workEditOptions = null;

function promptEditWorkEntry(entry, options = {}) {
  if (!entry) return;

  workEditContext = entry;
  workEditOptions = options;

  const { score, hours } = getWorkInfo(entry);

  const modal = $('workEditModal');
  const scoreInput = $('workEditScoreInput');
  const hoursInput = $('workEditHoursInput');
  const dateLabel = $('workEditDateLabel');

  if (!modal || !scoreInput || !hoursInput) return;

  const scoreDisplay = Number.isFinite(score) ? score : '';
  const hoursDisplay = Number.isFinite(hours) ? hours : '';

  scoreInput.value = scoreDisplay;
  hoursInput.value = hoursDisplay;

  if (dateLabel) {
    const date = new Date(entry.completedAtISO);
    dateLabel.textContent = date.toLocaleDateString('en-US', {
      weekday: 'short', month: 'short', day: 'numeric'
    });
  }

  modal.classList.remove('hidden');
  modal.classList.add('flex');

  window.lockScrollForModal?.();

  scoreInput.focus();
  scoreInput.select();
}

function closeWorkEditModal() {
  const modal = $('workEditModal');
  if (!modal) return;

  modal.classList.add('hidden');
  modal.classList.remove('flex');
  workEditContext = null;
  workEditOptions = null;
  window.unlockScrollForModal?.();
}

function submitWorkEditModal() {
  if (!workEditContext) return closeWorkEditModal();

  const scoreInput = $('workEditScoreInput');
  const hoursInput = $('workEditHoursInput');
  if (!scoreInput || !hoursInput) return;

  const scoreVal = Number(scoreInput.value);
  if (Number.isNaN(scoreVal)) {
    alert('Enter a valid work score.');
    return;
  }

  const hoursStr = hoursInput.value.trim();
  const hoursVal = hoursStr === '' ? 0 : Number(hoursStr);
  if (!Number.isFinite(hoursVal)) {
    alert('Hours value must be a number.');
    return;
  }

  const safeHours = Math.max(0, hoursVal);

  const d = new Date(workEditContext.completedAtISO);
  d.setHours(12, 0, 0, 0);

  if (workEditOptions?.pinToToday) {
    const today = new Date();
    today.setHours(12, 0, 0, 0);
    workEditContext.completedAtISO = today.toISOString();
  } else {
    workEditContext.completedAtISO = d.toISOString();
  }

  workEditContext.title = `Work Score (${scoreVal}) ‚Äî Hours ${safeHours}`;
  workEditContext.points = workPoints(scoreVal, safeHours);
  workEditContext.workHours = safeHours;
  workEditContext.source = 'work';

  markCompletionsDirty();
  save();
  scheduleRender(renderAll);
  closeWorkEditModal();
}

function migrateSleepEntriesForBonus() {
  if (!state || !Array.isArray(state.completions)) return;

  let changed = false;

  state.completions.forEach(c => {
    if (!c || !c.title || !c.title.startsWith('Sleep Score')) return;

    const { score, rested } = getSleepInfo(c);
    if (!Number.isFinite(score)) return;

    const restVal = Number.isFinite(rested) ? rested : 0;
    const newPts = sleepPoints(score, restVal);

    if (!Number.isFinite(c.sleepRested)) {
      c.sleepRested = restVal;
      changed = true;
    }

    // only update if different, to avoid noisy rewrites
    if (Math.abs((Number(c.points) || 0) - newPts) > 0.0001) {
      c.points = newPts;
      changed = true;
    }
  });

  if (changed) {
    markCompletionsDirty();
    save();
  }
}

migrateSleepEntriesForBonus();

function migrateWorkEntriesForHours() {
  if (!state || !Array.isArray(state.completions)) return;

  let changed = false;

  state.completions.forEach(c => {
    if (!c || !c.title || !c.title.startsWith('Work Score')) return;

    const { score, hours } = getWorkInfo(c);
    const safeHours = Number.isFinite(hours) ? Math.max(0, hours) : 0;
    const safeScore = Number.isFinite(score) ? score : Number(c.points) || 0;
    const newPts = workPoints(safeScore, safeHours);

    if (!Number.isFinite(c.workHours) || c.workHours !== safeHours) {
      c.workHours = safeHours;
      changed = true;
    }

    if (c.source !== 'work') {
      c.source = 'work';
      changed = true;
    }

    const desiredTitle = Number.isFinite(score)
      ? `Work Score (${score}) ‚Äî Hours ${safeHours}`
      : c.title;
    if (desiredTitle !== c.title) {
      c.title = desiredTitle;
      changed = true;
    }

    if (Math.abs((Number(c.points) || 0) - newPts) > 0.0001) {
      c.points = newPts;
      changed = true;
    }
  });

  if (changed) {
    markCompletionsDirty();
    save();
  }
}

migrateWorkEntriesForHours();


function isDesktop() {
  // Tailwind lg breakpoint (1024px) ‚Äì matches your layout
  return window.matchMedia("(min-width: 1024px)").matches;
}

function openAddTaskModal() {
  const modal = $("addTaskModal");
  if (!modal) return;

  modal.classList.remove("hidden");
  modal.classList.add("flex");

  window.lockScrollForModal?.();

  // ‚úÖ keep custom repeat row in sync immediately
  const repeatSel = $("repeatInput");
  if (repeatSel) syncCustomRepeatUI(repeatSel);

  $('titleInput')?.focus();
}


function closeAddTaskModal() {
  const modal = $("addTaskModal");
  if (!modal) return;

  modal.classList.add("hidden");
  modal.classList.remove("flex");
  window.unlockScrollForModal?.();
}

  function toggleAddTask() {
  const modal = $("addTaskModal");
  if (!modal) return;

  if (modal.classList.contains("hidden")) openAddTaskModal();
  else closeAddTaskModal();
}

function openAddTaskModal() {
  const modal = $("addTaskModal");
  if (!modal) return;

  modal.classList.remove("hidden");
  modal.classList.add("flex");
  window.lockScrollForModal?.();
  $("titleInput")?.focus();

  const btn = $("todayPointsAddTaskBtn");
  if (btn) btn.textContent = "Close";

  // ‚úÖ add this
  const rep = $("repeatInput");
  syncCustomRepeatUI(rep);
}


function closeAddTaskModal() {
  const modal = $("addTaskModal");
  if (!modal) return;

  modal.classList.add("hidden");
  modal.classList.remove("flex");
  window.unlockScrollForModal?.();

  // üëá and here
  const btn = $("todayPointsAddTaskBtn");
  if (btn) btn.textContent = "Add Task";
}


function showPointsToast(points){
  const container = $('pointsToastContainer');
  if(!container) return;

  const pts = Number(points) || 0;
  if(!pts) return;

  const div = document.createElement('div');
  div.className = 'points-toast';
  const sign = pts > 0 ? '+' : '';
  div.textContent = `${sign}${pts} pts`;

  container.appendChild(div);

  // remove after animation
  setTimeout(()=> {
    div.remove();
  }, 3200);
}

function parseCaloriesFromTitle(title) {
  if (typeof title !== 'string') return null;
  const match = title.match(/calories[^0-9]*([0-9]+(?:\.[0-9]+)?)/i);
  if (!match) return null;
  const raw = Number(match[1]);
  return Number.isFinite(raw) ? raw : null;
}

function caloriesToPoints(cal){
  if (window.TaskPointsCore?.caloriesToPoints) {
    return TaskPointsCore.caloriesToPoints(cal, state);
  }
  let pts = (2400 - cal) / 100;

  if (pts < 0) pts = 0;      // no negatives
  if (pts > 10) pts = 10;    // cap at 10

  pts = Math.round(pts * 10) / 10;  // nearest tenth
  return pts;
}

function moodPoints(score) {
  if (window.TaskPointsCore?.moodPoints) {
    return TaskPointsCore.moodPoints(score, state);
  }
  return Number.isFinite(score) ? score : 0;
}

function addCompletion(entry){
  const pts = Number(entry.points) || 0;
  state.completions.unshift(entry);
  markCompletionsDirty();
  showPointsToast(pts);
}

function removeTaskFromTodayView(taskId, dayKey) {
  if (!taskId || !dayKey) return;
  const raw = localStorage.getItem(TODAY_STORE_KEY);
  if (!raw) return;
  let parsed = null;
  try {
    parsed = JSON.parse(raw);
  } catch (e) {
    console.warn("Failed to parse today view storage", e);
    return;
  }
  if (!parsed || parsed.dayKey !== dayKey) return;

  const taskIds = Array.isArray(parsed.taskIds) ? parsed.taskIds : [];
  const order = Array.isArray(parsed.order) ? parsed.order : [];
  const nextTaskIds = taskIds.filter((id) => id !== taskId);
  const taskKey = `task:${taskId}`;
  const nextOrder = order.filter((key) => key !== taskKey);
  if (nextTaskIds.length === taskIds.length && nextOrder.length === order.length) return;

  localStorage.setItem(TODAY_STORE_KEY, JSON.stringify({
    ...parsed,
    taskIds: nextTaskIds,
    order: nextOrder
  }));
}

function loadProjectsFromStorage(){
  try{
    const raw = localStorage.getItem(PROJECTS_STORAGE_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  }catch(e){
    console.error("Failed to load projects from storage", e);
    return [];
  }
}

function saveProjectsToStorage(list){
  try{
    if (Array.isArray(list)){
      localStorage.setItem(PROJECTS_STORAGE_KEY, JSON.stringify(list));
    }
  }catch(e){
    console.error("Failed to save projects to storage", e);
  }
}

function getCachedStorageState() {
  if (storageCache.parsed) return storageCache.parsed;
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return null;
  const parsed = JSON.parse(raw);
  storageCache.raw = raw;
  storageCache.parsed = parsed;
  return parsed;
}

function writeCachedStorageState(nextState) {
  if (window.TaskPointsCore?.saveAppState) {
    const res = TaskPointsCore.saveAppState(nextState, { storageKey: STORAGE_KEY });
    storageCache.raw = null;          // don't stringify here (too expensive)
    storageCache.parsed = res.state;
    return res.state;
  }
  if (window.TaskPointsCore?.mergeAndSaveState) {
    const res = TaskPointsCore.mergeAndSaveState(nextState, { storageKey: STORAGE_KEY });
    storageCache.raw = null;          // don't stringify here (too expensive)
    storageCache.parsed = res.state;
    return res.state;
  }
  console.warn("writeCachedStorageState skipped localStorage write; TaskPointsCore missing.");
  storageCache.raw = null;            // don't stringify here either
  storageCache.parsed = nextState;
  return nextState;
}


function load() {
  try {
    const cached = getCachedStorageState();
    if (!cached) {
      // nothing saved yet on this device
      return {
        tasks:        [],
        completions:  [],
        players:      [],
        habits:       [],
        flexActions:  [],
        gameHistory:  [],
        matchups:     [],
        schedule:     [],
        opponentDripSchedules: [],
        projects:     loadProjectsFromStorage(),
        youImageId:   "",
        habitTagColors: {},
        scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
          ? TaskPointsCore.normalizeScoringSettings({})
          : {}
      };
    }

    const p = cached;
    const storedProjects = loadProjectsFromStorage();

    return {
      tasks:        Array.isArray(p.tasks)        ? p.tasks        : [],
      completions:  Array.isArray(p.completions)  ? p.completions  : [],
      players:      Array.isArray(p.players)      ? p.players      : [],
      habits:       Array.isArray(p.habits)       ? p.habits       : [],
      flexActions:  Array.isArray(p.flexActions)  ? p.flexActions  : [],
      gameHistory:  Array.isArray(p.gameHistory)  ? p.gameHistory  : [],
      matchups:     Array.isArray(p.matchups)     ? p.matchups     : [],
      schedule:     Array.isArray(p.schedule)     ? p.schedule     : [],
      opponentDripSchedules: Array.isArray(p.opponentDripSchedules) ? p.opponentDripSchedules : [],
      projects:     Array.isArray(p.projects)     ? p.projects     : storedProjects,
      youImageId:   typeof p.youImageId === "string" ? p.youImageId : "",
      habitTagColors: normalizeHabitTagColors(p.habitTagColors),
      scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
        ? TaskPointsCore.normalizeScoringSettings(p.scoringSettings || {})
        : (p.scoringSettings || {})
    };
  } catch (e) {
    console.error('Failed to load TaskPoints state on main page', e);
    return {
      tasks:        [],
      completions:  [],
      players:      [],
      habits:       [],
      flexActions:  [],
      gameHistory:  [],
      matchups:     [],
      schedule:     [],
      opponentDripSchedules: [],
      projects:     loadProjectsFromStorage(),
      youImageId:   "",
      habitTagColors: {},
      scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
        ? TaskPointsCore.normalizeScoringSettings({})
        : {}
    };
  }
}

function syncStateWithMatchups(current){
  let nextState = current;
  let changed = false;

  if (window.TaskPointsCore?.syncDerivedPoints) {
    const derivedSync = TaskPointsCore.syncDerivedPoints(nextState);
    nextState = derivedSync.state;
    changed = changed || derivedSync.changed;
  }

  if (window.TaskPointsCore?.syncYouMatchups) {
    const matchupSync = TaskPointsCore.syncYouMatchups(nextState);
    nextState = matchupSync.state;
    changed = changed || matchupSync.changed;
  }

  if (changed) {
    try {
      if (window.TaskPointsCore?.saveAppState) {
        const merged = TaskPointsCore.saveAppState(nextState).state;
        storageCache.parsed = merged;
        storageCache.raw = null;
        return merged;
      }
      if (window.TaskPointsCore?.mergeAndSaveState) {
        const merged = TaskPointsCore.mergeAndSaveState(nextState).state;
        storageCache.parsed = merged;
        storageCache.raw = null;
        return merged;
      }
      writeCachedStorageState(nextState);
    } catch (e) {
      console.error('Failed to persist synced matchups', e);
    }
  }
  return nextState;
}

function getPlayerNameById(id) {
  if (!id) return 'Unknown opponent';
  if (id === 'YOU') return 'You';

  const players = Array.isArray(state.players) ? state.players : [];
  const match = players.find(p => p && p.id === id);
  if (match && match.name) return match.name;

  return 'Opponent';
}

function getPlayerById(id) {
  if (!id || id === 'YOU') return null;

  const players = Array.isArray(state.players) ? state.players : [];
  return players.find(p => p && p.id === id) || null;
}

function getPlayerRecordText(playerId) {
  if (!playerId || playerId === 'YOU') return '0-0';

  if (window.TaskPointsCore?.computeRecord) {
    const record = TaskPointsCore.computeRecord(state, playerId, { includeToday: false, allowFallback: false });
    return record.games ? `${record.wins}-${record.losses}` : '0-0';
  }

  const player = getPlayerById(playerId);
  const baseline = player && typeof player.baseline === 'number'
    ? player.baseline
    : null;

  const history = Array.isArray(state.gameHistory) ? state.gameHistory : [];

  let wins = 0;
  let losses = 0;
  let games = 0;

  for (const g of history) {
    if (!g || g.playerId !== playerId) continue;

    games++;
    const score = typeof g.score === 'number' ? g.score : Number(g.score) || 0;

    if (baseline != null) {
      if (score >= baseline) wins++;
      else losses++;
    }
  }

  return games ? `${wins}-${losses}` : '0-0';
}

function getYourRecordText() {
  const formatRecord = (rec) => `${rec.wins}-${rec.losses}`;
  const record = computeYourRecord();
  return formatRecord(record);
}

function computeYourRecord(){
  if (window.TaskPointsCore?.computeRecord) {
    return TaskPointsCore.computeRecord(state, 'YOU', { includeToday: false, allowFallback: false });
  }
  const matchupRecord = computeYourMatchupRecord();
  if (matchupRecord.games > 0) return matchupRecord;
  return computeYourCompletionRecord();
}

function getCompletionPoints(entry) {
  if (window.TaskPointsCore?.pointsForCompletion) {
    return TaskPointsCore.pointsForCompletion(entry);
  }
  const caloriesRaw = parseCaloriesFromTitle(entry?.title);
  if (Number.isFinite(caloriesRaw)) return caloriesToPoints(caloriesRaw);
  return Number(entry?.points) || 0;
}

function computeYourMatchupRecord(){
  const matchups = Array.isArray(state.matchups) ? state.matchups : [];
  let wins = 0;
  let losses = 0;
  let ties = 0;
  let games = 0;

  matchups.forEach(m => {
    if (!m || (m.playerAId !== 'YOU' && m.playerBId !== 'YOU')) return;
    const aScore = Number(m.scoreA);
    const bScore = Number(m.scoreB);
    if (!Number.isFinite(aScore) || !Number.isFinite(bScore)) return;

    games++;
    const yourScore = m.playerAId === 'YOU' ? aScore : bScore;
    const oppScore  = m.playerAId === 'YOU' ? bScore : aScore;

    if (yourScore > oppScore) wins++;
    else if (yourScore < oppScore) losses++;
    else ties++;
  });

  return { wins, losses, ties, games, source: 'matchups' };
}

function computeYourCompletionRecord(){
  const comps = Array.isArray(state.completions) ? state.completions : [];
  if (!comps.length) return { wins: 0, losses: 0, ties: 0, games: 0, source: 'completions' };

  const dayTotals = {};

  comps.forEach(c => {
    if (!c || !c.completedAtISO) return;
    const k = dateKey(c.completedAtISO);
    const pts = getCompletionPoints(c);
    if (!Number.isFinite(pts)) return;
    dayTotals[k] = (dayTotals[k] || 0) + pts;
  });

  const totals = Object.values(dayTotals);
  if (!totals.length) return { wins: 0, losses: 0, ties: 0, games: 0, source: 'completions' };

  const avg = totals.reduce((a, b) => a + b, 0) / totals.length || 0;
  let wins = 0;
  let losses = 0;
  let ties = 0;

  totals.forEach(total => {
    if (total > avg) wins++;
    else if (total < avg) losses++;
    else ties++;
  });

  return { wins, losses, ties, games: totals.length, source: 'completions' };
}

function computeYouDailyAverages(){
  const comps = Array.isArray(state.completions) ? state.completions : [];
  if (!comps.length) return { dailyAvg: 0, ppd: 0, hasData: false };

  const dayTotals = {};

  comps.forEach(c => {
    if (!c || !c.completedAtISO) return;
    const k = dateKey(c.completedAtISO);
    const pts = getCompletionPoints(c);
    dayTotals[k] = (dayTotals[k] || 0) + pts;
  });

  const totals = Object.values(dayTotals);
  if (!totals.length) return { dailyAvg: 0, ppd: 0, hasData: false };

  const avg = totals.reduce((a, b) => a + b, 0) / totals.length;
  const rounded = Number(avg.toFixed(1));

  return { dailyAvg: rounded, ppd: rounded, hasData: true };
}

function computePlayerDailyAverages(playerId){
  if (!playerId) return { dailyAvg: 0, ppd: 0, hasData: false };
  if (playerId === 'YOU') return computeYouDailyAverages();

  const history = Array.isArray(state.gameHistory) ? state.gameHistory : [];
  const scores = history
    .filter(h => h && h.playerId === playerId)
    .map(h => Number(h.score))
    .filter(Number.isFinite);

  if (!scores.length) return { dailyAvg: 0, ppd: 0, hasData: false };

  const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
  const rounded = Number(avg.toFixed(1));

  return { dailyAvg: rounded, ppd: rounded, hasData: true };
}

function formatAverageLine(avg, ppd){
  const formatVal = (v) => Number.isFinite(v) ? v.toFixed(1) : '‚Äî';
  return `Daily Avg: ${formatVal(avg)} ¬∑ PPD: ${formatVal(ppd)}`;
}


/* ---------- OPPONENT DRIP SCHEDULE ---------- */
function getOpponentDripSchedules(){
  return Array.isArray(state.opponentDripSchedules) ? state.opponentDripSchedules : [];
}

function generateOpponentDripSchedule(dateKeyStr, playerId, totalPoints){
  const totalRounded = Math.max(0, Math.round((Number(totalPoints) || 0) * 10) / 10);
  const totalUnits   = Math.round(totalRounded * 10);

  const startHour = 6;
  const endHour   = 23;
  const count     = Math.max(12, Math.min(40, Math.round(Math.random() * 20) + 15));

  const baseDate = new Date(`${dateKeyStr}T00:00:00`);

  const hourBuckets = [];
  for (let h = startHour; h <= endHour; h++) {
    let weight = 1;

    // Favor earlier hours
    if (h >= 6 && h <= 11) weight += 1.6;
    if (h >= 12 && h <= 15) weight += 0.6;
    if (h >= 18 && h <= 23) weight -= 0.2;

    // Random dead zones
    if (Math.random() < 0.15) weight *= 0.4;

    hourBuckets.push({ hour: h, weight: Math.max(0.2, weight) });
  }

  const totalHourWeight = hourBuckets.reduce((s, h) => s + h.weight, 0) || 1;

  function pickTime(){
    let r = Math.random() * totalHourWeight;
    let chosenHour = startHour;
    for (const h of hourBuckets) {
      if (r <= h.weight) { chosenHour = h.hour; break; }
      r -= h.weight;
    }

    const m = Math.floor(Math.random() * 60);
    const s = Math.floor(Math.random() * 60);
    const d = new Date(baseDate.getTime());
    d.setHours(chosenHour, m, s, 0);
    return d;
  }

  const weights = [];
  for (let i = 0; i < count; i++) {
    const base = Math.pow(Math.random(), 1.4);
    const burst = Math.random() < 0.35 ? Math.random() * 1.2 : 0;
    weights.push(base + burst);
  }

  const weightSum = weights.reduce((s, n) => s + n, 0) || 1;

  let remaining = totalUnits;
  const pointUnits = [];
  for (let i = 0; i < count; i++) {
    if (i === count - 1) {
      pointUnits.push(Math.max(0, remaining));
    } else {
      const share = Math.min(
        remaining,
        Math.max(0, Math.round((weights[i] / weightSum) * totalUnits))
      );
      pointUnits.push(share);
      remaining -= share;
    }
  }

  // If rounding left stragglers, tack them onto the last bucket
  if (remaining > 0 && pointUnits.length) {
    pointUnits[pointUnits.length - 1] += remaining;
  }

  const times = pointUnits.map(() => pickTime()).sort((a, b) => a - b);
  const sizedUnits = pointUnits.slice().sort((a, b) => b - a);

  const events = sizedUnits
    .map((units, idx) => ({ t: times[idx].toISOString(), pts: units / 10 }))
    .filter(e => e.pts > 0)
    .sort((a, b) => new Date(a.t) - new Date(b.t));

  return {
    date: dateKeyStr,
    playerId,
    total: totalRounded,
    events
  };
}

function ensureOpponentDripSchedule(dateKeyStr, playerId, totalPoints){
  if (!dateKeyStr || !playerId) return null;

  const schedules = getOpponentDripSchedules();
  const existingIdx = schedules.findIndex(s => s && s.date === dateKeyStr && s.playerId === playerId);
  const totalRounded = Math.max(0, Math.round((Number(totalPoints) || 0) * 10) / 10);

  if (existingIdx !== -1) {
    const existing = schedules[existingIdx];
    if (existing && Math.abs((existing.total || 0) - totalRounded) < 0.001 && Array.isArray(existing.events) && existing.events.length) {
      return existing;
    }
  }

  const next = generateOpponentDripSchedule(dateKeyStr, playerId, totalRounded);
  const updated = schedules.filter(s => !(s && s.date === dateKeyStr && s.playerId === playerId));
  updated.push(next);

  state.opponentDripSchedules = updated;
  save();

  return next;
}

function accruedOpponentPoints(schedule, now = new Date()){
  if (!schedule) return 0;
  const events = Array.isArray(schedule.events) ? schedule.events.slice() : [];
  events.sort((a, b) => new Date(a.t) - new Date(b.t));

  const nowMs = now.getTime();
  const total = Math.max(0, Number(schedule.total) || 0);

  if (!events.length) return total;

  const firstMs = new Date(events[0].t).getTime();
  const lastMs  = new Date(events[events.length - 1].t).getTime();

  if (Number.isFinite(firstMs) && nowMs < firstMs) return 0;
  if (Number.isFinite(lastMs) && nowMs >= lastMs) return total;

  let accruedUnits = 0;
  events.forEach(e => {
    const when = new Date(e.t).getTime();
    const pts = Math.round((Number(e.pts) || 0) * 10);
    if (Number.isFinite(when) && nowMs >= when) {
      accruedUnits += Math.max(0, pts);
    }
  });

  const capped = Math.min(total * 10, accruedUnits);
  return Math.max(0, capped / 10);
}

function visibleOpponentScoreForMatchup(dateKeyStr, playerId, targetTotal){
  const schedule = ensureOpponentDripSchedule(dateKeyStr, playerId, targetTotal);
  return schedule ? accruedOpponentPoints(schedule, new Date()) : Math.max(0, Number(targetTotal) || 0);
}

/* ---------- MATCHUP AUTO-SIM ---------- */
function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function isPlayerActive(player){
  return !!player && player.active !== false;
}

function getAllParticipantIds(){
  const ids = ['YOU'];
  (state.players || []).forEach(p => {
    if (p && p.id && isPlayerActive(p)) ids.push(p.id);
  });
  return ids;
}

function participantSignature(ids){
  return ids.slice().sort().join('|');
}

function buildDailySchedule(dateKeyStr, participantIds, signature){
  const pool = participantIds.slice();
  shuffle(pool);

  const matchups = [];
  const byeIds = [];

  for (let i = 0; i + 1 < pool.length; i += 2) {
    matchups.push({
      playerAId: pool[i],
      playerBId: pool[i + 1]
    });
  }

  if (pool.length % 2 === 1) {
    byeIds.push(pool[pool.length - 1]);
  }

  return {
    date: dateKeyStr,
    matchups,
    byeIds,
    participantSignature: signature
  };
}

function ensureUpcomingSchedule(days = 7){
  const today = new Date();
  today.setHours(0,0,0,0);
  const todayKey = dateKey(today);

  const participants = getAllParticipantIds();
  const signature = participantSignature(participants);

  let schedule = Array.isArray(state.schedule) ? state.schedule.filter(d => d && d.date >= todayKey) : [];
  let changed = false;

  if (!schedule.every(d => d.participantSignature === signature)) {
    schedule = [];
    changed = true;
  }

  const neededDates = [];
  for (let i = 0; i < days; i++) {
    const dt = new Date(today);
    dt.setDate(dt.getDate() + i);
    neededDates.push(dateKey(dt));
  }

  const byDate = new Map();
  schedule.forEach((d) => {
    if (d && d.date) byDate.set(d.date, d);
  });

  const rebuilt = neededDates.map((key) => {
    const existing = byDate.get(key);
    if (existing) return existing;
    changed = true;
    return buildDailySchedule(key, participants, signature);
  });

  if (rebuilt.length !== schedule.length) changed = true;

  state.schedule = rebuilt;
  return changed;
}

function computeTodayPoints() {
  const today = new Date();
  today.setHours(0,0,0,0);
  const todayKey = dateKey(today);

  if (window.TaskPointsCore && typeof TaskPointsCore.buildDaySnapshot === "function" && typeof TaskPointsCore.computeDayTotals === "function") {
    const snapshot = TaskPointsCore.buildDaySnapshot(todayKey, state);
    const totals = TaskPointsCore.computeDayTotals(snapshot);
    return Number((totals.total || 0).toFixed(1));
  }

  const comps = Array.isArray(state.completions) ? state.completions : [];
  if (!comps.length) return 0;

  let total = 0;

  for (const c of comps) {
    if (!c || !c.completedAtISO) continue;

    const dk = dateKey(c.completedAtISO);
    if (dk === todayKey) {
      total += Number(c.points || 0);
    }
  }

  return Number(total.toFixed(1));
}

function simulateAiScoreForPlayer(player, todayKey){
  if (!player || !player.baseline) return 0;

  const baseline = Number(player.baseline);
  const variance = Number(player.variance);
  const varianceTiltRaw = Number(
    typeof player.varianceTilt === "number" ? player.varianceTilt : (player.varianceTilt || 50)
  );
  const varianceTilt = Math.min(100, Math.max(0, varianceTiltRaw)) / 100;
  const momentum = Number(player.momentum);

  let riskyRating = Number(player.risky);
  if (isNaN(riskyRating)) riskyRating = 0;
  const riskyNormalized = riskyRating > 10 ? riskyRating / 10 : riskyRating;

  const variationMagnitude = Math.random() * variance;
  const variationSign = Math.random() < varianceTilt ? 1 : -1;
  const variation = variationMagnitude * variationSign;

  let momentumBonus = 0;
  if (momentum && state.gameHistory.length) {
    const prev = state.gameHistory
      .filter(g => g.playerId === player.id)
      .sort((a,b) => b.date.localeCompare(a.date))[0];

    if (prev && prev.date !== todayKey) {
      momentumBonus = (prev.score * (momentum / 100)) * 0.18;
    }
  }

  let riskyMod = 0;
  if (Math.random() < riskyNormalized / 10) {
    const boom = Math.random() < 0.5;
    const riskyScale = 0.5 + Math.random() * 2.5;
    riskyMod = boom
      ? variance * riskyScale
      : -variance * riskyScale;
  }

  const score = baseline + variation + momentumBonus + riskyMod;
  return Number(score.toFixed(1));
}

function makeId() {
  if (window.crypto && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  return "id_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2);
}

function simulateToday() {
  const todayKey = getGameDayKey(new Date());

  state.gameHistory = state.gameHistory || [];
  state.matchups    = state.matchups    || [];
  state.schedule    = state.schedule    || [];

  ensureUpcomingSchedule();

  state.gameHistory = state.gameHistory.filter(g => g.date !== todayKey);
  state.matchups    = state.matchups.filter(m => (m.date || m.dateKey) !== todayKey);

  const todaysSchedule = state.schedule.find(d => d && d.date === todayKey);
  const todaysPairs = todaysSchedule && Array.isArray(todaysSchedule.matchups)
    ? todaysSchedule.matchups
    : [];

  if (!todaysPairs.length) {
    save();
    return;
  }

  const namesById = {};
  const playerMap = new Map();
  (state.players || []).forEach(p => {
    if (!p || !p.id) return;
    playerMap.set(p.id, p);
    namesById[p.id] = p.name || "Unnamed";
  });
  namesById["YOU"] = "You";

  const participantIds = Array.from(new Set(
    todaysPairs.flatMap(m => [m.playerAId, m.playerBId])
  ));

  const scoresById = {};

  const youScore = computeTodayPoints();
  if (participantIds.includes('YOU') && !isNaN(youScore)) {
    scoresById['YOU'] = youScore;
  }

  participantIds.forEach(id => {
    if (id === 'YOU') return;
    const player = playerMap.get(id);
    if (!player) return;
    const score = simulateAiScoreForPlayer(player, todayKey);
    scoresById[id] = score;
    ensureOpponentDripSchedule(todayKey, id, score);
    state.gameHistory.push({
      id: makeId(),
      date: todayKey,
      playerId: id,
      score
    });
  });

  todaysPairs.forEach(pair => {
    const matchup = {
      id: makeId(),
      date: todayKey,
      playerAId: pair.playerAId,
      playerBId: pair.playerBId,
      playerAName: namesById[pair.playerAId] || "Unknown",
      playerBName: namesById[pair.playerBId] || "Unknown",
      scoreA: scoresById[pair.playerAId] ?? 0,
      scoreB: scoresById[pair.playerBId] ?? 0
    };

    state.matchups.push(matchup);
  });

  save();
}

function maybeAutoSimToday(){
  const now = new Date();
  const todayKey = getGameDayKey(now);

  if (now.getHours() < 8) return false;
  if (!Array.isArray(state.players) || state.players.length === 0) return false;

  state.gameHistory = state.gameHistory || [];
  state.matchups = state.matchups || [];

  const hasTodayHistory = state.gameHistory.some(g => g.date === todayKey);
  const hasTodayMatchup = state.matchups.some(m => {
    const key = m?.date || m?.dateKey || (m?.dateISO ? dateKey(m.dateISO) : "");
    return key === todayKey;
  });
  if (hasTodayHistory || hasTodayMatchup) return false;

  simulateToday();
  return true;
}


function normalizeState(s) {
  return {
    tasks:       Array.isArray(s.tasks)       ? s.tasks.map(normalizeTask)       : [],
    completions: Array.isArray(s.completions) ? s.completions.map(normalizeCompletion) : [],
    players:     Array.isArray(s.players)     ? s.players     : [],
    habits:      Array.isArray(s.habits)      ? s.habits.map(normalizeHabit)      : [],
    flexActions: Array.isArray(s.flexActions) ? s.flexActions : [],
    gameHistory: Array.isArray(s.gameHistory) ? s.gameHistory : [],
    matchups:    Array.isArray(s.matchups)    ? s.matchups    : [],
    schedule:    Array.isArray(s.schedule)    ? s.schedule    : [],
    opponentDripSchedules: Array.isArray(s.opponentDripSchedules) ? s.opponentDripSchedules : [],
    youImageId:  typeof s.youImageId === "string" ? s.youImageId : "",
    projects:    Array.isArray(s.projects)    ? s.projects    : loadProjectsFromStorage(),
    habitTagColors: normalizeHabitTagColors(s.habitTagColors),
    scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
      ? TaskPointsCore.normalizeScoringSettings(s.scoringSettings || {})
      : (s.scoringSettings || {})
  };
}

function save() {
  try {
    if (window.TaskPointsCore?.saveAppState) {
      const { state: merged, trimmed } = TaskPointsCore.saveAppState(state);
      if (trimmed) {
        console.warn('Storage nearing capacity. Older history items were trimmed to keep saves working.');
      }
      state = merged;
      storageCache.parsed = merged;
      storageCache.raw = null;
      return;
    }
    if (window.TaskPointsCore?.mergeAndSaveState) {
      const { state: merged, trimmed } = TaskPointsCore.mergeAndSaveState(state);
      if (trimmed) {
        console.warn('Storage nearing capacity. Older history items were trimmed to keep saves working.');
      }
      state = merged;
      storageCache.parsed = merged;
      storageCache.raw = null;
      return;
    }
    const existing = getCachedStorageState() || {};
    const merged = { ...existing, ...state };
    writeCachedStorageState(merged);
    state = merged;
  } catch (e) {
    console.error("Failed to save state (index.html)", e);
    // last-ditch: write the in-memory snapshot
    try {
      writeCachedStorageState(state);
    } catch (e2) {
      console.error("Last-ditch save failed (index.html)", e2);
    }
  }
}



function resetAll(){
  const msg = [
    'This will erase ALL TaskPoints data stored on this device:',
    '- Tasks',
    '- Completions / log history',
    '- Habits & their history',
    '- Flex actions',
    '- Players / Game data',
    '',
    'This cannot be undone. Continue?'
  ].join('\n');

  if (!confirm(msg)) return;

  try{
    window.TaskPointsCore?.flushPendingSaves?.();
    // Clear local storage for TaskPoints
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(PROJECTS_STORAGE_KEY);
    storageCache.raw = null;
    storageCache.parsed = null;
  }catch(e){
    console.error('Failed to clear TaskPoints storage', e);
  }

  // Reset in-memory state so the UI updates immediately
  state = {
    tasks:        [],
    completions:  [],
    players:      [],
    habits:       [],
    flexActions:  [],
    gameHistory:  [],
    matchups:     [],
    schedule:     [],
    projects:     [],
    habitTagColors: {},
    scoringSettings: window.TaskPointsCore?.normalizeScoringSettings
      ? TaskPointsCore.normalizeScoringSettings({})
      : {}
  };

  // Re-render everything so the page doesn't look broken
  try { scheduleRender(renderAll); }           catch(e){ console.error('renderAll after reset:', e); }
  try { renderHabits(); }        catch(e){ console.error('renderHabits after reset:', e); }
  try { renderVices(); }         catch(e){ console.error('renderVices after reset:', e); }
  try { renderFlexActions(); }   catch(e){ console.error('renderFlexActions after reset:', e); }
  try { renderHabitWeekLabels(); } catch(e){ console.error('renderHabitWeekLabels after reset:', e); }
  try { renderViceWeekLabels(); }  catch(e){ console.error('renderViceWeekLabels after reset:', e); }
}


function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); x.setHours(0,0,0,0); return x; }
function dayDiff(fromKey,toKey){
  if(!fromKey || !toKey) return 0;
  const from = new Date(fromKey + 'T00:00:00');
  const to = new Date(toKey + 'T00:00:00');
  const ms = to - from;
  if (!Number.isFinite(ms) || ms <= 0) return 0;
  return Math.round(ms / 86400000);
}
function trackDueDatePush(task, oldDueISO, newDueISO){
  if(!task) return;
  if (!task.originalDueDateISO && (newDueISO || oldDueISO)) {
    task.originalDueDateISO = newDueISO || oldDueISO || null;
  }
  if(!oldDueISO || !newDueISO) return;
  const delta = dayDiff(oldDueISO, newDueISO);
  if(delta>0){
    const current = Number(task.postponedDays) || 0;
    task.postponedDays = current + delta;
  }
}
function computeNextDueDate(task){
  const rec = task.recurrence || {};
  const mode = rec.mode || 'none';
  if (mode === 'none') return null;

  const baseKey = task.dueDateISO || todayKey();
  const base = new Date(baseKey + 'T00:00:00');

  let next = null;

  if (mode === 'daily') {
    next = addDays(base, 1);
  } else if (mode === 'everyWeekday') {
    next = addDays(base, 1);
    let d = next.getDay(); // 0 Sun, 6 Sat
    if (d === 6) next = addDays(next, 2);     // Sat -> Mon
    else if (d === 0) next = addDays(next, 1); // Sun -> Mon
  } else if (mode === 'weekly') {
    next = addDays(base, 7);
  } else if (mode === 'monthly') {
    next = new Date(base);
    next.setMonth(next.getMonth() + 1);
    next.setHours(0,0,0,0);
  } else if (mode === 'yearly') {
    next = new Date(base);
    next.setFullYear(next.getFullYear() + 1);
    next.setHours(0,0,0,0);
  } else if (mode === 'custom') {
    const count = Number.isFinite(rec.customCount) && rec.customCount > 0 ? rec.customCount : 1;
    const unit  = rec.customUnit || 'day';
    if (unit === 'day') {
      next = addDays(base, count);
    } else if (unit === 'week') {
      next = addDays(base, count * 7);
    } else if (unit === 'month') {
      next = new Date(base);
      next.setMonth(next.getMonth() + count);
      next.setHours(0,0,0,0);
    } else if (unit === 'year') {
      next = new Date(base);
      next.setFullYear(next.getFullYear() + count);
      next.setHours(0,0,0,0);
    }
  }

  if (!next) {
    next = addDays(base, 1);
  }

  return next ? dateKey(next) : null;
}

function startOfWeek(d){ const x=new Date(d); x.setHours(0,0,0,0); const day=(x.getDay()+6)%7; x.setDate(x.getDate()-day); return x; }
function weekDays(baseDate){
  const start=startOfWeek(baseDate);
  const days=[];
  for(let i=0;i<7;i++){
    const d=addDays(start,i);
    days.push({date:d, key:dateKey(d), label:d.toLocaleDateString(undefined,{weekday:'short'})});
  }
  return days;
}
function computeHabitStreak(h){
  if (!h || !Array.isArray(h.doneKeys) || h.doneKeys.length === 0) return 0;

  // Use fromKey so "YYYY-MM-DD" is parsed the same way everywhere else
  const dates = h.doneKeys
    .map(k => fromKey(k))
    .filter(d => d && !isNaN(d))
    .sort((a, b) => b - a); // newest ‚Üí oldest

  if (!dates.length) return 0;

  // Normalize "today"
  const today = new Date();
  today.setHours(0,0,0,0);

  const mostRecent = new Date(dates[0].getTime());
  mostRecent.setHours(0,0,0,0);

  const diffToToday = Math.round((today - mostRecent) / 86400000);
  if (diffToToday > 0) {
    // Last completion wasn't today ‚Üí streak broken
    return 0;
  }

  // Count backwards through consecutive days
  let streak = 1;
  let prev = mostRecent;

  for (let i = 1; i < dates.length; i++) {
    const d = new Date(dates[i].getTime());
    d.setHours(0,0,0,0);

    const diffDays = Math.round((prev - d) / 86400000);
    if (diffDays === 1) {
      streak++;
      prev = d;
    } else {
      break;
    }
  }

  return streak;
}

function computeHabitCompletion(h){
  if (!h) return 0;

  const doneKeys = Array.isArray(h.doneKeys) ? h.doneKeys : [];

  // Normalize "today"
  const today = new Date();
  today.setHours(0,0,0,0);

  // Figure out when this habit/vice "started"
  let start = null;

  // Prefer createdAtISO if present
  if (h.createdAtISO) {
    const d = new Date(h.createdAtISO);
    if (!isNaN(d)) {
      d.setHours(0,0,0,0);
      start = d;
    }
  }

  // Fallback: earliest doneKey
  if (!start && doneKeys.length) {
    const dates = doneKeys
      .map(k => fromKey(k))
      .filter(d => d && !isNaN(d))
      .sort((a, b) => a - b); // oldest ‚Üí newest

    if (dates.length) {
      const d0 = new Date(dates[0].getTime());
      d0.setHours(0,0,0,0);
      start = d0;
    }
  }

  // If we *still* don't have a start, treat as 0% for now
  if (!start) return 0;
  if (start > today) start = today;

  const totalDays = Math.max(
    1,
    Math.round((today - start) / 86400000) + 1
  );

  // Count how many days it was actually marked done
  const doneCount = doneKeys.filter(k => {
    const d = fromKey(k);
    if (!d || isNaN(d)) return false;
    d.setHours(0,0,0,0);
    return d >= start && d <= today;
  }).length;

  const pct = Math.round((doneCount / totalDays) * 100);
  return pct;
}


/* ---------- DATE HELPERS ---------- */
function todayKey(){
  const d = new Date();
  d.setHours(0,0,0,0);
  return dateKey(d);
}

function getGameDayKey(now = new Date()){
  const dt = new Date(now);
  dt.setHours(0,0,0,0);
  return dateKey(dt);
}

function dateKey(d){
  // Accept either a Date or something parseable
  if (!(d instanceof Date)) d = new Date(d);
  if (!d || isNaN(d.getTime())) return 'invalid';
  const y  = d.getFullYear();
  const m  = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${dd}`;
}

function fromKey(k){
  if (!k || typeof k !== 'string') return new Date(NaN);
  const parts = k.split('-');
  if (parts.length < 3) return new Date(NaN);
  const [yStr,mStr,dStr] = parts;
  const y = parseInt(yStr,10);
  const m = parseInt(mStr,10);
  const d = parseInt(dStr,10);
  if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) {
    return new Date(NaN);
  }
  const dt = new Date(y, m-1, d);
  dt.setHours(0,0,0,0);
  return dt;
}

function niceDate(d){
  if (!(d instanceof Date)) d = new Date(d);
  if (!d || isNaN(d.getTime())) return 'Invalid date';
  return d.toLocaleDateString(undefined,{
    year:'numeric',
    month:'short',
    day:'numeric'
  });
}

function aggregateCompletionsByDate(completions){
  if (window.TaskPointsCore?.aggregateCompletionsByDate) {
    return TaskPointsCore.aggregateCompletionsByDate(completions || [], state);
  }
  const dailyTotals   = {};
  const weeklyTotals  = {};
  const monthlyTotals = {};

  if (!Array.isArray(completions)) return { dailyTotals, weeklyTotals, monthlyTotals };

  completions.forEach(c => {
    if (!c || !c.completedAtISO) return;

    const d = new Date(c.completedAtISO);
    if (!d || isNaN(d.getTime())) {
      // Ignore bad/legacy entries instead of crashing the page
      return;
    }

    const dk = dateKey(d);
    const wk = isoWeekKey(d);
    const mk = monthKey(d);

    const pts = c.points || 0;

    dailyTotals[dk]   = (dailyTotals[dk]   || 0) + pts;
    weeklyTotals[wk]  = (weeklyTotals[wk]  || 0) + pts;
    monthlyTotals[mk] = (monthlyTotals[mk] || 0) + pts;
  });

  return { dailyTotals, weeklyTotals, monthlyTotals };
}

function computeInertia(dailyTotals, todayK){
  if (window.TaskPointsCore?.computeInertia) {
    return TaskPointsCore.computeInertia(dailyTotals, todayK, state);
  }
  const today = fromKey(todayK);
  if (!today || isNaN(today.getTime())) return { inertia: 0, average: 0 };

  const keys = Array.from(new Set([...Object.keys(dailyTotals), todayK]))
    .filter(k => {
      const d = fromKey(k);
      return d && !isNaN(d.getTime());
    })
    .sort((a, b) => fromKey(a) - fromKey(b));

  const inertiaMap = new Map();
  const totalsWithInertia = new Map();

  keys.forEach(k => {
    const current = fromKey(k);
    if (!current || isNaN(current.getTime())) return;

    let sum = 0;
    let count = 0;

    for (let i = 1; i <= 7; i++) {
      const d = new Date(current);
      d.setDate(current.getDate() - i);
      const key = dateKey(d);
      const total = totalsWithInertia.get(key);
      if (Number.isFinite(total)) {
        sum += total;
        count++;
      }
    }

    const average = count ? sum / count : 0;
    const inertia = count ? average * 0.25 : 0;

    inertiaMap.set(k, { inertia, average });
    const base = Number(dailyTotals[k]) || 0;
    totalsWithInertia.set(k, base + inertia);
  });

  return inertiaMap.get(todayK) || { inertia: 0, average: 0 };
}

function deriveTodayWithInertia(dailyTotals, todayK){
  if (window.TaskPointsCore?.deriveTodayWithInertia) {
    return TaskPointsCore.deriveTodayWithInertia(dailyTotals, todayK, state);
  }
  const { inertia, average } = computeInertia(dailyTotals, todayK);
  const todayBase = Number(dailyTotals[todayK]) || 0;
  const todayPoints = Math.round((todayBase + inertia) * 10) / 10;

  return { todayPoints, inertia, average, base: todayBase };
}

function renderTodayPointsSummary(todayPoints, inertia, inertiaAvg){
  const todayPointsEl = $('todayPoints');
  if (todayPointsEl) {
    todayPointsEl.textContent = todayPoints.toLocaleString(undefined, {
      maximumFractionDigits: 1,
    });
  }

  const inertiaValueEl = $('inertiaValue');
  if (inertiaValueEl) inertiaValueEl.textContent = (Number.isFinite(inertia) ? inertia : 0).toFixed(1);

  const inertiaAvgEl = $('inertiaAverage');
  if (inertiaAvgEl) {
    const inertiaDays = window.TaskPointsCore?.getScoringSettings
      ? TaskPointsCore.getScoringSettings(state).inertia?.windowDays
      : 7;
    inertiaAvgEl.textContent = `${inertiaDays || 7}-day avg: ${(Number.isFinite(inertiaAvg) ? inertiaAvg : 0).toFixed(1)}`;
  }
}

function todaysPointsTotal(){
  const todayK = todayKey();
  const { dailyTotals } = getDerived().agg;
  const { todayPoints } = deriveTodayWithInertia(dailyTotals, todayK);
  return todayPoints;
}

function startOpponentDripTicker(){
  function tick(){
    const todayK = todayKey();
    const matchupKey = getGameDayKey(new Date());
    const { dailyTotals } = getDerived().agg;

    const { todayPoints, inertia, average } = deriveTodayWithInertia(dailyTotals, todayK);
    const { todayPoints: matchupPoints } = deriveTodayWithInertia(dailyTotals, matchupKey);

    renderTodayPointsSummary(todayPoints, inertia, average);

    if (typeof window.renderTodaysMatchup === 'function') {
      window.renderTodaysMatchup(matchupKey, matchupPoints);
    }
  }

  tick();
  setInterval(tick, 45000);
  document.addEventListener('visibilitychange', () => { if (!document.hidden) tick(); });
}

function monthKey(d){
  if (!(d instanceof Date)) d = new Date(d);
  if (!d || isNaN(d.getTime())) return 'invalid-month';
  const y  = d.getFullYear();
  const m  = String(d.getMonth()+1).padStart(2,'0');
  return `${y}-${m}`;
}

function formatMonthKey(k){
  const parts = (k || '').split('-');
  if (parts.length < 2) return 'Invalid month';
  const [yStr,mStr] = parts;
  const y = parseInt(yStr,10);
  const m = parseInt(mStr,10);
  if (!Number.isFinite(y) || !Number.isFinite(m)) return 'Invalid month';
  const dt = new Date(y, m-1, 1);
  if (isNaN(dt.getTime())) return 'Invalid month';
  return dt.toLocaleString(undefined,{month:'long',year:'numeric'});
}

function isoWeekKey(d){
  if (!(d instanceof Date)) d = new Date(d);
  if (!d || isNaN(d.getTime())) return 'invalid-week';

  const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  const dayNum = date.getUTCDay() || 7;
  date.setUTCDate(date.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(date.getUTCFullYear(),0,1));
  const weekNo = Math.ceil(((date - yearStart) / 86400000 + 1) / 7);
  return `${date.getUTCFullYear()}-W${String(weekNo).padStart(2,'0')}`;
}

function isoWeekRange(weekKey){
  const [yStr, wStr] = weekKey.split('-W');
  const y = parseInt(yStr, 10);
  const w = parseInt(wStr, 10);

  // Build a local date that falls in the correct ISO week
  const simple = new Date(y, 0, 1 + (w - 1) * 7); // local time
  let dow = simple.getDay(); // 0 = Sun, 1 = Mon, ... 6 = Sat
  if (dow === 0) dow = 7;    // treat Sunday as 7

  // Start of week = Monday
  const start = new Date(simple);
  start.setDate(simple.getDate() + 1 - dow);

  // End of week = Sunday
  const end = new Date(start);
  end.setDate(start.getDate() + 6);

  return { start, end };
}

function renderStats(){
  const derived = getDerived();

  const lifetime = derived.lifetimePoints;
  const lifetimeEl = $('lifetimePoints');
  if (lifetimeEl) lifetimeEl.textContent = String(lifetime);

  const { dailyTotals, weeklyTotals, monthlyTotals } = derived.agg;


  const dKeys = Object.keys(dailyTotals);

  const dAvg = dKeys.length
    ? (dKeys.reduce((s, k) => s + dailyTotals[k], 0) / dKeys.length).toFixed(1)
    : "0.0";

  const dailyAvgEl = $('dailyAvg');
  if (dailyAvgEl) {
    dailyAvgEl.textContent = dAvg.toLocaleString();
  }


  // Draw daily trend line
  drawDailyTrend(dailyTotals);

  // Today / this week / this month keys
  const today = new Date();
  today.setHours(0,0,0,0);

  const todayK    = dateKey(today);
  const thisWeekK = isoWeekKey(today);
  const thisMonthK= monthKey(today);
  const matchupKey = getGameDayKey(today);

  const { todayPoints, inertia: inertiaPts, average: inertiaAvg } = deriveTodayWithInertia(dailyTotals, todayK);
  const { todayPoints: matchupPoints } = deriveTodayWithInertia(dailyTotals, matchupKey);

  // Today's points bubble
  renderTodayPointsSummary(todayPoints, inertiaPts, inertiaAvg);

  renderTodaysMatchup(matchupKey, matchupPoints);
  renderYesterdaysResult(dailyTotals);

  // Today's breakdown bar ‚Äì wrapped in try/catch so it can't kill stats
  try {
    const todayList = derived.byDay.get(todayK) || [];
    updateTodayBreakdown(todayList, todayK, inertiaPts);
  } catch (e) {
    console.error('updateTodayBreakdown error', e);
  }

  // ----- LEADERBOARDS -----
  function fillBoard(ulId, entries, labelFn){
    const ul = $(ulId);
    if (!ul) return;

    ul.innerHTML = '';
    if (!entries.length) {
      ul.innerHTML = '<li class="muted">No data yet.</li>';
      return;
    }

    entries.slice(0, 10).forEach((row, i) => {
      const li = document.createElement('li');

      // Store the key on the <li> so we can highlight the current one later
      li.dataset.key = row.key;
      li.className = 'flex items-center justify-between';

      const formattedTotal = Number(row.total).toLocaleString(undefined, {
        maximumFractionDigits: 1,
      });

      li.innerHTML = `
        <span>${i+1}. ${labelFn(row)}</span>
        <span class="font-semibold">${formattedTotal} pts</span>
      `;
      ul.appendChild(li);
    });
  }

const dailyTotalsWithInertia =
  window.TaskPointsCore?.computeDailyTotalsWithInertia
    ? TaskPointsCore.computeDailyTotalsWithInertia(dailyTotals, state)
    : Object.fromEntries(
        Object.entries(dailyTotals).map(([k, v]) => {
          const { inertia } = computeInertia(dailyTotals, k);
          const inertiaVal = Number.isFinite(inertia) ? inertia : 0;
          return [k, v + inertiaVal];
        })
      );


  const weeklyTotalsWithInertia = {};
  const monthlyTotalsWithInertia = {};

  Object.entries(dailyTotalsWithInertia).forEach(([k, total]) => {
    const d = fromKey(k);
    if (!d || isNaN(d.getTime())) return;

    const wk = isoWeekKey(d);
    const mk = monthKey(d);

    weeklyTotalsWithInertia[wk]  = (weeklyTotalsWithInertia[wk]  || 0) + total;
    monthlyTotalsWithInertia[mk] = (monthlyTotalsWithInertia[mk] || 0) + total;
  });

  const bestDays = Object.entries(dailyTotalsWithInertia)
    .map(([k, v]) => ({ key: k, total: v }))
    .sort((a, b) => b.total - a.total);

  const bestWeeks = Object.entries(weeklyTotalsWithInertia)
    .map(([k, v]) => ({ key: k, total: v, ...isoWeekRange(k) }))
    .sort((a, b) => b.total - a.total);

  const bestMonths = Object.entries(monthlyTotalsWithInertia)
    .map(([k, v]) => ({ key: k, total: v }))
    .sort((a, b) => b.total - a.total);

  // Labels with NO "(Today / This Week / This Month)" text
  fillBoard('dailyBoard', bestDays, r =>
    niceDate(fromKey(r.key))
  );

  fillBoard('weeklyBoard', bestWeeks, r =>
    `${niceDate(r.start)} ‚Äì ${niceDate(r.end)}`
  );

  fillBoard('monthlyBoard', bestMonths, r =>
    formatMonthKey(r.key)
  );

  // Highlight current day/week/month in orange if they appear
  [
    ['dailyBoard', todayK],
    ['weeklyBoard', thisWeekK],
    ['monthlyBoard', thisMonthK],
  ].forEach(([ulId, currentKey]) => {
    const ul = $(ulId);
    if (!ul) return;

    ul.querySelectorAll('li').forEach(li => {
      if (li.dataset.key === currentKey) {
        li.classList.add('leaderboard-current');
      }
    });
  });


function renderTodaysMatchup(todayKeyStr, yourScore){
  const oppNameEl = $('matchupOpponent');
  const oppScoreEl= $('matchupOpponentScore');
  const yourScoreEl = $('matchupYourScore');
  const diffEl    = $('matchupDiff');
  const diffValueEl = $('matchupDiffValue');
  const oppRecordEl = $('matchupOpponentRecord');
  const yourRecordEl = $('matchupYourRecord');
  const yourNameEl = $('matchupYourName');
  const yourAvgEl = $('matchupYourAverages');
  const oppAvgEl = $('matchupOpponentAverages');

  if (!oppNameEl || !oppScoreEl || !yourScoreEl || !diffEl || !diffValueEl || !oppRecordEl || !yourRecordEl) return;

  if (yourNameEl) yourNameEl.textContent = 'You';
  const youAverages = computeYouDailyAverages();
  if (yourAvgEl) {
    const youAvgVal = youAverages.hasData ? youAverages.dailyAvg : null;
    const youPpdVal = youAverages.hasData ? youAverages.ppd : null;
    yourAvgEl.textContent = formatAverageLine(youAvgVal, youPpdVal);
  }
  if (oppAvgEl) oppAvgEl.textContent = formatAverageLine(null, null);

  const setOpponentAverages = (playerId) => {
    if (!oppAvgEl) return;
    const oppAverages = computePlayerDailyAverages(playerId);
    const avgVal = oppAverages.hasData ? oppAverages.dailyAvg : null;
    const ppdVal = oppAverages.hasData ? oppAverages.ppd : null;
    oppAvgEl.textContent = formatAverageLine(avgVal, ppdVal);
  };

  const matchups = Array.isArray(state.matchups) ? state.matchups : [];
  const matchupDateKey = (m) => {
    if (!m) return '';
    if (m.date) return m.date;
    if (m.dateKey) return m.dateKey;
    if (m.dateISO) return dateKey(m.dateISO);
    return '';
  };
  const matchup = matchups.find(m => m && matchupDateKey(m) === todayKeyStr && (m.playerAId === 'YOU' || m.playerBId === 'YOU'));

  if (!matchup) {
    diffEl.textContent = 'No matchup today';
    diffValueEl.textContent = '‚Äî';
    oppScoreEl.textContent = '‚Äî';
    yourScoreEl.textContent = '‚Äî';
    oppRecordEl.textContent = 'Record: ‚Äî';
    yourRecordEl.textContent = `Record: ${getYourRecordText()}`;
    oppNameEl.textContent = '‚Äî';
    setOpponentAverages(null);
    return;
  }

  const youAreA = matchup.playerAId === 'YOU';
  const oppId = youAreA ? matchup.playerBId : matchup.playerAId;
  const oppScoreRaw = youAreA ? matchup.scoreB : matchup.scoreA;
  const yourScoreSaved = youAreA ? matchup.scoreA : matchup.scoreB;

  const oppScoreNum = Number(oppScoreRaw);
  const safeOppScore = Number.isFinite(oppScoreNum) ? oppScoreNum : 0;
  const safeYourScore = Number.isFinite(yourScore)
    ? yourScore
    : (Number.isFinite(yourScoreSaved) ? yourScoreSaved : 0);

  const visibleOppScore = oppId
    ? visibleOpponentScoreForMatchup(todayKeyStr, oppId, safeOppScore)
    : safeOppScore;

  oppNameEl.textContent = getPlayerNameById(oppId);
  oppScoreEl.textContent = visibleOppScore.toFixed(1);
  yourScoreEl.textContent = safeYourScore.toFixed(1);
  oppRecordEl.textContent = `Record: ${getPlayerRecordText(oppId)}`;
  yourRecordEl.textContent = `Record: ${getYourRecordText()}`;
  setOpponentAverages(oppId);

  diffEl.className = 'muted text-xs mt-1';
  const diff = Number((safeYourScore - visibleOppScore).toFixed(1));

  diffValueEl.textContent = `${diff > 0 ? '+' : ''}${diff.toFixed(1)}`;
  diffValueEl.className = 'scoreboard-diff-value';
  diffValueEl.classList.remove('diff-positive', 'diff-negative', 'diff-neutral');

  if (diff > 0) {
    diffEl.textContent = `Winning by ${diff.toFixed(1)} pts`;
    diffValueEl.classList.add('diff-positive');
  } else if (diff < 0) {
    diffEl.textContent = `Losing by ${Math.abs(diff).toFixed(1)} pts`;
    diffValueEl.classList.add('diff-negative');
  } else {
    diffEl.textContent = 'Tied right now';
    diffValueEl.classList.add('diff-neutral');
  }
}

function renderYesterdaysResult(dailyTotals){
  const yourScoreEl = $('yesterdayYourScore');
  const oppNameEl = $('yesterdayOpponent');
  const oppScoreEl = $('yesterdayOpponentScore');
  const resultEl = $('yesterdayResult');

  if (!yourScoreEl || !oppNameEl || !oppScoreEl || !resultEl) return;

  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayKey = getGameDayKey(yesterday);

  const { todayPoints: yourScore } = deriveTodayWithInertia(dailyTotals, yesterdayKey);

  const matchups = Array.isArray(state.matchups) ? state.matchups : [];
  const matchupDateKey = (m) => {
    if (!m) return '';
    if (m.date) return m.date;
    if (m.dateKey) return m.dateKey;
    if (m.dateISO) return dateKey(m.dateISO);
    return '';
  };
  const matchup = matchups.find(m => m && matchupDateKey(m) === yesterdayKey && (m.playerAId === 'YOU' || m.playerBId === 'YOU'));

  if (!matchup) {
    yourScoreEl.textContent = '‚Äî';
    oppNameEl.textContent = 'Opponent';
    oppScoreEl.textContent = '‚Äî';
    resultEl.textContent = '‚Äî';
    return;
  }

  const youAreA = matchup.playerAId === 'YOU';
  const oppId = youAreA ? matchup.playerBId : matchup.playerAId;
  const oppScoreRaw = youAreA ? matchup.scoreB : matchup.scoreA;
  const yourScoreSaved = youAreA ? matchup.scoreA : matchup.scoreB;

  const oppScoreNum = Number(oppScoreRaw);
  const safeOppScore = Number.isFinite(oppScoreNum) ? oppScoreNum : 0;
  const safeYourScore = Number.isFinite(yourScore)
    ? yourScore
    : (Number.isFinite(yourScoreSaved) ? yourScoreSaved : 0);

  const visibleOppScore = oppId
    ? visibleOpponentScoreForMatchup(yesterdayKey, oppId, safeOppScore)
    : safeOppScore;

  oppNameEl.textContent = getPlayerNameById(oppId);
  yourScoreEl.textContent = safeYourScore.toFixed(1);
  oppScoreEl.textContent = visibleOppScore.toFixed(1);

  const diff = Number((safeYourScore - visibleOppScore).toFixed(1));
  resultEl.textContent = diff >= 0 ? 'W' : 'L';
}

function updateTodayBreakdown(completions, todayKey, inertiaPoints = 0){
  const bar       = $('todayBreakdownBar');
  const summaryEl = $('todayBreakdownSummary');
  if (!bar) return;

  const safeCompletions = Array.isArray(completions) ? completions : [];

  // Totals per category (now includes calories)
  const totals = {
    sleep:    0,
    tasks:    0,
    habits:   0,
    vices:    0,
    flex:     0,
    calories: 0,
    inertia:  Number(inertiaPoints) || 0,
  };

  // Collect today's points by category
  safeCompletions.forEach(c => {
    if (!c || !c.completedAtISO) return;

    const pts = getCompletionPoints(c);
    if (!pts) return;

    const titleStr = typeof c.title === 'string' ? c.title : '';

         // Sleep entries: "Sleep Score (...)"
// `c.points` already includes bonus, so just add it once.
if (titleStr.startsWith('Sleep Score (')) {
  totals.sleep += pts;
  return;
}


    // Calories entries
    if (titleStr.startsWith('Calories')) {
      totals.calories += pts;
      return;
    }

    // Habits / Vices / Flux based on source
    if (c.source === 'habit') {
      totals.habits += pts;
      return;
    }
    if (c.source === 'vice') {
      totals.vices += pts;
      return;
    }
    if (c.source === 'flex') {
      totals.flex += pts;
      return;
    }

    // Everything else counts as Tasks
    totals.tasks += pts;
  });

  // Build the bar
  bar.innerHTML = '';

  const totalPts = Object.values(totals).reduce((sum, v) => sum + v, 0);

  if (!totalPts) {
    if (summaryEl) {
      summaryEl.textContent = 'No points yet today.';
    }
    return;
  }

  const segments = [
    { key: 'sleep',    label: 'Sleep',    cls: 'todayBreakdown-sleep'    },
    { key: 'tasks',    label: 'Tasks',    cls: 'todayBreakdown-tasks'    },
    { key: 'habits',   label: 'Habits',   cls: 'todayBreakdown-habits'   },
    { key: 'vices',    label: 'Vices',    cls: 'todayBreakdown-vices'    },
    { key: 'flex',     label: 'Flux',     cls: 'todayBreakdown-flex'     },
    { key: 'calories', label: 'Calories', cls: 'todayBreakdown-calories' },
    { key: 'inertia',  label: 'Inertia',  cls: 'todayBreakdown-inertia'  },
  ];

  const parts = [];

  segments.forEach(({ key, label, cls }) => {
    const val = totals[key];
    if (val <= 0) return;

    const pct = (val / totalPts) * 100;

    const seg = document.createElement('div');
    seg.className = 'todayBreakdown-seg ' + cls;
    seg.style.width = pct + '%';
    bar.appendChild(seg);

    parts.push(`${label} ${val.toFixed(1)}`);
  });

  if (summaryEl) {
    summaryEl.textContent = parts.join(' ¬∑ ');
  }
}


function drawDailyTrend(dailyTotals){
  const canvas = $('dailyTrend');
  if (!canvas || !canvas.getContext) return;

  const ctx = canvas.getContext('2d');

  const width  = canvas.clientWidth  || 320;
  const height = canvas.clientHeight || 80;
  canvas.width  = width;
  canvas.height = height;

  ctx.clearRect(0, 0, width, height);

  let entries = Object.entries(dailyTotals)
    .map(([key, total]) => ({ key, total }))
    .sort((a, b) => a.key.localeCompare(b.key));

// Show full history, but downsample if it's huge (keeps last point)
const MAX_POINTS = 400; // tweak: 200‚Äì800 depending on taste
if (entries.length > MAX_POINTS) {
  const step = Math.ceil(entries.length / MAX_POINTS);
  entries = entries.filter((_, i) => i % step === 0 || i === entries.length - 1);
}

  const n = entries.length;
  if (!n) {
    ctx.strokeStyle = 'rgba(148,163,184,0.3)';
    ctx.beginPath();
    ctx.moveTo(0, height - 4);
    ctx.lineTo(width, height - 4);
    ctx.stroke();
    return;
  }

  const maxVal = Math.max(...entries.map(r => r.total));
  const minVal = Math.min(...entries.map(r => r.total));
  const range  = (maxVal - minVal) || 1;

  const paddingX = 6;
  const paddingY = 6;
  const w = width  - paddingX * 2;
  const h = height - paddingY * 2;

  // Baseline
  ctx.strokeStyle = 'rgba(15,23,42,0.7)';
  ctx.lineWidth   = 1;
  ctx.beginPath();
  ctx.moveTo(paddingX, paddingY + h);
  ctx.lineTo(paddingX + w, paddingY + h);
  ctx.stroke();

  // Line
  ctx.strokeStyle = '#22d3ee';
  ctx.lineWidth   = 2;
  ctx.beginPath();

  entries.forEach((row, i) => {
    const x = paddingX + (n === 1 ? w / 2 : (w * i / (n - 1)));
    const norm = (row.total - minVal) / range;
    const y = paddingY + h - norm * h;

    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });

  ctx.stroke();
}
}

function bumpOneDay(task){
  if (!task.dueDateISO) return;  // nothing to bump
  const d = new Date(task.dueDateISO + 'T00:00:00');
  const bumped = addDays(d, 1);
  const oldDue = task.dueDateISO;
  task.dueDateISO = dateKey(bumped);
  trackDueDatePush(task, oldDue, task.dueDateISO);
}

function labelForDay(d,baseToday){
  const t=dateKey(baseToday), k=dateKey(d);
  if(k===t) return 'Today';
  if(k===dateKey(addDays(baseToday,1))) return 'Tomorrow';
  return d.toLocaleDateString(undefined,{weekday:'long',month:'short',day:'numeric'});
}
function cmpImportance(a,b){ const o={Low:0,Medium:1,High:2,Critical:3}; return (o[a.importance]||0)-(o[b.importance]||0); }

/* ---------- HABITS ---------- */
function renderHabitWeekLabels(){
  const row = $('habitWeekLabels');
  row.innerHTML = '';

  const days = weekDays(new Date());

  // Use the same layout container as the habit day bubbles
  const wrapper = document.createElement('div');
  wrapper.className = 'habitDaysRow';

  days.forEach(d => {
    const cell = document.createElement('div');
    cell.className = 'habitLabelDay';
    cell.textContent = d.label; // "Mon", "Tue", etc.
    wrapper.appendChild(cell);
  });

  row.appendChild(wrapper);
}


function renderViceWeekLabels(){
  const row = $('viceWeekLabels');
  row.innerHTML = '';

  const days = weekDays(new Date());

  // Same layout as vices' day bubbles
  const wrapper = document.createElement('div');
  wrapper.className = 'habitDaysRow';

  days.forEach(d => {
    const cell = document.createElement('div');
    cell.className = 'habitLabelDay';
    cell.textContent = d.label;
    wrapper.appendChild(cell);
  });

  row.appendChild(wrapper);
}

function sortHabitsForMode(habits, sortMode) {
  if (sortMode === 'custom') {
    habits.sort((a,b) => {
      const ao = (typeof a.order === 'number') ? a.order : 0;
      const bo = (typeof b.order === 'number') ? b.order : 0;
      if (ao !== bo) return ao - bo;

      const ac = a.createdAtISO || '';
      const bc = b.createdAtISO || '';
      return ac.localeCompare(bc);
    });
    return habits;
  }

  if (sortMode === 'points') {
    habits.sort((a,b) =>
      (Number(b.pointsPerDay||0) - Number(a.pointsPerDay||0)) ||
      (a.name||'').localeCompare(b.name||'')
    );
    return habits;
  }

  if (sortMode === 'streak') {
    habits.sort((a,b) =>
      (Number(b.__streak||0) - Number(a.__streak||0)) ||
      (Number(b.pointsPerDay||0) - Number(a.pointsPerDay||0)) ||
      (a.name||'').localeCompare(b.name||'')
    );
    return habits;
  }

  if (sortMode === 'completion') {
    habits.sort((a,b) =>
      (Number(b.__completion||0) - Number(a.__completion||0)) ||
      (Number(b.__streak||0) - Number(a.__streak||0)) ||
      (Number(b.pointsPerDay||0) - Number(a.pointsPerDay||0)) ||
      (a.name||'').localeCompare(b.name||'')
    );
  }

  return habits;
}

function buildHabitRenderEntries(habits, sortMode) {
  const tagCounts = new Map();
  habits.forEach(h => {
    const tag = (h.tag || '').trim();
    if (!tag) return;
    tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
  });

  const groupedTags = new Set(
    Array.from(tagCounts.entries())
      .filter(([, count]) => count > 1)
      .map(([tag]) => tag)
  );

  const sorted = sortHabitsForMode(habits.slice(), sortMode);
  const grouped = new Map();
  const groupOrder = [];
  const entries = [];
  const singles = [];

  sorted.forEach(h => {
    const tag = (h.tag || '').trim();
    if (tag && groupedTags.has(tag)) {
      if (!grouped.has(tag)) {
        grouped.set(tag, []);
        groupOrder.push(tag);
        if (sortMode === 'custom') {
          entries.push({ type: 'group', tag, habits: grouped.get(tag) });
        }
      }
      grouped.get(tag).push(h);
      return;
    }

    const entry = { type: 'single', habit: h };
    if (sortMode === 'custom') {
      entries.push(entry);
    } else {
      singles.push(entry);
    }
  });

  if (sortMode === 'custom') {
    return { entries };
  }

  const groupedEntries = groupOrder.map(tag => ({
    type: 'group',
    tag,
    habits: grouped.get(tag)
  }));

  return { entries: [...singles, ...groupedEntries] };
}

function renderHabitRow(h, days, wrap, options = {}) {
  const showMoveButtons = options.showMoveButtons ?? (getHabitSortMode() === 'custom');
  const showTag = options.showTag ?? true;
  const isGrouped = options.isGrouped ?? false;

  h.doneKeys = Array.isArray(h.doneKeys) ? h.doneKeys : [];

  const streak     = Number(h.__streak || 0);
  const completion = Number(h.__completion || 0);

  const row = document.createElement('div');
  row.className = 'habitRow';
  if (!isGrouped) {
    row.classList.add('habitRow--single');
  }

  const daysHtml = days.map(d => {
    const on = h.doneKeys.includes(d.key);
    const status = on ? 'on' : 'off';
    const styleAttr = getHabitBubbleStyleAttr(h.tag, status);
    return `<div class="habitDay ${status}"${styleAttr} data-habit="${h.id}" data-day="${d.key}">
      ${d.date.getDate()}
    </div>`;
  }).join('');

  const daysRowHtml = `<div class="habitDaysRow">${daysHtml}</div>`;

  if (editingHabitId === h.id) {
    const category = h.category || 'habit';
    row.innerHTML = `
      <div class="flex flex-col gap-2 min-w-0">
        <input class="input" data-field="name" value="${escapeHtml(h.name)}">
        <input class="input" data-field="points" type="number" value="${h.pointsPerDay||0}">
        <input class="input" data-field="tag" value="${escapeHtml(h.tag || '')}" placeholder="Tag">
        <select class="input" data-field="category">
          <option value="habit" ${category==='habit'?'selected':''}>Habit</option>
          <option value="vice"  ${category==='vice'?'selected':''}>Vice</option>
        </select>
        <div class="flex gap-2 flex-wrap">
          <button class="btn btn-success" data-act="habit-save">Save</button>
          <button class="btn btn-ghost" data-act="habit-cancel">Cancel</button>
          <button class="btn btn-ghost" data-act="habit-delete">Delete</button>
        </div>
      </div>
      ${daysRowHtml}
    `;

    wrap.appendChild(row);

    row.querySelector('[data-act="habit-save"]').onclick = () => saveHabitEdit(h.id, row);
    row.querySelector('[data-act="habit-cancel"]').onclick = () => { editingHabitId=null; renderHabits(); renderVices(); };
    row.querySelector('[data-act="habit-delete"]').onclick = () => deleteHabit(h.id);
    return;
  }

  const nameHtml = `
    <div class="habitLeft flex items-center gap-2 flex-wrap min-w-0 flex-1 text-xs sm:text-sm">
      <!-- Left side: habit name + points + streak + completion% -->
      <div class="habitName cursor-pointer" title="${escapeHtml(h.name)}" data-act="habit-edit" data-id="${h.id}">
        ${escapeHtml(h.name)}
      </div>
      <div class="tag bg-zinc-200/60 dark:bg-zinc-700/60">
        ${h.pointsPerDay||0} pts
      </div>
      ${showTag && h.tag ? `<div class="tag tag-clear">${escapeHtml(h.tag)}</div>` : ''}
    ${streak > 0 ? `
      <div class="tag streak-pill">
        ${streak}d
      </div>
    ` : ''}
      <div class="tag bg-zinc-200/60 dark:bg-zinc-700/60 text-orange-400">
        ${completion}%
      </div>
    </div>
  `;

  const controlsHtml = `
    <div class="habitControls flex items-center gap-2 flex-wrap text-xs sm:text-sm">
      ${showMoveButtons ? `
        <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
                data-act="habit-up" data-id="${h.id}">‚ñ≤</button>
        <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
                data-act="habit-down" data-id="${h.id}">‚ñº</button>
      ` : ``}
    </div>
  `;

  row.innerHTML = nameHtml + controlsHtml + daysRowHtml;
  wrap.appendChild(row);
}



let habitTapHandlerBound = false;
let viceTapHandlerBound = false;

function renderHabits(){
  const wrap  = $('habitsList');
  const empty = $('habitsEmpty');
  wrap.innerHTML = '';
  const days = weekDays(new Date());

  // Only active habits (NOT vices, NOT retired)
  const sortMode = getHabitSortMode();

  const habits = state.habits
    .filter(h => (h.category || 'habit') !== 'vice')
    .filter(h => !h.retired)
    .slice();

  // Precompute streak + completion once so sorting is stable + fast
  habits.forEach(h => {
    h.doneKeys = Array.isArray(h.doneKeys) ? h.doneKeys : [];
    h.__streak = computeHabitStreak(h);
    h.__completion = computeHabitCompletion(h);
  });

  if(!habits.length){
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');

  const { entries } = buildHabitRenderEntries(habits, sortMode);

  entries.forEach(entry => {
    if (entry.type === 'group') {
      const groupWrap = document.createElement('div');
      groupWrap.className = 'habitGroup';

      const header = document.createElement('div');
      header.className = 'habitGroupHeader';
      header.innerHTML = `
        <div class="habitGroupTitle"${getHabitGroupStyleAttr(entry.tag)}>
          ${escapeHtml(entry.tag)}
        </div>
        <div class="habitGroupControls">
          ${sortMode === 'custom' ? `
            <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
                    data-act="habit-group-up" data-tag="${escapeHtml(entry.tag)}">‚ñ≤</button>
            <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
                    data-act="habit-group-down" data-tag="${escapeHtml(entry.tag)}">‚ñº</button>
          ` : ``}
        </div>
      `;
      groupWrap.appendChild(header);

      const body = document.createElement('div');
      body.className = 'habitGroupBody';
      entry.habits.forEach(h => renderHabitRow(h, days, body, { showMoveButtons: false, showTag: false, isGrouped: true }));
      groupWrap.appendChild(body);
      wrap.appendChild(groupWrap);
      return;
    }

    renderHabitRow(entry.habit, days, wrap, { showMoveButtons: sortMode === 'custom', isGrouped: false });
  });

if (!habitTapHandlerBound) {
  habitTapHandlerBound = true;

  let tap = null; // { id, startX, startY, startBubble, moved }

  wrap.addEventListener('pointerdown', (e) => {
    const bubble = e.target.closest('.habitDay[data-habit][data-day]');
    if (!bubble || !wrap.contains(bubble)) return;

    tap = {
      id: e.pointerId,
      startX: e.clientX,
      startY: e.clientY,
      startBubble: bubble,
      moved: false
    };
  }, { passive: true });

  wrap.addEventListener('pointermove', (e) => {
    if (!tap || e.pointerId !== tap.id) return;

    const dx = Math.abs(e.clientX - tap.startX);
    const dy = Math.abs(e.clientY - tap.startY);

    if (dx > 12 || dy > 12) tap.moved = true; // scroll threshold
  }, { passive: true });

  wrap.addEventListener('pointerup', (e) => {
    const bubble = e.target.closest('.habitDay[data-habit][data-day]');
    if (!bubble || !wrap.contains(bubble)) return;

    // If this pointer became a drag OR ended on a different bubble, ignore.
    if (tap && e.pointerId === tap.id) {
      const moved = tap.moved;
      const sameBubble = (bubble === tap.startBubble);
      tap = null;

      if (moved || !sameBubble) return;
    }

    handleHabitBubbleTap(bubble);
  }, { passive: true });

  wrap.addEventListener('pointercancel', (e) => {
    if (tap && e.pointerId === tap.id) tap = null;
  }, { passive: true });
}
}

function renderVices(){
  const wrap  = $('vicesList');
  const empty = $('vicesEmpty');
  wrap.innerHTML = '';
  const days = weekDays(new Date());

  // Only VICES, non-retired
  const habits = state.habits
    .filter(h => (h.category || 'habit') === 'vice')
    .filter(h => !h.retired)
    .slice()
    .sort((a,b) => {
      const ao = (typeof a.order === 'number') ? a.order : 0;
      const bo = (typeof b.order === 'number') ? b.order : 0;
      if (ao !== bo) return ao - bo;

      const ac = a.createdAtISO || '';
      const bc = b.createdAtISO || '';
      return ac.localeCompare(bc);
    });

  if (!habits.length) {
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');

  habits.forEach(h => {
    h.doneKeys = Array.isArray(h.doneKeys) ? h.doneKeys : [];
    h.failedKeys = Array.isArray(h.failedKeys) ? h.failedKeys : [];
    const streak     = computeHabitStreak(h);
    const completion = computeHabitCompletion(h);
    const row = document.createElement('div');

    row.className = 'habitRow';
    row.classList.add('habitRow--single');

    const daysHtml = days.map(d => {
      const on = h.doneKeys.includes(d.key);
      const failed = h.failedKeys.includes(d.key);
      const statusClass = on ? 'on' : (failed ? 'failed' : 'off');
      const styleAttr = getHabitBubbleStyleAttr(h.tag, statusClass);
      return `<div class="habitDay viceDay ${statusClass}"${styleAttr} data-habit="${h.id}" data-day="${d.key}">

        ${d.date.getDate()}
      </div>`;
    }).join('');

    const daysRowHtml = `<div class="habitDaysRow">${daysHtml}</div>`;

    if (editingHabitId === h.id) {
      // EDIT MODE
      row.innerHTML = `
        <div class="flex flex-col gap-2 min-w-0">
          <input class="input" data-field="name" value="${escapeHtml(h.name)}">
          <input class="input" data-field="points" type="number" value="${h.pointsPerDay||0}">
          <input class="input" data-field="tag" value="${escapeHtml(h.tag || '')}" placeholder="Tag">
          <div class="flex gap-2 flex-wrap">
            <button class="btn btn-success" data-act="habit-save">Save</button>
            <button class="btn btn-ghost" data-act="habit-cancel">Cancel</button>
            <button class="btn btn-ghost" data-act="habit-delete">Delete</button>
          </div>
        </div>
        ${daysRowHtml}
      `;

      wrap.appendChild(row);

      const saveBtn   = row.querySelector('[data-act="habit-save"]');
      const cancelBtn = row.querySelector('[data-act="habit-cancel"]');
      const delBtn    = row.querySelector('[data-act="habit-delete"]');

      saveBtn.onclick   = () => saveHabitEdit(h.id, row);
      cancelBtn.onclick = () => { editingHabitId = null; renderHabits(); renderVices(); };
      delBtn.onclick    = () => deleteHabit(h.id);

    } else {
// NORMAL MODE
const nameHtml = `
  <div class="habitLeft flex items-center gap-2 flex-wrap min-w-0 flex-1 text-xs sm:text-sm">
    <!-- Left side: vice name + points + streak + completion% -->
    <div class="habitName cursor-pointer" title="${escapeHtml(h.name)}" data-act="habit-edit" data-id="${h.id}">
      ${escapeHtml(h.name)}
    </div>
    <div class="tag bg-zinc-200/60 dark:bg-zinc-700/60">
      ${h.pointsPerDay||0} pts
    </div>
    ${h.tag ? `<div class="tag tag-clear">${escapeHtml(h.tag)}</div>` : ''}
  ${streak > 0 ? `
    <div class="tag streak-pill">
      ${streak}d
    </div>
  ` : ''}
    <div class="tag bg-zinc-200/60 dark:bg-zinc-700/60 text-orange-400">
      ${completion}%
    </div>
  </div>
`;


      // Right side: controls only (‚ñ≤/‚ñº)
      const controlsHtml = `
        <div class="habitControls flex items-center gap-2 flex-wrap text-xs sm:text-sm">
          <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
                  data-act="habit-up" data-id="${h.id}">‚ñ≤</button>
          <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
                  data-act="habit-down" data-id="${h.id}">‚ñº</button>
        </div>
      `;

      row.innerHTML = nameHtml + controlsHtml + daysRowHtml;
      wrap.appendChild(row);
    }

  });

  if (!viceTapHandlerBound) {
    viceTapHandlerBound = true;

    let tap = null; // { id, startX, startY, startBubble, moved }

    const getViceBubble = (e) =>
      e.target.closest('.habitDay.viceDay[data-habit][data-day]');

    wrap.addEventListener('pointerdown', (e) => {
      const bubble = getViceBubble(e);
      if (!bubble || !wrap.contains(bubble)) return;

      tap = {
        id: e.pointerId,
        startX: e.clientX,
        startY: e.clientY,
        startBubble: bubble,
        moved: false
      };
    }, { passive: true });

    wrap.addEventListener('pointermove', (e) => {
      if (!tap || e.pointerId !== tap.id) return;

      const dx = Math.abs(e.clientX - tap.startX);
      const dy = Math.abs(e.clientY - tap.startY);

      // if you dragged, it's a scroll, not a tap
      if (dx > 12 || dy > 12) tap.moved = true;
    }, { passive: true });

    wrap.addEventListener('pointerup', (e) => {
      const bubble = getViceBubble(e);
      if (!bubble || !wrap.contains(bubble)) return;

      if (tap && e.pointerId === tap.id) {
        const moved = tap.moved;
        const sameBubble = (bubble === tap.startBubble);
        tap = null;

        if (moved || !sameBubble) return; // ignore scroll / drift
      }

      // vices use the same toggle pipeline as habits (category === 'vice' inside applyHabitDayToggle)
      handleHabitBubbleTap(bubble);
    }, { passive: true });

    wrap.addEventListener('pointercancel', (e) => {
      if (tap && e.pointerId === tap.id) tap = null;
    }, { passive: true });
  }



  // Edit / delete
  wrap.querySelectorAll('[data-act="habit-edit"]').forEach(btn => {
    btn.onclick = () => {
      editingHabitId = btn.getAttribute('data-id');
      renderHabits();
      renderVices();
    };
  });
  wrap.querySelectorAll('[data-act="habit-delete"]').forEach(btn => {
    btn.onclick = () => deleteHabit(btn.getAttribute('data-id'));
  });

  // ‚¨ÜÔ∏è‚¨áÔ∏è NEW: reordering for vices too
  wrap.querySelectorAll('[data-act="habit-up"]').forEach(btn => {
    btn.onclick = () => moveHabit(btn.getAttribute('data-id'), -1);
  });
  wrap.querySelectorAll('[data-act="habit-down"]').forEach(btn => {
    btn.onclick = () => moveHabit(btn.getAttribute('data-id'), +1);
  });
}


function openHabitModal() {
  const modal = $('addHabitModal');
  if (!modal) return;
  modal.classList.remove('hidden');
  modal.classList.add('flex');
  $('habitName')?.focus();
}

function closeHabitModal() {
  const modal = $('addHabitModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.classList.remove('flex');
}

function openViceModal() {
  const modal = $('addViceModal');
  if (!modal) return;
  modal.classList.remove('hidden');
  modal.classList.add('flex');
  $('viceName')?.focus();
}

function closeViceModal() {
  const modal = $('addViceModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.classList.remove('flex');
}

function addHabit(){
  const name = $('habitName')?.value.trim() || '';
  const tag  = $('habitTag')?.value.trim() || '';
  const pts  = Number($('habitPts')?.value)||0;
  if(!name) return alert('Enter a habit name');

  // Find the current max order among non-retired HABITS
  const maxOrder = state.habits
    .filter(x => !x.retired && (x.category || 'habit') === 'habit')
    .reduce((max, x) =>
      (typeof x.order === 'number' && x.order > max) ? x.order : max,
      0
    );

  const h = {
    id: crypto.randomUUID(),
    name,
    pointsPerDay: pts,
    doneKeys: [],
    createdAtISO: new Date().toISOString(),
    category: 'habit',
    tag,
    order: maxOrder + 1
  };


  state.habits.push(h);
  save();
  $('habitName').value=''; $('habitPts').value=''; if ($('habitTag')) $('habitTag').value='';
  closeHabitModal();

  renderHabits();
  renderVices();
  renderStats();
}

function addVice(){
  const name = $('viceName')?.value.trim() || '';
  const tag  = $('viceTag')?.value.trim() || '';
  const pts  = Number($('vicePts')?.value)||0;
  if(!name) return alert('Enter a vice name');

  // Find the current max order among non-retired VICES
  const maxOrder = state.habits
    .filter(x => !x.retired && (x.category || 'habit') === 'vice')
    .reduce((max, x) =>
      (typeof x.order === 'number' && x.order > max) ? x.order : max,
      0
    );

  const h = {
    id: crypto.randomUUID(),
    name,
    pointsPerDay: pts,
    doneKeys: [],
    createdAtISO: new Date().toISOString(),
    category: 'vice',
    tag,
    order: maxOrder + 1
  };


  state.habits.push(h);
  save();
  $('viceName').value=''; $('vicePts').value=''; if ($('viceTag')) $('viceTag').value='';
  closeViceModal();

  renderHabits();
  renderVices();
  renderStats();
}


function saveHabitEdit(id,row){
  const h=state.habits.find(x=>x.id===id); if(!h) return;
  const nameInput=row.querySelector('input[data-field="name"]');
  const ptsInput=row.querySelector('input[data-field="points"]');
  const tagInput=row.querySelector('input[data-field="tag"]');
  const catInput=row.querySelector('[data-field="category"]');

  const oldPoints = h.pointsPerDay || 0;

  h.name = nameInput.value.trim() || h.name;
  h.pointsPerDay = Number(ptsInput.value)||0;
  if (tagInput) h.tag = tagInput.value.trim();
  h.category = catInput ? (catInput.value || 'habit') : (h.category || 'habit');

  // update existing log entries
  if (h.pointsPerDay !== oldPoints) {
    state.completions.forEach(c => {
      if (c.source === 'habit' && c.habitId === id) {
        c.points = h.pointsPerDay;
      }
    });
  }

  editingHabitId=null;
  save(); 
  renderHabits(); 
  renderVices();
  renderStats();
}

function deleteHabit(id){
  if(!confirm('Delete this habit (keeps past log entries)?')) return;
  state.habits = state.habits.filter(x=>x.id!==id);
  if(editingHabitId===id) editingHabitId=null;
  save(); renderHabits(); renderStats(); renderVices();
}
function moveHabit(id, delta){
  const h = state.habits.find(x => x.id === id);
  if (!h) return;
  const category = h.category || 'habit';

  // All active items in the same category (habits or vices)
  const siblings = state.habits
    .filter(x => !x.retired && (x.category || 'habit') === category)
    .slice()
    .sort((a,b) => {
      const ao = (typeof a.order === 'number') ? a.order : 0;
      const bo = (typeof b.order === 'number') ? b.order : 0;
      if (ao !== bo) return ao - bo;
      const ac = a.createdAtISO || '';
      const bc = b.createdAtISO || '';
      return ac.localeCompare(bc);
    });

  if (!siblings.length) return;

  // Normalize orders to 1..N in current visual order
  siblings.forEach((x, idx) => { x.order = idx + 1; });

  const idx = siblings.findIndex(x => x.id === id);
  if (idx === -1) return;

  const newIdx = idx + delta;
  if (newIdx < 0 || newIdx >= siblings.length) return;

  const a = siblings[idx];
  const b = siblings[newIdx];
  const tmp = a.order;
  a.order = b.order;
  b.order = tmp;

  save();
  renderHabits();
  renderVices();
}

function moveHabitGroup(tag, delta) {
  const groupTag = (tag || '').trim();
  if (!groupTag) return;

  const activeHabits = state.habits
    .filter(h => (h.category || 'habit') !== 'vice')
    .filter(h => !h.retired)
    .slice();

  const tagCounts = new Map();
  activeHabits.forEach(h => {
    const habitTag = (h.tag || '').trim();
    if (!habitTag) return;
    tagCounts.set(habitTag, (tagCounts.get(habitTag) || 0) + 1);
  });

  if ((tagCounts.get(groupTag) || 0) < 2) return;

  const groupedTags = new Set(
    Array.from(tagCounts.entries())
      .filter(([, count]) => count > 1)
      .map(([t]) => t)
  );

  const sorted = sortHabitsForMode(activeHabits.slice(), 'custom');
  const blocks = [];
  const groupBlocks = new Map();

  sorted.forEach(h => {
    const habitTag = (h.tag || '').trim();
    if (habitTag && groupedTags.has(habitTag)) {
      if (!groupBlocks.has(habitTag)) {
        const block = { type: 'group', tag: habitTag, habits: [] };
        groupBlocks.set(habitTag, block);
        blocks.push(block);
      }
      groupBlocks.get(habitTag).habits.push(h);
      return;
    }

    blocks.push({ type: 'single', habits: [h] });
  });

  const idx = blocks.findIndex(b => b.type === 'group' && b.tag === groupTag);
  if (idx === -1) return;

  const newIdx = idx + delta;
  if (newIdx < 0 || newIdx >= blocks.length) return;

  const nextBlocks = blocks.slice();
  const [moving] = nextBlocks.splice(idx, 1);
  nextBlocks.splice(newIdx, 0, moving);

  const reordered = [];
  nextBlocks.forEach(block => {
    const blockHabits = sortHabitsForMode(block.habits.slice(), 'custom');
    reordered.push(...blockHabits);
  });

  reordered.forEach((h, index) => {
    h.order = index + 1;
  });

  save();
  renderHabits();
  renderVices();
}

function toggleHabitDay(habitId, dayKey){
  const h = state.habits.find(x => x.id === habitId);
  if (!h || h.retired) return;
  applyHabitDayToggle(h, dayKey);
  save();
  renderHabits();
  renderStats();
  renderVices();
}

let habitSaveDebounceId = null;
let habitRerenderDebounceId = null;
let habitLastTapPerfStart = null;

function deferAfterPaint(fn) {
  requestAnimationFrame(() => {
    if (window.requestIdleCallback) {
      requestIdleCallback(fn, { timeout: 500 });
    } else {
      setTimeout(fn, 0);
    }
  });
}

function scheduleHabitSave() {
  if (habitSaveDebounceId) clearTimeout(habitSaveDebounceId);
  const perfStart = window.TP_DEBUG_PERF ? habitLastTapPerfStart : null;
  habitSaveDebounceId = setTimeout(() => {
    habitSaveDebounceId = null;
    deferAfterPaint(() => {
      if (window.TaskPointsCore?.queueStateSnapshot) {
        TaskPointsCore.queueStateSnapshot(state);
      } else {
        save();
      }
      if (window.TP_DEBUG_PERF && perfStart !== null) {
        console.log(`[TP_PERF] tap->save ${Math.round(performance.now() - perfStart)}ms`);
      }
    });
  }, 200);
}

function scheduleHabitRerender() {
  if (habitRerenderDebounceId) clearTimeout(habitRerenderDebounceId);
  const perfStart = window.TP_DEBUG_PERF ? habitLastTapPerfStart : null;
  habitRerenderDebounceId = setTimeout(() => {
    habitRerenderDebounceId = null;
    deferAfterPaint(() => {
      if (window.TP_DEBUG_PERF && perfStart !== null) {
        console.log(`[TP_PERF] tap->rerender ${Math.round(performance.now() - perfStart)}ms`);
      }
      renderHabits();
      renderStats();
      renderVices();
    });
  }, 150);
}

function applyHabitBubbleStyle(el, habit, statusClass) {
  const styleAttr = getHabitBubbleStyleAttr(habit.tag, statusClass);
  if (styleAttr) {
    const styleValue = styleAttr.replace(/^ style="/, '').replace(/"$/, '');
    el.setAttribute('style', styleValue);
  } else {
    el.removeAttribute('style');
  }
}

function applyHabitDayToggle(h, dayKey) {
  const habitId = h.id;
  const category = (h.category || 'habit');   // 'habit' or 'vice'
  const source   = category === 'vice' ? 'vice' : 'habit';
  const tagLabel = category === 'vice' ? 'Vice' : 'Habit';

  h.doneKeys   = Array.isArray(h.doneKeys)   ? h.doneKeys   : [];
  h.failedKeys = Array.isArray(h.failedKeys) ? h.failedKeys : [];

  const removeCompletionForDay = () => {
    const mIdx = state.completions.findIndex(c =>
      (c.source === 'habit' || c.source === 'vice') &&
      c.habitId === habitId &&
      c.dayKey === dayKey
    );
if (mIdx !== -1) {
  state.completions.splice(mIdx, 1);
  markCompletionsDirty();
}
  };

  if (category === 'vice') {
    const doneIdx   = h.doneKeys.indexOf(dayKey);
    const failedIdx = h.failedKeys.indexOf(dayKey);

    if (doneIdx === -1 && failedIdx === -1) {
      // neutral ‚Üí completed (award points)
      h.doneKeys.push(dayKey);
      const iso = new Date(fromKey(dayKey).getTime() + 12 * 3600 * 1000).toISOString();
      addCompletion({
        id: crypto.randomUUID(),
        taskId: `habit:${habitId}:${dayKey}`,
        title: `[${tagLabel}] ${h.name} (${dayKey})`,
        points: h.pointsPerDay || 0,
        completedAtISO: iso,
        source,
        habitId: habitId,
        dayKey: dayKey
      });
    } else if (doneIdx !== -1) {
      // completed ‚Üí failed (remove points, mark failed)
      h.doneKeys.splice(doneIdx, 1);
      removeCompletionForDay();
      if (failedIdx === -1) h.failedKeys.push(dayKey);
    } else {
      // failed ‚Üí neutral
      h.failedKeys.splice(failedIdx, 1);
      removeCompletionForDay();
    }
  } else {
    // Habits keep simple toggle behavior
    const idx = h.doneKeys.indexOf(dayKey);
    if (idx === -1) {
      h.doneKeys.push(dayKey);
      const iso = new Date(fromKey(dayKey).getTime() + 12 * 3600 * 1000).toISOString();
      addCompletion({
        id: crypto.randomUUID(),
        taskId: `habit:${habitId}:${dayKey}`,
        title: `[${tagLabel}] ${h.name} (${dayKey})`,
        points: h.pointsPerDay || 0,
        completedAtISO: iso,
        source,
        habitId: habitId,
        dayKey: dayKey
      });
    } else {
      h.doneKeys.splice(idx, 1);
      removeCompletionForDay();
    }

    // If a failed marker snuck in (shouldn't happen for habits), clear it
    const failedIdx = h.failedKeys.indexOf(dayKey);
    if (failedIdx !== -1) h.failedKeys.splice(failedIdx, 1);
  }

  if (h.doneKeys.includes(dayKey)) return 'on';
  if (h.failedKeys.includes(dayKey)) return 'failed';
  return 'off';
}

function handleHabitBubbleTap(bubbleEl) {
  const habitId = bubbleEl.getAttribute('data-habit');
  const dayKey = bubbleEl.getAttribute('data-day');
  if (!habitId || !dayKey) return;

  const h = state.habits.find(x => x.id === habitId);
  if (!h || h.retired) return;

  const perfStart = performance.now();
  habitLastTapPerfStart = perfStart;
  if (window.TP_DEBUG_PERF) {
    console.count('habitTap');
  }

  const statusClass = applyHabitDayToggle(h, dayKey);
  bubbleEl.classList.remove('on', 'off', 'failed');
  bubbleEl.classList.add(statusClass);
  applyHabitBubbleStyle(bubbleEl, h, statusClass);

  if (window.TP_DEBUG_PERF) {
    console.log('[TP_PERF] habitToggle', {
      habitId,
      dayKey,
      statusClass,
      doneKeys: Array.isArray(h.doneKeys) ? [...h.doneKeys] : [],
      failedKeys: Array.isArray(h.failedKeys) ? [...h.failedKeys] : []
    });
    console.log(`[TP_PERF] tap->bubble ${Math.round(performance.now() - perfStart)}ms`);
  }

  scheduleHabitSave();
  scheduleHabitRerender();
}



/* ---------- FLEX ACTIONS ---------- */
function renderFlexActions(){
  const list = $('flexList'), empty = $('flexEmpty');
  if (!list || !empty) return;
  list.innerHTML = '';

  const items = (Array.isArray(state.flexActions) ? state.flexActions : []).filter(f => !f.retired);
  const todayKeyStr = dateKey(new Date());
  const flexUseCounts = new Map();
  let appliedAnimation = false;
  const completions = Array.isArray(state.completions) ? state.completions : [];
  for (const entry of completions) {
    if (!entry?.flexId) continue;
    if (dateKey(entry.completedAtISO) !== todayKeyStr) continue;
    flexUseCounts.set(entry.flexId, (flexUseCounts.get(entry.flexId) || 0) + 1);
  }

  if (!items.length) {
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');

  items.forEach(f => {
    const row = document.createElement('div');
    row.className = 'glass flex flex-col sm:flex-row sm:items-start justify-between gap-3 flex-action-row';
    if (editingFlexId === f.id) {
      row.classList.add('flex-action-row--edit');
    }

    if (editingFlexId === f.id) {
      // üîß EDIT MODE
      row.innerHTML = `
        <div class="flex-1 min-w-0">
          <label class="text-xs muted block mb-1">Flex action</label>
          <input class="input w-full mb-2" data-field="name"
                 value="${escapeHtml(f.name || '')}">
          <label class="text-xs muted block mb-1">Points per use</label>
          <input class="input w-28" data-field="points" type="number" step="any"
                 value="${f.points || 0}">
        </div>
        <div class="flex gap-2 flex-wrap">
          <button class="btn btn-success btn-task" data-act="flex-save">Save</button>
          <button class="btn btn-ghost btn-task" data-act="flex-cancel">Cancel</button>
          <button class="btn btn-ghost btn-task" data-act="flex-retire" data-id="${f.id}">Retire</button>
          <button class="btn btn-delete btn-task" data-act="flex-del" data-id="${f.id}">Delete</button>
        </div>
      `;
      list.appendChild(row);

      const saveBtn   = row.querySelector('[data-act="flex-save"]');
      const cancelBtn = row.querySelector('[data-act="flex-cancel"]');
      const delBtn    = row.querySelector('[data-act="flex-del"]');

      saveBtn.onclick   = () => saveFlexEdit(f.id, row);
      cancelBtn.onclick = () => { editingFlexId = null; renderFlexActions(); };
      delBtn.onclick    = () => deleteFlexAction(f.id);

    } else {
      // üìÑ NORMAL MODE
      const usageCount = flexUseCounts.get(f.id) || 0;
      const shouldAnimate = lastFlexCompletion
        && lastFlexCompletion.id === f.id
        && (Date.now() - lastFlexCompletion.at) < 2000;
      const usageDots = usageCount
        ? `<span class="flex-action-dots" aria-label="${usageCount} time${usageCount === 1 ? '' : 's'} used today">${Array.from({ length: usageCount }, (_, index) => `<span class="flex-action-dot${shouldAnimate && index === usageCount - 1 ? ' flex-action-dot--pop' : ''}"></span>`).join('')}</span>`
        : '';
      row.innerHTML = `
        <div class="min-w-0 flex-action-main">
          <div class="font-medium truncate"
               title="${escapeHtml(f.name || '')}">
            ${escapeHtml(f.name || '')}
          </div>
          <div class="text-xs text-zinc-400 flex-action-usage">
            <span>${f.points || 0} pts/use</span>
            ${usageDots}
          </div>
        </div>
        <div class="flex gap-2 flex-wrap flex-action-buttons">
          <button class="btn btn-ghost btn-task" data-act="flex-edit" data-id="${f.id}">Edit</button>
          <button class="btn btn-success btn-task btn-check" data-act="flex-do" data-id="${f.id}" aria-label="Done">‚úì</button>
        </div>
      `;
      list.appendChild(row);
      if (shouldAnimate) appliedAnimation = true;
    }
  });
  if (appliedAnimation) {
    lastFlexCompletion = null;
  }

  // Wire normal-mode buttons
  list.querySelectorAll('[data-act="flex-do"]').forEach(btn => {
    btn.onclick = () => logFlexCompletion(btn.getAttribute('data-id'));
  });
  list.querySelectorAll('[data-act="flex-edit"]').forEach(btn => {
    btn.onclick = () => {
      editingFlexId = btn.getAttribute('data-id');
      renderFlexActions();
    };
  });
  list.querySelectorAll('[data-act="flex-retire"]').forEach(btn => {
    btn.onclick = () => toggleFlexRetired(btn.getAttribute('data-id'));
  });
  list.querySelectorAll('[data-act="flex-del"]').forEach(btn => {
    btn.onclick = () => deleteFlexAction(btn.getAttribute('data-id'));
  });
}


function addFlexAction(){
  const nameEl = $('flexName');
  const ptsEl  = $('flexPts');
  const name = nameEl.value.trim();
  const pts = parseFloat(ptsEl.value);
  const safePts = Number.isFinite(pts) ? pts : 0;
  if(!name) return;
  if(!Array.isArray(state.flexActions)) state.flexActions = [];
  state.flexActions.push({
    id: crypto.randomUUID(),
    name,
    points: safePts
  });
  nameEl.value = '';
  ptsEl.value = '';
  save();
  renderFlexActions();
  renderStats();
}

function logFlexCompletion(id){
  if(!Array.isArray(state.flexActions)) state.flexActions = [];
  const f = state.flexActions.find(x=>x.id===id);
  if(!f || f.retired) return;
  const now = new Date().toISOString();
  addCompletion({
    id: crypto.randomUUID(),
    taskId: null,
    flexId: id,
    title: `[Flex] ${f.name}`,
    points: f.points || 0,
    completedAtISO: now,
    source: 'flex'
  });

  lastFlexCompletion = { id, at: Date.now() };
  save();
  renderFlexActions();
  scheduleRender(renderAll);
}

function saveFlexEdit(id, row){
  if (!Array.isArray(state.flexActions)) state.flexActions = [];
  const f = state.flexActions.find(x => x.id === id);
  if (!f) return;

  const nameInput = row.querySelector('input[data-field="name"]');
  const ptsInput  = row.querySelector('input[data-field="points"]');
  let pointsChanged = false;

  if (nameInput) {
    const trimmed = nameInput.value.trim();
    if (trimmed) f.name = trimmed;
  }

  if (ptsInput) {
    const pts = parseFloat(ptsInput.value);
    if (Number.isFinite(pts)) {
      pointsChanged = Number(f.points) !== pts;
      f.points = pts;
    }
  }

  if (pointsChanged && window.TaskPointsCore?.syncDerivedPoints) {
    const derivedSync = TaskPointsCore.syncDerivedPoints(state);
    state = derivedSync.state;

    if (window.TaskPointsCore?.syncYouMatchups) {
      const matchupSync = TaskPointsCore.syncYouMatchups(state);
      state = matchupSync.state;
    }
  }

  editingFlexId = null;
  save();
  renderFlexActions();
  renderStats(); // points per use changed => stats affected
}

function toggleFlexRetired(id){
  if(!Array.isArray(state.flexActions)) state.flexActions = [];
  const f = state.flexActions.find(x => x.id === id);
  if(!f) return;
  f.retired = !f.retired;
  if (f.retired && editingFlexId === id) editingFlexId = null;
  save();
  renderFlexActions();
  renderStats();
}


/* ---------- TASKS ---------- */
function renderTasks(){
  const container=$('taskList'), empty=$('emptyList'); container.innerHTML='';
  const active=state.tasks.filter(t=>!t.completedAtISO && !t.hidden);
  if(!active.length){ empty.classList.remove('hidden'); } else empty.classList.add('hidden');

  const sort=$('sortSelect').value;
  let tasks=active.slice();
  if(sort==='due'){
    tasks.sort((a,b)=>(a.dueDateISO||'').localeCompare(b.dueDateISO||'') || cmpImportance(b,a) || (b.points-a.points));
  }else if(sort==='importance'){
    tasks.sort((a,b)=>cmpImportance(b,a) || (a.dueDateISO||'').localeCompare(b.dueDateISO||''));
  }else if(sort==='points'){
    tasks.sort((a,b)=>b.points-a.points || (a.dueDateISO||'').localeCompare(b.dueDateISO||''));
  }else{
    tasks.sort((a,b)=>a.title.localeCompare(b.title));
  }

  const today = new Date(); today.setHours(0,0,0,0);
  const overdueBucket = { label:'Overdue', key:'overdue', items:[] };
  const dmap = {};
  for(let i=0;i<7;i++){ const d=addDays(today,i); const k=dateKey(d); dmap[k]={ label:labelForDay(d,today), key:k, date:d, items:[] }; }
  const laterBucket = { label:'Later', key:'later', items:[] };
  const nodueBucket = { label:'No due date', key:'nodue', items:[] };

  for(const t of tasks){
    if(!t.dueDateISO){ nodueBucket.items.push(t); continue; }
    if(t.dueDateISO < dateKey(today)) overdueBucket.items.push(t);
    else if(dmap[t.dueDateISO]) dmap[t.dueDateISO].items.push(t);
    else laterBucket.items.push(t);
  }

  const order=[overdueBucket, ...Object.values(dmap), laterBucket, nodueBucket];
  const fragment = document.createDocumentFragment();
  for(const b of order){
    if(b.items.length===0) continue;
    const div=document.createElement('div');
    div.innerHTML=`<div class="sectionDivider">${b.label}</div>`;
    fragment.appendChild(div);

    b.items.forEach(t=>{
      const isOverdue = t.dueDateISO && t.dueDateISO < dateKey(today);
      const postponeDays = Number(t.postponedDays) || 0;
      const showPostponePill = postponeDays > 0 && !!t.dueDateISO;

const badge = {
  Low:      'bg-transparent text-zinc-500 border border-zinc-700',
  Medium:   'bg-teal-400/40 text-teal-950',      // darker text for visibility
  High:     'tag-high',
  Critical: 'tag-critical'
}[t.importance] || 'bg-zinc-300/60 text-zinc-950';

      // Build tags row if this task has tags
      const tags = Array.isArray(t.tags) ? t.tags : [];
const tagsHtml = tags.length
  ? tags.map(tag =>
      `<span class="tag bg-zinc-700/40">${escapeHtml(tag)}</span>`
    ).join('')
  : '';


      const card = document.createElement('div');
      card.dataset.taskId = t.id;
const cardClasses = ['glass'];
if (t.importance === 'Critical') cardClasses.push('critical-card');
else if (t.importance === 'High') cardClasses.push('high-card');
card.className = cardClasses.join(' ');


if (editingTaskId === t.id) {
  const rec = t.recurrence || {};
  const recMode = rec.mode || 'none';
  const recCount = Number.isFinite(rec.customCount) && rec.customCount > 0 ? rec.customCount : 1;
  const recUnit  = rec.customUnit || 'day';

  card.innerHTML = `
    <div class="flex flex-col gap-3">
      <div class="grid gap-2 sm:grid-cols-2">
        <div class="sm:col-span-2">
          <label class="text-xs muted">Title</label>
          <input class="input mt-1" data-field="title" value="${escapeHtml(t.title)}">
        </div>
        <div>
          <label class="text-xs muted">Importance</label>
          <select class="input mt-1" data-field="importance">
            <option ${t.importance==='Low'?'selected':''}>Low</option>
            <option ${t.importance==='Medium'?'selected':''}>Medium</option>
            <option ${t.importance==='High'?'selected':''}>High</option>
            <option ${t.importance==='Critical'?'selected':''}>Critical</option>
          </select>
        </div>
        <div>
          <label class="text-xs muted">Due Date</label>
          <input class="input mt-1" type="date" data-field="due" value="${t.dueDateISO||''}">
        </div>
        <div>
          <label class="text-xs muted">Points</label>
          <input class="input mt-1" type="number" data-field="points" value="${t.points||0}">
        </div>
        <div>
          <label class="text-xs muted">Repeat</label>
          <select class="input mt-1" data-field="repeat">
            <option value="none" ${recMode==='none'?'selected':''}>Does not repeat</option>
            <option value="daily" ${recMode==='daily'?'selected':''}>Daily</option>
            <option value="everyWeekday" ${recMode==='everyWeekday'?'selected':''}>Every Weekday</option>
            <option value="weekly" ${recMode==='weekly'?'selected':''}>Weekly</option>
            <option value="monthly" ${recMode==='monthly'?'selected':''}>Monthly</option>
            <option value="yearly" ${recMode==='yearly'?'selected':''}>Yearly</option>
            <option value="custom" ${recMode==='custom'?'selected':''}>Custom‚Ä¶</option>
          </select>

          <div class="flex items-center gap-2 text-xs mt-2 repeat-custom-row ${recMode==='custom'?'':'hidden'}">
            <span class="muted">Repeat every</span>
            <input type="number" min="1" class="input w-16" data-field="repeatCustomCount" value="${recCount}">
            <select class="input w-24 text-xs" data-field="repeatCustomUnit">
              <option value="day" ${recUnit==='day'?'selected':''}>day(s)</option>
              <option value="week" ${recUnit==='week'?'selected':''}>week(s)</option>
              <option value="month" ${recUnit==='month'?'selected':''}>month(s)</option>
              <option value="year" ${recUnit==='year'?'selected':''}>year(s)</option>
            </select>
          </div>
        </div>
        <div class="sm:col-span-2">
          <label class="text-xs muted">Tags</label>
          <input class="input mt-1" data-field="tags" value="${(Array.isArray(t.tags) ? t.tags : []).join(', ')}">
        </div>
      </div>
      <div class="flex gap-2 flex-wrap justify-end">
        <button class="btn btn-success" data-task-action="task-save" data-task-id="${t.id}">Save</button>
        <button class="btn btn-ghost" data-task-action="task-cancel" data-task-id="${t.id}">Cancel</button>
        <button class="btn btn-ghost" data-task-action="task-delete" data-task-id="${t.id}">Delete</button>
      </div>
    </div>
  `;

  // ‚¨áÔ∏è keep this
  fragment.appendChild(card);

  // wire up custom row toggle for this card
  const repSel = card.querySelector('select[data-field="repeat"]');
  const customRow = card.querySelector('.repeat-custom-row');
  if (repSel && customRow) {
    const toggle = () => {
      if (repSel.value === 'custom') customRow.classList.remove('hidden');
      else customRow.classList.add('hidden');
    };
    repSel.addEventListener('change', toggle);
    toggle();
  }

  // ‚¨áÔ∏è keep these exactly like before
} else {
card.innerHTML=`
  <div class="flex flex-wrap sm:flex-nowrap items-center gap-3">
    <div class="taskPoints flex flex-col items-center justify-center">
      <div class="taskPointsNumber">${t.points}</div>
      <div class="taskPointsLabel muted">pts</div>
    </div>
<div class="title-wrap min-w-0 flex-1">
  <div class="font-semibold task-title">${escapeHtml(t.title)}</div>

  <div class="flex gap-2 text-xs mt-1 flex-wrap">
    <span class="tag ${badge}">${t.importance}</span>

${t.dueDateISO
  ? `<span class="tag ${isOverdue ? 'bg-rose-600/70 text-rose-50' : 'bg-zinc-700/40'}">
       ${niceDate(fromKey(t.dueDateISO))}
     </span>${showPostponePill ? `<span class="tag postpone-pill">+${postponeDays}d</span>` : ''}`
  : ''
}


    ${tagsHtml}
  </div>
</div>


    <div class="flex gap-2 flex-wrap justify-end ml-auto">
      ${isOverdue?`<button class="btn btn-ghost btn-task" data-task-action="postpone" data-task-id="${t.id}">Postpone</button>`:''}
      <button class="btn btn-ghost btn-task" data-task-action="wont-do" data-task-id="${t.id}">Won‚Äôt do</button>
      <button class="btn btn-ghost btn-task" data-task-action="bump" data-task-id="${t.id}">+1d</button>
      <button class="btn btn-ghost btn-task" data-task-action="edit" data-task-id="${t.id}">Edit</button>
      <button class="btn btn-ghost btn-task" data-task-action="hide" data-task-id="${t.id}">Hide</button>
      <button class="btn btn-delete btn-task" data-task-action="delete" data-task-id="${t.id}">Delete</button>
      <button class="btn btn-success btn-task btn-check" data-task-action="complete" data-task-id="${t.id}" aria-label="Done">‚úì</button>

    </div>
  </div>`;

        fragment.appendChild(card);
      }
    });
  }
  container.appendChild(fragment);
  initTaskListDelegation();
}

function initTaskListDelegation(){
  const list = document.getElementById('taskList');
  if (!list) return;
  if (list.dataset.tpDelegationAttached === '1') return;
  list.addEventListener('click', (e) => {
    if (!(e.target instanceof Element)) return;
    const btn = e.target.closest('[data-task-action][data-task-id]');
    if (!btn) return;
    const action = btn.getAttribute('data-task-action');
    const id = btn.getAttribute('data-task-id');
    if (!action || !id) return;

    switch (action) {
      case 'postpone':
        postponeTask(id);
        break;
      case 'wont-do':
        wontDoMain(id);
        break;
      case 'bump':
        bumpTaskOneDay(id);
        break;
      case 'edit':
        editTask(id);
        break;
      case 'hide':
        hideTask(id);
        break;
      case 'delete':
      case 'task-delete':
        deleteTask(id);
        break;
      case 'complete':
        completeTask(id);
        break;
      case 'task-save': {
        const card = btn.closest('.glass[data-task-id]');
        if (card) saveTaskEdit(id, card);
        break;
      }
      case 'task-cancel':
        editingTaskId = null;
        renderTasks();
        break;
      default:
        break;
    }
  });
  list.dataset.tpDelegationAttached = '1';
}

function saveSleepScore(){
  const rawStr = $('sleepScoreInput').value.trim();
  if (rawStr === '') return alert("Enter your sleep score (0‚Äì100).");

  const raw = Number(rawStr);
  if (Number.isNaN(raw) || raw < 0 || raw > 100) {
    return alert("Sleep score must be between 0 and 100.");
  }

  const restedStr = $('sleepRestedInput')?.value.trim() ?? '';
  const rested = restedStr === '' ? 0 : Number(restedStr);
  if (!Number.isFinite(rested)) {
    return alert("Rested value must be a valid number.");
  }

  const pts = sleepPoints(raw, rested); // e.g. 97 ‚Üí 10.7 plus rest

  // Use today's date (local) and normalize so timezones don't mess the day
  const d = new Date();
  d.setHours(12, 0, 0, 0);        // force midday
  const key = dateKey(d);         // e.g. "2025-12-03"
  const whenISO = d.toISOString();

  // Look for an existing Sleep Score entry for this same day
  let existing = null;
  for (const c of state.completions) {
    if (!c.title || !c.title.startsWith('Sleep Score')) continue;
    const cd = new Date(c.completedAtISO);
    if (dateKey(cd) === key) {
      existing = c;
      break;
    }
  }

  if (existing) {
    // Update today's sleep entry
    existing.title = `Sleep Score (${raw}) ‚Äî Rest ${rested}`;
    existing.points = pts;
    existing.sleepRested = rested;
    existing.completedAtISO = whenISO;
    existing.source = 'metric';
  } else {
    // Create a new one if none exists for today
// Create a new one if none exists for today
state.completions.unshift({
  id: crypto.randomUUID(),
  title: `Sleep Score (${raw}) ‚Äî Rest ${rested}`,
  points: pts,
  completedAtISO: whenISO,
  sleepRested: rested,
  source: "metric"
});
markCompletionsDirty();
  }

  $('sleepScoreInput').value = "";  // clear input
  const restInput = $('sleepRestedInput');
  if (restInput) restInput.value = "";

  save();
  scheduleRender(renderAll);  // refresh stats, history chips, etc.
}

function editTodaySleepScore() {
  const entry = getTodaySleepEntry();
  if (!entry) return alert("You haven't entered today's sleep score yet.");

  promptEditSleepEntry(entry);
}


function saveCalories(){
  const rawStr = $('caloriesInput').value.trim();
  if (rawStr === '') return alert("Enter today's calories.");

  const raw = Number(rawStr);
  if (Number.isNaN(raw) || raw < 0) return alert("Calories can‚Äôt be negative.");

  const pts = caloriesToPoints(raw);

  // 1) Figure out what date this entry is for (date picker or today)
  const dateStr = $('caloriesDate') ? $('caloriesDate').value : '';
  let d;
  if (dateStr) {
    const [y, m, day] = dateStr.split('-').map(n => parseInt(n, 10));
    d = new Date(y, m - 1, day);
  } else {
    d = new Date();
  }
  // normalize so timezones don't bump it to the wrong day
  d.setHours(12, 0, 0, 0);
  const key = dateKey(d);
  const whenISO = d.toISOString();

  // 2) Look for an existing Calories entry for this same date
  let existing = null;
  for (const c of state.completions) {
    if (!c.title || !c.title.startsWith('Calories')) continue;
    const cd = new Date(c.completedAtISO);
    if (dateKey(cd) === key) {
      existing = c;
      break;
    }
  }

  // 3) If we found one, UPDATE it; otherwise, create a new one
  if (existing) {
    existing.title = `Calories (${raw})`;
    existing.points = pts;
    existing.completedAtISO = whenISO;
    existing.source = 'metric';
  } else {
    state.completions.unshift({
      id: crypto.randomUUID(),
      title: `Calories (${raw})`,
      points: pts,
      completedAtISO: whenISO,
      source: "metric"
    });
  }

  markCompletionsDirty();
  
  $('caloriesInput').value = '';
  
  save();
  scheduleRender(renderAll);
}


function formatCaloriesDateLabel(value) {
  if (!value) return '';
  const [y, m, d] = value.split('-').map(v => parseInt(v, 10));
  if (!y || !m || !d) return '';
  return `${m}/${d}`;
}

function initCaloriesDatePicker(){
  const dateInput = $('caloriesDate');
  const label = $('caloriesDateLabel');
  if(!dateInput || !label) return;

  dateInput.addEventListener('change', () => {
    const picked = dateInput.value; // "YYYY-MM-DD"
    if(!picked){
      label.textContent = '';
      return;
    }

    const [y, m, d] = picked.split('-').map(Number);
    const dt = new Date(y, m - 1, d);

    label.textContent = `üìÖ ${dt.toLocaleDateString([], { month:'short', day:'numeric', year:'numeric' })}`;
  });
}



function renderSleepHistory() {
  const container = $('sleepHistory');
  if (container) container.innerHTML = '';

const sleepEntries = getDerived().sleepEntries;


  // --- LEFT SIDE: Today's big stat ---
  const todayKey = dateKey(new Date());
  const todayEntry = getTodaySleepEntry();

  const todayValueEl   = $('sleepTodayValue');
  const todayImpactEl  = $('sleepTodayImpact');
  const todayRestChip  = $('sleepTodayRest');
  const todayRestValue = $('sleepTodayRestValue');
  const sleepInputRow  = $('sleepInputRow');

const sleepSummaryRow = $('sleepSummaryRow');
const sleepSummaryValue = $('sleepSummaryValue');
const sleepSummaryRest = $('sleepSummaryRest');
const sleepSummaryRestValue = $('sleepSummaryRestValue');
const sleepSummaryImpact = $('sleepSummaryImpact');

   const sleepImpactBelow      = $('sleepImpactBelow');


  
  const setTodaySleepEditable = (el) => {
    if (!el) return;
    if (todayEntry) {
      el.classList.add('cursor-pointer');
      el.setAttribute('role', 'button');
      el.setAttribute('tabindex', '0');
      el.onclick = (ev) => {
        ev?.stopPropagation?.();
        editTodaySleepScore();
      };
      el.onkeydown = (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          ev.stopPropagation();
          editTodaySleepScore();
        }
      };
    } else {
      el.classList.remove('cursor-pointer');
      el.removeAttribute('role');
      el.removeAttribute('tabindex');
      el.onclick = null;
      el.onkeydown = null;
    }
  };

  if (todayValueEl && todayImpactEl) {
    if (todayEntry) {
      const { score, rested } = getSleepInfo(todayEntry);
      if (score != null && !Number.isNaN(score)) {
        todayValueEl.textContent = score;

        const hasRest = Number.isFinite(rested) && rested !== 0;
        if (todayRestChip && todayRestValue) {
          if (hasRest) {
            todayRestValue.textContent = rested > 0 ? `+${rested}` : `${rested}`;
            todayRestChip.classList.remove('hidden');
          } else {
            todayRestChip.classList.add('hidden');
            todayRestValue.textContent = '';
          }
        }

        const totalPts = sleepPoints(score, rested);
const base  = score / 10;
const bonus = sleepBonus(score);
const rest  = Number.isFinite(rested) ? rested : 0;

const parts = [base];
if (bonus) parts.push(bonus);
if (rest)  parts.push(rest);

const breakdown = parts.map(v => Number(v).toFixed(1)).join(' + ');

if (sleepImpactBelow) {
  sleepImpactBelow.textContent = `adds ${totalPts.toFixed(1)} pts (${breakdown})`;
}

        const restText = hasRest ? ` (${rested >= 0 ? '+' : ''}${rested})` : '';

// --- Mobile summary line: "- 90" and optional (+rested) chip ---
if (sleepSummaryValue && sleepSummaryRow) {
  sleepSummaryValue.textContent = `${score}`;

  // show (+rested) chip
  if (sleepSummaryRest && sleepSummaryRestValue) {
    if (hasRest) {
      sleepSummaryRestValue.textContent = rested > 0 ? `+${rested}` : `${rested}`;
      sleepSummaryRest.classList.remove('hidden');
    } else {
      sleepSummaryRest.classList.add('hidden');
      sleepSummaryRestValue.textContent = '';
    }
  }
}

if (sleepSummaryImpact) {
  const base  = score / 10;
  const bonus = sleepBonus(score);
  const rest  = Number.isFinite(rested) ? rested : 0;

  const parts = [base];
  if (bonus) parts.push(bonus);
  if (rest)  parts.push(rest);

  const breakdown = parts.map(v => Number(v).toFixed(1)).join(' + ');
  sleepSummaryImpact.textContent = `adds ${totalPts.toFixed(1)} pts (${breakdown})`;
}



        
        todayImpactEl.textContent = `Adds ${totalPts.toFixed(1)} pts to today${restText}`;
        todayImpactEl.dataset.empty = 'false';
      } else {
        todayValueEl.textContent = '‚Äî';
        todayImpactEl.textContent = 'Adds ‚Äî pts to today';
        todayImpactEl.dataset.empty = 'true';
      }
    } else {
      todayValueEl.textContent = '‚Äî';
      todayImpactEl.textContent = 'Adds 0 pts to today';
      todayImpactEl.dataset.empty = 'true';
    }
  }

  if (todayRestChip && todayRestValue && !todayEntry) {
    todayRestChip.classList.add('hidden');
    todayRestValue.textContent = '';
  }

  setTodaySleepEditable(todayValueEl);
  setTodaySleepEditable(todayRestChip);
  setTodaySleepEditable(todayImpactEl);
  setTodaySleepEditable(sleepSummaryRow);


if (todayEntry) {
  sleepInputRow?.classList.add('hidden');
  sleepSummaryRow?.classList.remove('hidden');
  sleepImpactBelow?.classList.remove('hidden');
} else {
  sleepInputRow?.classList.remove('hidden');
  sleepSummaryRow?.classList.add('hidden');
  sleepImpactBelow?.classList.add('hidden');
  if (sleepImpactBelow) sleepImpactBelow.textContent = '';
}





  // --- RIGHT SIDE: recent nights chips ---
  // Show the 4 most recent *prior* nights (exclude today's entry if present)
  const recent = sleepEntries
    .filter(entry => {
      const d = new Date(entry.completedAtISO);
      return dateKey(d) !== todayKey;
    })
    .slice(0, 6);

  if (!container) return;


  recent.forEach(entry => {
    const date = new Date(entry.completedAtISO);

    const prettyDate = date.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'numeric',
      day: 'numeric'
    });

    const { score, rested } = getSleepInfo(entry);
    const pts   = sleepPoints(score, rested).toFixed(1);
    const restLabel = rested ? `<div class="sleep-chip-rest muted text-[11px]">${rested > 0 ? `+${rested}` : rested}</div>` : '';
    const scoreDisplay = Number.isFinite(score) ? score : '?';

    const block = document.createElement('div');
    block.className = 'sleep-chip cursor-pointer';

    block.innerHTML = `
      <div class="sleep-chip-date">${prettyDate}</div>
      <div class="sleep-chip-score">${scoreDisplay}</div>
      <div class="sleep-chip-pts">${pts} pts</div>
      ${restLabel}
    `;




    block.onclick = () => {
      promptEditSleepEntry(entry);
    };

    container.appendChild(block);
  });
}

function renderCaloriesHistory() {
  const container = $('caloriesHistory');
  if (container) container.innerHTML = '';

const entries = getDerived().caloriesEntries;

  const todayKey = dateKey(new Date());
  const todayEntry = getTodayCaloriesEntry();

  // Big Today stat
  const todayValueEl  = $('caloriesTodayValue');
  const todayImpactEl = $('caloriesTodayImpact');

  const inputRow = $('caloriesInputRow');
  const dateInput = $('caloriesDate');
  const dateLabel = $('caloriesDateLabel');
  const caloriesSummaryRow   = $('caloriesSummaryRow');
const caloriesSummaryValue = $('caloriesSummaryValue');
const caloriesImpactBelow  = $('caloriesImpactBelow');
const impactBelow  = $('caloriesImpactBelow');
const summaryRow   = $('caloriesSummaryRow');
const summaryValue = $('caloriesSummaryValue');


  const setTodayCaloriesEditable = (el) => {
    if (!el) return;
    if (todayEntry) {
      el.classList.add('cursor-pointer');
      el.setAttribute('role', 'button');
      el.setAttribute('tabindex', '0');
      el.onclick = (ev) => {
        ev?.stopPropagation?.();
        editTodayCalories();
      };
      el.onkeydown = (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          ev.stopPropagation();
          editTodayCalories();
        }
      };
    } else {
      el.classList.remove('cursor-pointer');
      el.removeAttribute('role');
      el.removeAttribute('tabindex');
      el.onclick = null;
      el.onkeydown = null;
    }
  };

// hide the entry UI once today exists (Sleep-style)
if (todayEntry) {
  inputRow?.classList.add('hidden');
  dateLabel?.classList.add('hidden');

  // show mobile summary + impact-below
  summaryRow?.classList.remove('hidden');
  impactBelow?.classList.remove('hidden');
} else {
  inputRow?.classList.remove('hidden');
  dateLabel?.classList.remove('hidden');

  // hide mobile summary + impact-below
  summaryRow?.classList.add('hidden');
  if (summaryValue) summaryValue.textContent = '';
  impactBelow?.classList.add('hidden');
  if (impactBelow) impactBelow.textContent = '';

  // optional: default back to ‚Äútoday‚Äù mode
  if (dateInput) dateInput.value = '';
  if (dateLabel) dateLabel.textContent = '';
}



  setTodayCaloriesEditable(todayValueEl);
  setTodayCaloriesEditable(todayImpactEl);
  
  setTodayCaloriesEditable(summaryRow);     // ‚úÖ lets you click the right-side number
setTodayCaloriesEditable(summaryValue);   // optional, but nice
setTodayCaloriesEditable(impactBelow);    // optional, makes the "adds X pts" line clickable too

  
  if (todayValueEl && todayImpactEl) {
    if (todayEntry) {
      const titleMatch = todayEntry.title.match(/\((\d+)\)/);
      const calNum = titleMatch ? Number(titleMatch[1]) : null;

if (calNum != null && !Number.isNaN(calNum)) {
  const pts = caloriesToPoints(calNum);

  todayValueEl.textContent = calNum;

  // big meta line (the one that already exists)
  todayImpactEl.textContent = `Adds ${pts.toFixed(1)} pts to today`;
  todayImpactEl.dataset.empty = 'false';

  // mobile summary number on the right
  if (summaryValue) summaryValue.textContent = String(calNum);

  // ‚úÖ the gray line UNDER "Calories" title
  if (impactBelow) impactBelow.textContent = `adds ${pts.toFixed(1)} pts`;


      } else {
        todayValueEl.textContent = '‚Äî';
        todayImpactEl.textContent = 'Adds ‚Äî pts to today';
        todayImpactEl.dataset.empty = 'true';
      }
    } else {
      todayValueEl.textContent = '‚Äî';
      todayImpactEl.textContent = 'Adds 0 pts to today';
      todayImpactEl.dataset.empty = 'true';
    }
  }

  // Recent (max 4) excluding today
  const recent = entries
    .filter(entry => dateKey(new Date(entry.completedAtISO)) !== todayKey)
    .slice(0, 6);

  if (!container) return;

  recent.forEach(entry => {
    const date = new Date(entry.completedAtISO);

    const prettyDate = date.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'numeric',
      day: 'numeric'
    });

    const cal = entry.title.match(/\((\d+)\)/)?.[1] || '?';
    const pts = (Number(entry.points) || 0).toFixed(1);

    const block = document.createElement('div');
    block.className = 'cal-chip cursor-pointer';

    block.innerHTML = `
      <div class="cal-chip-date">${prettyDate}</div>
      <div class="cal-chip-value">${cal}</div>
      <div class="cal-chip-pts">${pts} pts</div>
    `;


    // allow editing a past day
    block.onclick = () => {
      const newVal = prompt('Edit calories for this day:', cal);
      if (!newVal && newVal !== '0') return;

      const raw = Number(newVal);
      if (isNaN(raw) || raw < 0) return alert('Invalid calories.');

      entry.title  = `Calories (${raw})`;
      entry.points = caloriesToPoints(raw);

      markCompletionsDirty();
      
      save();
      scheduleRender(renderAll);
    };

    container.appendChild(block);
  });
}

function getTodayWorkEntry() {
  const todayKey = dateKey(new Date());
  for (const entry of state.completions) {
    if (!entry?.title?.startsWith("Work Score")) continue;
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayKey) return entry;
  }
  return null;
}

function editTodayWork() {
  const entry = getTodayWorkEntry();
  if (!entry) return alert("You haven't entered today's work score yet.");

  promptEditWorkEntry(entry, { pinToToday: true });
}

  
function saveWorkScore() {
  const rawStr = $('workScoreInput').value.trim();
  if (rawStr === '') return alert("Enter your work score.");

  const raw = Number(rawStr);
  if (Number.isNaN(raw)) return alert("Work Score must be a number.");

  const hoursStr = $('workHoursInput')?.value.trim() ?? '';
  const hoursVal = hoursStr === '' ? 0 : Number(hoursStr);
  if (!Number.isFinite(hoursVal)) return alert("Hours value must be a number.");
  const safeHours = Math.max(0, hoursVal);

  // Direct 1:1 mapping ‚Üí 7 becomes 7 pts
  const pts = workPoints(raw, safeHours);

  // Date normalized so it always logs to the correct day
  const d = new Date();
  d.setHours(12, 0, 0, 0);
  const key = dateKey(d);
  const whenISO = d.toISOString();

  // Look for an existing Work Score entry for today
  let existing = null;
  for (const c of state.completions) {
    if (!c.title || !c.title.startsWith('Work Score')) continue;
    const cd = new Date(c.completedAtISO);
    if (dateKey(cd) === key) {
      existing = c;
      break;
    }
  }

  if (existing) {
    existing.title = `Work Score (${raw}) ‚Äî Hours ${safeHours}`;
    existing.points = pts;
    existing.workHours = safeHours;
    existing.source = 'work';
    existing.completedAtISO = whenISO;
  } else {
    state.completions.unshift({
      id: crypto.randomUUID(),
      title: `Work Score (${raw}) ‚Äî Hours ${safeHours}`,
      points: pts,
      completedAtISO: whenISO,
      workHours: safeHours,
      source: "work"
    });
  }

  $('workScoreInput').value = "";
  const hoursInput = $('workHoursInput');
  if (hoursInput) hoursInput.value = "";
  markCompletionsDirty();
  save();
  scheduleRender(renderAll);
}

function renderWorkHistory() {
  const container = $('workHistory');
  if (container) container.innerHTML = '';
  if (!container) return;

const entries = getDerived().workEntries;

  const workImpactBelow = document.getElementById('workImpactBelow');
const workSummaryRow = document.getElementById('workSummaryRow');
const workSummaryValue = document.getElementById('workSummaryValue');
const workSummaryHours = document.getElementById('workSummaryHours');
const workSummaryHoursValue = document.getElementById('workSummaryHoursValue');


  // TODAY
  const today = new Date();
  const todayK = dateKey(today);
  let todayEntry = null;

  for (const entry of entries) {
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayK) {
      todayEntry = entry;
      break;
    }
  }

  const todayValueEl = $('workTodayValue');
  const todayImpactEl = $('workTodayImpact');
  const inputRow = $('workInputRow');
  const todayHoursChip = $('workTodayHours');
  const todayHoursValue = $('workTodayHoursValue');
  const setTodayWorkEditable = (el) => {
    if (!el) return;
    if (todayEntry) {
      el.classList.add('cursor-pointer');
      el.setAttribute('role', 'button');
      el.setAttribute('tabindex', '0');
      el.title = "Tap/click to edit today's work score";
      el.onclick = (ev) => {
        ev?.stopPropagation?.();
        editTodayWork();
      };
      el.onkeydown = (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          ev.stopPropagation();
          editTodayWork();
        }
      };
    } else {
      el.classList.remove('cursor-pointer');
      el.removeAttribute('role');
      el.removeAttribute('tabindex');
      el.title = "";
      el.onclick = null;
      el.onkeydown = null;
    }
  };


if (todayValueEl && todayImpactEl) {
  if (todayEntry) {
    const { score, hours } = getWorkInfo(todayEntry);
    if (!Number.isNaN(score) && score !== null) {
      todayValueEl.textContent = score;

      const hasHours = Number.isFinite(hours) && hours !== 0;
      if (todayHoursChip && todayHoursValue) {
        if (hasHours) {
          todayHoursValue.textContent = hours > 0 ? `+${hours}` : `${hours}`;
          todayHoursChip.classList.remove('hidden');
        } else {
          todayHoursChip.classList.add('hidden');
          todayHoursValue.textContent = '';
        }
      }

      const totalPts = workPoints(score, hours);
      const hoursText = hasHours ? ` (${hours >= 0 ? '+' : ''}${hours})` : '';
      todayImpactEl.textContent = `Adds ${totalPts.toFixed(1)} pts to today${hoursText}`;
      todayImpactEl.dataset.empty = 'false';

// ‚úÖ hide input row after initial entry (Sleep/Calories style)
inputRow?.classList.add('hidden');

// show mobile summary + impact-below
workSummaryRow?.classList.remove('hidden');
workImpactBelow?.classList.remove('hidden');

// fill summary value (right-side number)
if (workSummaryValue) workSummaryValue.textContent = String(score);

// hours chip should show the HOURS BONUS (not raw hours), like your history chips do
const hoursBonus = workHoursBonus(hours);
if (workSummaryHours && workSummaryHoursValue) {
  const show = Number.isFinite(hoursBonus) && hoursBonus !== 0;
  if (show) {
    workSummaryHoursValue.textContent = `${hoursBonus >= 0 ? '+' : ''}${hoursBonus.toFixed(1)}`;
    workSummaryHours.classList.remove('hidden');
  } else {
    workSummaryHours.classList.add('hidden');
    workSummaryHoursValue.textContent = '';
  }
}

// gray line under the title
if (workImpactBelow) {
  const breakdown = (Number.isFinite(hoursBonus) && hoursBonus !== 0)
    ? ` (${score} + ${hoursBonus.toFixed(1)})`
    : ` (${score})`;
  workImpactBelow.textContent = `adds ${totalPts.toFixed(1)} pts${breakdown}`;
}

    } else {
      todayValueEl.textContent = '‚Äî';
      todayImpactEl.textContent = 'Adds ‚Äî pts to today';
      todayImpactEl.dataset.empty = 'true';
    }
  } else {
    todayValueEl.textContent = '‚Äî';
    todayImpactEl.textContent = 'Adds 0 pts to today';
    todayImpactEl.dataset.empty = 'true';

    if (todayHoursChip && todayHoursValue) {
      todayHoursChip.classList.add('hidden');
      todayHoursValue.textContent = '';
    }

// ‚úÖ show input row if no entry yet (and hide summary/impact)
inputRow?.classList.remove('hidden');

workSummaryRow?.classList.add('hidden');
if (workSummaryValue) workSummaryValue.textContent = '';
if (workSummaryHours) workSummaryHours.classList.add('hidden');
if (workSummaryHoursValue) workSummaryHoursValue.textContent = '';

workImpactBelow?.classList.add('hidden');
if (workImpactBelow) workImpactBelow.textContent = '';

  }
}

  setTodayWorkEditable(todayValueEl);
  setTodayWorkEditable(todayImpactEl);
  setTodayWorkEditable(todayHoursChip);
setTodayWorkEditable(workSummaryRow);
setTodayWorkEditable(workSummaryValue);
setTodayWorkEditable(workImpactBelow);


  // RECENT HISTORY (4 chips)
  const recent = entries
    .filter(e => dateKey(new Date(e.completedAtISO)) !== todayK)
    .slice(0, 6);

  recent.forEach(entry => {
    const date = new Date(entry.completedAtISO);

    const prettyDate = date.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'numeric',
      day: 'numeric'
    });

    const { score, hours } = getWorkInfo(entry);
    const val = Number.isFinite(score) ? score : '?';
    const safeHours = Number.isFinite(hours) ? hours : 0;
    const pts = workPoints(val, safeHours).toFixed(1);
    const hoursBonus = workHoursBonus(safeHours);
    const hoursDisplay = Number.isFinite(hoursBonus)
      ? `${hoursBonus >= 0 ? '+' : ''}${hoursBonus.toFixed(1)}`
      : '';

    const block = document.createElement('div');
    block.className = 'work-chip cursor-pointer';

    block.innerHTML = `
      <div class="work-chip-date">${prettyDate}</div>
      <div class="work-chip-value">${val}</div>
      <div class="work-chip-pts">${pts} pts</div>
      <div class="work-chip-bonus">${hoursDisplay}</div>
    `;

    block.onclick = () => {
      promptEditWorkEntry(entry);
    };

    container.appendChild(block);
  });
}

  function getTodayMoodEntry() {
  const todayKeyStr = dateKey(new Date());
  for (const c of state.completions) {
    if (!c?.title?.startsWith('Mood Score')) continue;
    const d = new Date(c.completedAtISO);
    if (dateKey(d) === todayKeyStr) return c;
  }
  return null;
}

function editTodayMood() {
  const entry = getTodayMoodEntry();
  if (!entry) return alert("You haven't entered today's mood score yet.");

  const current = entry.title.match(/\((.+)\)/)?.[1] ?? "";
  const newVal = prompt("Edit today's mood score:", String(current));
  if (newVal === null) return;

  const num = Number(String(newVal).trim());
  if (Number.isNaN(num)) return alert("Invalid mood score.");

  const d = new Date();
  d.setHours(12, 0, 0, 0);

  entry.title = `Mood Score (${num})`;
  entry.points = moodPoints(num);
  entry.completedAtISO = d.toISOString();
  entry.source = 'metric';

  markCompletionsDirty();
  
  save();
  scheduleRender(renderAll);
}

function saveMoodScore() {
  const rawStr = $('moodScoreInput').value.trim();
  if (rawStr === '') return alert("Enter your mood score.");

  const raw = Number(rawStr);
  if (Number.isNaN(raw)) return alert("Mood Score must be a number.");

  const pts = moodPoints(raw);

  const d = new Date();
  d.setHours(12, 0, 0, 0);
  const key = dateKey(d);
  const whenISO = d.toISOString();

  let existing = null;
  for (const c of state.completions) {
    if (!c.title || !c.title.startsWith('Mood Score')) continue;
    const cd = new Date(c.completedAtISO);
    if (dateKey(cd) === key) { existing = c; break; }
  }

  if (existing) {
    existing.title = `Mood Score (${raw})`;
    existing.points = pts;
    existing.completedAtISO = whenISO;
    existing.source = 'metric';
  } else {
    state.completions.unshift({
      id: crypto.randomUUID(),
      title: `Mood Score (${raw})`,
      points: pts,
      completedAtISO: whenISO,
      source: "metric"
    });
  }

  markCompletionsDirty();
  
  $('moodScoreInput').value = "";
  save();
  scheduleRender(renderAll);
}

function renderMoodHistory() {
  const container = $('moodHistory');
  if (container) container.innerHTML = '';

const entries = getDerived().moodEntries;

  const today = new Date();
  const todayK = dateKey(today);

  let todayEntry = null;
  for (const entry of entries) {
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayK) { todayEntry = entry; break; }
  }

  const todayValueEl = $('moodTodayValue');
  const todayImpactEl = $('moodTodayImpact');
  const inputRow = $('moodInputRow');
  const moodImpactBelow = document.getElementById('moodImpactBelow');
const moodSummaryRow = document.getElementById('moodSummaryRow');
const moodSummaryValue = document.getElementById('moodSummaryValue');
  const setTodayMoodEditable = (el) => {
    if (!el) return;
    if (todayEntry) {
      el.classList.add('cursor-pointer');
      el.setAttribute('role', 'button');
      el.setAttribute('tabindex', '0');
      el.title = "Tap/click to edit today's mood score";
      el.onclick = (ev) => {
        ev?.stopPropagation?.();
        editTodayMood();
      };
      el.onkeydown = (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          ev.stopPropagation();
          editTodayMood();
        }
      };
    } else {
      el.classList.remove('cursor-pointer');
      el.removeAttribute('role');
      el.removeAttribute('tabindex');
      el.title = "";
      el.onclick = null;
      el.onkeydown = null;
    }
  };

  if (todayValueEl && todayImpactEl) {
    if (todayEntry) {
      const num = Number(todayEntry.title.match(/\((.+)\)/)?.[1] || NaN);
if (!isNaN(num)) {
  todayValueEl.textContent = num;
  todayImpactEl.textContent = `Adds ${todayEntry.points} pts to today`;
  todayImpactEl.dataset.empty = 'false';

  // show mobile summary + impact-below (Work style)
  moodSummaryRow?.classList.remove('hidden');
  moodImpactBelow?.classList.remove('hidden');
  if (moodSummaryValue) moodSummaryValue.textContent = String(num);
  if (moodImpactBelow) moodImpactBelow.textContent = `adds ${todayEntry.points} pts`;
} else {
  todayValueEl.textContent = '‚Äî';
  todayImpactEl.textContent = 'Adds ‚Äî pts to today';
  todayImpactEl.dataset.empty = 'true';

  // hide summary/impact when parsing fails
  moodSummaryRow?.classList.add('hidden');
  if (moodSummaryValue) moodSummaryValue.textContent = '';
  moodImpactBelow?.classList.add('hidden');
  if (moodImpactBelow) moodImpactBelow.textContent = '';
}

inputRow?.classList.add('hidden');
    }
  }
  setTodayMoodEditable(todayValueEl);
  setTodayMoodEditable(todayImpactEl);
  setTodayMoodEditable(moodSummaryRow);
  setTodayMoodEditable(moodSummaryValue);
setTodayMoodEditable(moodImpactBelow);


  const recent = entries
    .filter(e => dateKey(new Date(e.completedAtISO)) !== todayK)
    .slice(0, 6);

  recent.forEach(entry => {
    const date = new Date(entry.completedAtISO);

    const prettyDate = date.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'numeric',
      day: 'numeric'
    });

    const val = entry.title.match(/\((.+)\)/)?.[1] || '?';
    const pts = entry.points;

    const block = document.createElement('div');
    block.className = 'mood-chip cursor-pointer';

    block.innerHTML = `
      <div class="mood-chip-date">${prettyDate}</div>
      <div class="mood-chip-value">${val}</div>
      <div class="mood-chip-pts">${pts} pts</div>
    `;

    block.onclick = () => {
      const newVal = prompt("Edit mood score:", val);
      if (!newVal && newVal !== "0") return;

      const num = Number(newVal);
      if (isNaN(num)) return alert("Invalid number.");

      entry.title = `Mood Score (${num})`;
      entry.points = moodPoints(num);

      markCompletionsDirty();
      
      save();
      scheduleRender(renderAll);
    };

    container.appendChild(block);
  });
}


function addTask(){
  const title = $('titleInput').value.trim();
  if(!title) return alert('Enter a task name');

  const mode = $('repeatInput').value || 'none';
  const rec = { mode };

  // Parse tags from the tags input (comma-separated)
  const rawTags = ($('tagsInput')?.value || '');
  const tags = rawTags
    .split(',')
    .map(s => s.trim())
    .filter(s => s.length > 0);

  if (mode === 'custom') {
    const countRaw = $('repeatCustomCount')?.value;
    const unitRaw  = $('repeatCustomUnit')?.value;
    let count = parseInt(countRaw, 10);
    if (!Number.isFinite(count) || count <= 0) count = 1;
    const unit = (unitRaw === 'week' || unitRaw === 'month' || unitRaw === 'year') ? unitRaw : 'day';
    rec.customCount = count;
    rec.customUnit = unit;
  }

  const task = {
    id: crypto.randomUUID(),
    title,
    importance: $('importanceInput').value,
    dueDateISO: $('dueDateInput').value || null,
    originalDueDateISO: $('dueDateInput').value || null,
    points: Number($('pointsInput').value)||0,
    recurrence: rec,
    tags,                // ‚¨Ö new
    skipDates: [],
    hidden: false,
    completedAtISO: null,
    createdAtISO: new Date().toISOString(),
    postponedDays: 0
  };


  state.tasks.unshift(task);

  save();
  clearForm();
  renderTasks();

  closeAddTaskModal();
}


function setDueToday(){
  $('dueDateInput').value = todayKey();
}

function scrollToTasks(){
  const el = $('tasksAnchor');
  if (el) {
    el.scrollIntoView({
      behavior: 'smooth',
      block: 'start'
    });
  }
}

function clearForm(){
  $('titleInput').value='';
  $('pointsInput').value='';
  $('dueDateInput').value='';
  $('importanceInput').value='Medium';
  $('repeatInput').value='none';
  if ($('repeatCustomCount')) $('repeatCustomCount').value='1';
  if ($('repeatCustomUnit')) $('repeatCustomUnit').value='day';
  if ($('tagsInput')) $('tagsInput').value='';          // ‚¨Ö new
  if (repeatCustomRow) repeatCustomRow.classList.add('hidden');
}


function bumpTaskOneDay(id){
  const t = state.tasks.find(x => x.id === id);
  if (!t) return;
  bumpOneDay(t);
  save();
  renderTasks();
}

function postponeTask(id){
  const t=state.tasks.find(x=>x.id===id); if(!t||!t.dueDateISO) return;
  const oldDue = t.dueDateISO;
  t.dueDateISO = todayKey();
  trackDueDatePush(t, oldDue, t.dueDateISO);
  save(); renderTasks();
}
function wontDoMain(id){
  const t=state.tasks.find(x=>x.id===id); if(!t) return;
  const mode = (t.recurrence && t.recurrence.mode) || 'none';
  if(mode==='none'){
    if(!confirm('Won‚Äôt do this task? It will be removed.')) return;
    state.tasks = state.tasks.filter(x=>x.id!==id);
  }else{
    const k = t.dueDateISO || todayKey();
    t.skipDates = Array.isArray(t.skipDates)?t.skipDates:[];
    if(!t.skipDates.includes(k)) t.skipDates.push(k);
    const nextKey = computeNextDueDate(t);
    if (nextKey) {
      t.dueDateISO = nextKey;
    }
  }
  save(); renderTasks();
}

function completeTask(id){
  const t = state.tasks.find(x=>x.id===id);
  if(!t) return;
  const now = new Date().toISOString();
  const completedDayKey = dateKey(now);
  const alreadyCompletedToday = Array.isArray(state.completions)
    ? state.completions.some(c => c && c.taskId === id && dateKey(c.completedAtISO) === completedDayKey)
    : false;

  if (alreadyCompletedToday) {
    return;
  }

  // always log the completion
  addCompletion({
    id: crypto.randomUUID(),
    taskId: id,
    title: t.title,
    points: t.points,
    completedAtISO: now
  });


  const rec = t.recurrence || {};
  const mode = rec.mode || 'none';

  if (mode === 'none') {
    // one-off task ‚Üí mark completed and hide from list
    t.completedAtISO = now;
  } else {
    // repeating task ‚Üí move due date forward, keep it active
    const nextKey = computeNextDueDate(t);
    if (nextKey) t.dueDateISO = nextKey;
    t.completedAtISO = null; // keep it in the active list
  }

  removeTaskFromTodayView(id, completedDayKey);

  save();
  scheduleRender(renderAll);
}

function editTask(id){ editingTaskId = id; renderTasks(); }
function saveTaskEdit(id,card){
  const t=state.tasks.find(x=>x.id===id); if(!t) return;
  const titleInput=card.querySelector('input[data-field="title"]');
  const ptsInput=card.querySelector('input[data-field="points"]');
  const dueInput=card.querySelector('input[data-field="due"]');
  const impSel=card.querySelector('select[data-field="importance"]');
  const repSel=card.querySelector('select[data-field="repeat"]');
  const tagsInput=card.querySelector('input[data-field="tags"]');


  t.title = titleInput.value.trim() || t.title;
  t.points = Number(ptsInput.value)||0;
  const prevDue = t.dueDateISO;
  const dueVal = (dueInput.value||'').trim();
  t.dueDateISO = dueVal || null;
  const impVal = impSel.value;
  if(['Low','Medium','High','Critical'].includes(impVal)) t.importance = impVal;

  trackDueDatePush(t, prevDue, t.dueDateISO);

  if (tagsInput) {
    const raw = tagsInput.value || '';
    t.tags = raw
      .split(',')
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

if (repSel) {
  const mode = repSel.value || 'none';
  t.recurrence = t.recurrence || {};
  t.recurrence.mode = mode;

  if (mode === 'custom') {
    const countInput = card.querySelector('input[data-field="repeatCustomCount"]');
    const unitSel    = card.querySelector('select[data-field="repeatCustomUnit"]');
    let count = parseInt(countInput && countInput.value, 10);
    if (!Number.isFinite(count) || count <= 0) count = 1;
    const unit = (unitSel && (unitSel.value === 'week' || unitSel.value === 'month' || unitSel.value === 'year'))
      ? unitSel.value
      : 'day';
    t.recurrence.customCount = count;
    t.recurrence.customUnit  = unit;
  } else {
    // if you switch away from custom, clean it up
    delete t.recurrence.customCount;
    delete t.recurrence.customUnit;
  }
  }

  editingTaskId=null;
  save(); renderTasks();
}

function hideTask(id){
  const t = state.tasks.find(x => x.id === id);
  if (!t) return;
  t.hidden = true;
  save();
  renderTasks();
}

function deleteTask(id){
  if(!confirm('Delete this task?')) return;
  // Remove the task itself
  state.tasks = state.tasks.filter(t => t.id !== id);
  // Do NOT touch state.completions here ‚Äì keep history/log and points
  if (editingTaskId === id) editingTaskId = null;
  save();
  renderTasks();
}


/* ---------- IMPORT/EXPORT/RESET ---------- */
function stripLegacyImageFields(snapshot) {
  const next = { ...snapshot };
  if (next.youImage) delete next.youImage;
  if (Array.isArray(next.players)) {
    next.players = next.players.map((player) => {
      if (!player || typeof player !== "object") return player;
      const { imageData, ...rest } = player;
      return rest;
    });
  }
  return next;
}

function isZipFile(file) {
  if (!file) return false;
  const name = file.name || "";
  return file.type === "application/zip" || name.toLowerCase().endsWith(".zip");
}

function mimeForImageExtension(ext) {
  const normalized = ext.toLowerCase();
  if (normalized === "png") return "image/png";
  if (normalized === "webp") return "image/webp";
  if (normalized === "gif") return "image/gif";
  if (normalized === "jpg" || normalized === "jpeg") return "image/jpeg";
  return "application/octet-stream";
}

function readZipEntries(arrayBuffer) {
  const bytes = new Uint8Array(arrayBuffer);
  const view = new DataView(arrayBuffer);
  const decoder = new TextDecoder();
  const entries = new Map();
  let offset = 0;

  while (offset + 30 <= bytes.length) {
    const signature = view.getUint32(offset, true);
    if (signature !== 0x04034b50) break;
    const flags = view.getUint16(offset + 6, true);
    const compression = view.getUint16(offset + 8, true);
    if (flags & 0x08) {
      throw new Error("Zip entries with data descriptors are not supported.");
    }
    if (compression !== 0) {
      throw new Error("Only stored (uncompressed) zip entries are supported.");
    }
    const compressedSize = view.getUint32(offset + 18, true);
    const nameLength = view.getUint16(offset + 26, true);
    const extraLength = view.getUint16(offset + 28, true);

    const nameStart = offset + 30;
    const nameEnd = nameStart + nameLength;
    const extraEnd = nameEnd + extraLength;
    const dataStart = extraEnd;
    const dataEnd = dataStart + compressedSize;

    if (dataEnd > bytes.length) {
      throw new Error("Zip entry is truncated.");
    }

    const name = decoder.decode(bytes.slice(nameStart, nameEnd));
    const data = bytes.slice(dataStart, dataEnd);
    entries.set(name, { data });
    offset = dataEnd;
  }

  return entries;
}

async function importBackupZip(file) {
  const entries = readZipEntries(await file.arrayBuffer());
  let manifestEntry = entries.get("manifest.json");
  if (!manifestEntry) {
    for (const [name, entry] of entries.entries()) {
      if (name.endsWith("/manifest.json")) {
        manifestEntry = entry;
        break;
      }
    }
  }
  if (!manifestEntry) {
    throw new Error("manifest.json not found in zip.");
  }

  const manifestText = new TextDecoder().decode(manifestEntry.data);
  const manifest = JSON.parse(manifestText);

  const saveImageBlob = window.TaskPointsCore?.saveImageBlob || window.saveImageBlobFallback;

  for (const [name, entry] of entries.entries()) {
    if (name.endsWith("/")) continue;
    const normalized = name.replace(/\\/g, "/");
    if (!normalized.includes("/images/") && !normalized.startsWith("images/")) continue;
    const fileName = normalized.split("/").pop() || "";
    if (!fileName) continue;
    const dotIndex = fileName.lastIndexOf(".");
    const imageId = dotIndex > 0 ? fileName.slice(0, dotIndex) : fileName;
    const ext = dotIndex > 0 ? fileName.slice(dotIndex + 1) : "";
    if (!imageId) continue;
    const blob = new Blob([entry.data], { type: mimeForImageExtension(ext) });
    if (typeof saveImageBlob === "function") {
      await saveImageBlob(imageId, blob);
    }
  }

  return manifest;
}

function exportData(){
  const scheduleChanged = ensureUpcomingSchedule();
  if (scheduleChanged) save();
  const snapshot = stripLegacyImageFields({ ...state, projects: loadProjectsFromStorage() });
  const blob=new Blob([JSON.stringify(snapshot,null,2)],{type:'application/json'});
  const now = new Date();

  const y  = now.getFullYear();
  const mo = String(now.getMonth() + 1).padStart(2,'0');
  const d  = String(now.getDate()).padStart(2,'0');
  const hh = String(now.getHours()).padStart(2,'0');
  const mm = String(now.getMinutes()).padStart(2,'0');
  const ss = String(now.getSeconds()).padStart(2,'0');

  const filename = `taskpoints-backup-${y}-${mo}-${d}_${hh}-${mm}-${ss}.json`;

  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function applyImportedState(root){
  let normalized = normalizeState({
    tasks:       Array.isArray(root.tasks)       ? root.tasks       : [],
    completions: Array.isArray(root.completions) ? root.completions : [],
    players:     Array.isArray(root.players)     ? root.players     : [],
    habits:      Array.isArray(root.habits)      ? root.habits      : [],
    flexActions: Array.isArray(root.flexActions) ? root.flexActions : [],
    gameHistory: Array.isArray(root.gameHistory) ? root.gameHistory : [],
    matchups:    Array.isArray(root.matchups)    ? root.matchups    : [],
    schedule:    Array.isArray(root.schedule)    ? root.schedule    : [],
    opponentDripSchedules: Array.isArray(root.opponentDripSchedules) ? root.opponentDripSchedules : [],
    youImageId:  typeof root.youImageId === "string" ? root.youImageId : ""
  });

  normalized.projects = Array.isArray(root.projects) ? root.projects : loadProjectsFromStorage();
  state = normalized;

  editingTaskId = null;
  editingHabitId = null;
  editingFlexId = null;

  saveProjectsToStorage(state.projects);

  save();
  window.TaskPointsCore?.flushPendingSaves?.();

  if (window.TaskPointsCore?.migrateLegacyImages) {
    const migrated = await TaskPointsCore.migrateLegacyImages(root);
    if (migrated?.migrated) {
      state = normalizeState(stripLegacyImageFields({ ...migrated.state, projects: normalized.projects }));
      save();
      window.TaskPointsCore?.flushPendingSaves?.();
    }
  }
  scheduleRender(renderAll);
  renderHabits();
  renderHabitWeekLabels();
  renderVices();
  renderViceWeekLabels();

  console.log("Import applied successfully, including projects.");
}

function importFile(ev){
  const f = ev.target.files?.[0];
  if (!f) return;

  if (isZipFile(f)) {
    importBackupZip(f).then((manifest) => {
      const root =
        (manifest && Array.isArray(manifest.tasks) && Array.isArray(manifest.completions)) ? manifest :
        (manifest && manifest.state && Array.isArray(manifest.state.tasks) && Array.isArray(manifest.state.completions)) ? manifest.state :
        null;

      if (!root) {
        throw new Error("Root object missing tasks/completions arrays");
      }

      applyImportedState(root).catch((err) => {
        console.error("Failed to apply imported state (zip):", err);
        alert("Failed to apply imported data. Check console for details.");
      });
    }).catch((err) => {
      console.error("Failed to import zip backup", err);
      alert("Import failed. Make sure the zip was exported from TaskPoints.");
    }).finally(() => {
      ev.target.value = "";
    });
    return;
  }

  const r = new FileReader();
  r.onload = () => {
    let data;
    // 1) Parse stage
    try {
      const raw = String(r.result);
      data = JSON.parse(raw);
      console.log("JSON parsed OK (file import):", data);
    } catch (err) {
      console.error("ACTUAL PARSE ERROR (file import):", err);
      alert("The file is not valid JSON. Check console for details.");
      return;
    }

    // 2) App logic stage
    try {
      const root =
        (data && Array.isArray(data.tasks) && Array.isArray(data.completions)) ? data :
        (data && data.state && Array.isArray(data.state.tasks) && Array.isArray(data.state.completions)) ? data.state :
        null;

      if (!root) {
        throw new Error("Root object missing tasks/completions arrays");
      }

      applyImportedState(root).catch((err) => {
        console.error("Failed to apply imported state (file):", err);
        alert("Failed to apply imported data. Check console for details.");
      });
    } catch (logicErr) {
      console.error("LOGIC ERROR during import (file):", logicErr);
      alert("JSON was valid, but the app crashed trying to load it. Check console.");
    }
  };

  r.readAsText(f);
  ev.target.value = "";
}

function importPaste(){
  const txt = prompt("Paste TaskPoints JSON:");
  if (!txt) return;

  let data;
  // 1) Parse stage
  try {
    data = JSON.parse(txt);
    console.log("JSON parsed OK (paste):", data);
  } catch (err) {
    console.error("ACTUAL PARSE ERROR (paste):", err);
    alert("The text is not valid JSON. Check console for details.");
    return;
  }

  // 2) App logic stage
  try {
    const root =
      (data && Array.isArray(data.tasks) && Array.isArray(data.completions)) ? data :
      (data && data.state && Array.isArray(data.state.tasks) && Array.isArray(data.state.completions)) ? data.state :
      null;

    if (!root) {
      throw new Error("Root object missing tasks/completions arrays");
    }

    applyImportedState(root).catch((err) => {
      console.error("Failed to apply imported state (paste):", err);
      alert("Failed to apply imported data. Check console for details.");
    });
  } catch (logicErr) {
    console.error("LOGIC ERROR during import (paste):", logicErr);
    alert("JSON was valid, but the app crashed trying to load it. Check console.");
  }
}


/* ---------- RENDER/WIRE ---------- */
function renderAll() {
  const perfLabel = window.TP_DEBUG_PERF ? 'renderAll' : null;
  if (perfLabel) console.time(perfLabel);
  try {
    try { renderStats(); } catch (e) { console.error('renderStats error:', e); }
    try { renderTasks(); } catch (e) { console.error('renderTasks error:', e); }

    const defer = window.requestIdleCallback
      ? window.requestIdleCallback
      : (cb) => setTimeout(() => cb({ timeRemaining: () => 0 }), 200);
    defer(() => {
      try { renderSleepHistory(); } catch (e) { console.error('renderSleepHistory error:', e); }
      try { renderCaloriesHistory(); } catch (e) { console.error('renderCaloriesHistory error:', e); }
      try { renderWorkHistory(); } catch (e) { console.error('renderWorkHistory error:', e); }
      try { renderMoodHistory(); } catch (e) { console.error('renderMoodHistory error:', e); }
    });
  } finally {
    if (perfLabel) console.timeEnd(perfLabel);
  }
}


function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#039;'}[m])); }

document.addEventListener('DOMContentLoaded', () => {
  $('addBtn')?.addEventListener('click', addTask);
  $('openAddTaskBtn')?.addEventListener('click', openAddTaskModal);
  $('sortSelect')?.addEventListener('change', renderTasks);
  $('resetBtn')?.addEventListener('click', resetAll);
  $('addHabitBtn')?.addEventListener('click', openHabitModal);
  $('addViceBtn')?.addEventListener('click', openViceModal);
  $('addFlexBtn')?.addEventListener('click', addFlexAction);
  $('saveSleepScoreBtn')?.addEventListener('click', saveSleepScore);
  $('addHabitModal')?.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeHabitModal();
  });
  ['habitName', 'habitTag', 'habitPts'].forEach(id => {
    $(id)?.addEventListener('keydown', e => {
      if (e.key === 'Enter') addHabit();
    });
  });
  $('addViceModal')?.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeViceModal();
  });
  ['viceName', 'viceTag', 'vicePts'].forEach(id => {
    $(id)?.addEventListener('keydown', e => {
      if (e.key === 'Enter') addVice();
    });
  });
  $('sleepEditModal')?.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeSleepEditModal();
  });
  ['sleepEditScoreInput','sleepEditRestedInput'].forEach(id => {
    $(id)?.addEventListener('keydown', e => {
      if (e.key === 'Enter') submitSleepEditModal();
    });
  });
  $('workEditModal')?.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeWorkEditModal();
  });
  ['workEditScoreInput','workEditHoursInput'].forEach(id => {
    $(id)?.addEventListener('keydown', e => {
      if (e.key === 'Enter') submitWorkEditModal();
    });
  });
  $('saveCaloriesBtn')?.addEventListener('click', saveCalories);
  $('saveWorkScoreBtn')?.addEventListener('click', saveWorkScore);
  $('saveMoodScoreBtn')?.addEventListener('click', saveMoodScore);

  const rep = $("repeatInput");
  rep?.addEventListener("change", () => syncCustomRepeatUI(rep));
  rep?.addEventListener("input",  () => syncCustomRepeatUI(rep)); // extra iOS safety
  syncCustomRepeatUI(rep); // sync once at load
  
  initCaloriesDatePicker();
  initHabitSortControl();
  renderHabitWeekLabels();
  renderViceWeekLabels();
  renderHabits();
  renderVices();
  renderFlexActions();

  maybeAutoSimToday();
  state = syncStateWithMatchups(state);

console.log('TaskPoints main state summary:', {
  tasks:       Array.isArray(state.tasks)       ? state.tasks.length       : 'no array',
  completions: Array.isArray(state.completions) ? state.completions.length : 'no array',
  habits:      Array.isArray(state.habits)      ? state.habits.length      : 'no array',
  flexActions: Array.isArray(state.flexActions) ? state.flexActions.length : 'no array',
  players:     Array.isArray(state.players)     ? state.players.length     : 'no array',
  gameHistory: Array.isArray(state.gameHistory) ? state.gameHistory.length : 'no array'
});

  scheduleRender(renderAll);
  startOpponentDripTicker();
  initTaskListDelegation();

  if (window.TP_DEBUG_PERF) {
    requestAnimationFrame(() => {
      const elapsed = performance.now() - bootStart;
      console.log(`[TP_PERF] boot->first-render: ${elapsed.toFixed(1)}ms`);
    });
  }
});


function syncCustomRepeatUI(repeatSelectEl) {
  const row = document.getElementById('repeatCustomRow');
  if (!row || !repeatSelectEl) return;

  if (repeatSelectEl.value === 'custom') row.classList.remove('hidden');
  else row.classList.add('hidden');
}

// Event delegation: works even if the Add Task UI is injected/moved for mobile modal
document.addEventListener('change', (e) => {
  const t = e.target;
  if (t && t.id === 'repeatInput') {
    syncCustomRepeatUI(t);
  }
});

</script>

<!-- EDIT SLEEP ENTRY MODAL -->
  <div
    id="sleepEditModal"
  class="fixed inset-0 z-40 hidden items-center justify-center bg-black/60"
  onclick="closeSleepEditModal()"
>
  <div
    id="sleepEditModalBody"
    class="w-full max-w-sm mx-3 rounded-2xl px-4 pb-5 pt-8 relative bg-zinc-900 text-zinc-100 text-sm"
    onclick="event.stopPropagation();"
  >
    <button
      type="button"
      class="absolute top-3 right-3 btn btn-secondary text-[11px] px-3 py-1 rounded-md"
      onclick="closeSleepEditModal()"
    >
      Close
    </button>

    <div class="flex items-start justify-between gap-3 mb-4">
      <div>
        <div class="muted text-[11px] uppercase tracking-wide">Edit Sleep</div>
        <div id="sleepEditDateLabel" class="text-base font-semibold leading-tight"></div>
      </div>
      <div class="text-2xl">üõå</div>
    </div>

    <label class="grid gap-1 text-sm font-medium">
      Sleep score (0‚Äì100)
      <input id="sleepEditScoreInput" type="number" min="0" max="100" class="input" placeholder="e.g., 95">
    </label>

    <label class="grid gap-1 text-sm font-medium mt-3">
      Rested modifier (can be negative)
      <input id="sleepEditRestedInput" type="number" class="input" placeholder="e.g., 1">
    </label>

    <div class="flex justify-end gap-2 mt-6">
      <button type="button" class="btn btn-secondary" onclick="closeSleepEditModal()">Cancel</button>
      <button type="button" id="sleepEditSaveBtn" class="btn btn-primary" onclick="submitSleepEditModal()">Save</button>
    </div>
  </div>
</div>

<!-- EDIT WORK ENTRY MODAL -->
  <div
    id="workEditModal"
  class="fixed inset-0 z-40 hidden items-center justify-center bg-black/60"
  onclick="closeWorkEditModal()"
>
  <div
    id="workEditModalBody"
    class="w-full max-w-sm mx-3 rounded-2xl px-4 pb-5 pt-8 relative bg-zinc-900 text-zinc-100 text-sm"
    onclick="event.stopPropagation();"
  >
    <button
      type="button"
      class="absolute top-3 right-3 btn btn-secondary text-[11px] px-3 py-1 rounded-md"
      onclick="closeWorkEditModal()"
    >
      Close
    </button>

    <div class="flex items-start justify-between gap-3 mb-4">
      <div>
        <div class="muted text-[11px] uppercase tracking-wide">Edit Work</div>
        <div id="workEditDateLabel" class="text-base font-semibold leading-tight"></div>
      </div>
      <div class="text-2xl">üíº</div>
    </div>

    <label class="grid gap-1 text-sm font-medium">
      Work score
      <input id="workEditScoreInput" type="number" class="input" placeholder="e.g., 5">
    </label>

    <label class="grid gap-1 text-sm font-medium mt-3">
      Hours (/100, negatives become 0)
      <input id="workEditHoursInput" type="number" class="input" placeholder="e.g., 0.25">
    </label>

    <div class="flex justify-end gap-2 mt-6">
      <button type="button" class="btn btn-secondary" onclick="closeWorkEditModal()">Cancel</button>
      <button type="button" id="workEditSaveBtn" class="btn btn-primary" onclick="submitWorkEditModal()">Save</button>
    </div>
  </div>
</div>

<!-- ADD HABIT MODAL -->
<div
  id="addHabitModal"
  class="fixed inset-0 z-40 hidden items-center justify-center bg-black/60"
  onclick="closeHabitModal()"
>
  <div
    class="w-full max-w-sm mx-3 rounded-2xl px-4 pb-5 pt-8 relative bg-zinc-900 text-zinc-100 text-sm"
    onclick="event.stopPropagation();"
  >
    <button
      type="button"
      class="absolute top-3 right-3 btn btn-secondary text-[11px] px-3 py-1 rounded-md"
      onclick="closeHabitModal()"
    >
      Close
    </button>

    <div class="flex items-start justify-between gap-3 mb-4">
      <div>
        <div class="muted text-[11px] uppercase tracking-wide">New Habit</div>
        <div class="text-base font-semibold leading-tight">Create a habit</div>
      </div>
      <div class="text-2xl">‚ú®</div>
    </div>

    <label class="grid gap-1 text-sm font-medium">
      Habit name
      <input id="habitName" class="input" placeholder="Habit name">
    </label>

    <label class="grid gap-1 text-sm font-medium mt-3">
      Tag
      <input id="habitTag" class="input" placeholder="Tag">
    </label>

    <label class="grid gap-1 text-sm font-medium mt-3">
      Points
      <input id="habitPts" class="input" type="number" placeholder="Pts">
    </label>

    <div class="flex justify-end gap-2 mt-6">
      <button type="button" class="btn btn-secondary" onclick="closeHabitModal()">Cancel</button>
      <button type="button" id="confirmHabitBtn" class="btn btn-primary" onclick="addHabit()">Confirm</button>
    </div>
  </div>
</div>

<!-- ADD VICE MODAL -->
<div
  id="addViceModal"
  class="fixed inset-0 z-40 hidden items-center justify-center bg-black/60"
  onclick="closeViceModal()"
>
  <div
    class="w-full max-w-sm mx-3 rounded-2xl px-4 pb-5 pt-8 relative bg-zinc-900 text-zinc-100 text-sm"
    onclick="event.stopPropagation();"
  >
    <button
      type="button"
      class="absolute top-3 right-3 btn btn-secondary text-[11px] px-3 py-1 rounded-md"
      onclick="closeViceModal()"
    >
      Close
    </button>

    <div class="flex items-start justify-between gap-3 mb-4">
      <div>
        <div class="muted text-[11px] uppercase tracking-wide">New Vice</div>
        <div class="text-base font-semibold leading-tight">Create a vice</div>
      </div>
      <div class="text-2xl">‚ö°</div>
    </div>

    <label class="grid gap-1 text-sm font-medium">
      Vice name
      <input id="viceName" class="input" placeholder="Vice name">
    </label>

    <label class="grid gap-1 text-sm font-medium mt-3">
      Tag
      <input id="viceTag" class="input" placeholder="Tag">
    </label>

    <label class="grid gap-1 text-sm font-medium mt-3">
      Points
      <input id="vicePts" class="input" type="number" placeholder="Pts">
    </label>

    <div class="flex justify-end gap-2 mt-6">
      <button type="button" class="btn btn-secondary" onclick="closeViceModal()">Cancel</button>
      <button type="button" id="confirmViceBtn" class="btn btn-primary" onclick="addVice()">Confirm</button>
    </div>
  </div>
</div>

<!-- DESKTOP-ONLY ADD TASK MODAL -->
<div
  id="addTaskModal"
  class="fixed inset-0 z-40 hidden items-center justify-center bg-black/60"
>
  <div class="addTaskModalPanel w-full max-w-xl mx-4 rounded-2xl px-6 pb-6 pt-12 relative bg-zinc-900 text-zinc-100">
<button
  type="button"
  class="absolute top-4 right-4 btn btn-secondary text-xs px-3 py-1 rounded-md"
  onclick="closeAddTaskModal()"
>
  Close
</button>




    <div id="addTaskModalBody" class="grid gap-3">
      <!-- Row 1: task title -->
      <input id="titleInput" class="input" placeholder="e.g., 30-min treadmill walk">

      <!-- Row 2: priority + due date + Today -->
      <div id="addTaskRow2" class="flex flex-wrap gap-2 mt-1">
        <select id="importanceInput" class="input flex-1 min-w-[120px]">
          <option>Low</option>
          <option selected>Medium</option>
          <option>High</option>
          <option>Critical</option>
        </select>

        <input id="dueDateInput" type="date" class="input flex-1 min-w-[120px]">

        <button class="addTaskTodayBtn btn btn-ghost text-xs px-2" onclick="setDueToday()">Today</button>
      </div>

      <!-- Row 3: points + repeat rule -->
      <div id="addTaskRow3" class="flex flex-wrap gap-2 mt-1">
        <input id="pointsInput" type="number" min="0" class="input w-24" placeholder="e.g., 25">

        <select id="repeatInput" class="input flex-1 min-w-[120px]">
          <option value="none">Does not repeat</option>
          <option value="daily">Every day</option>
          <option value="weekdays">Weekdays (Mon‚ÄìFri)</option>
          <option value="weekly">Every week</option>
          <option value="monthly">Every month (same date)</option>
          <option value="yearly">Every year (same date)</option>
          <option value="custom">Custom‚Ä¶</option>
        </select>
      </div>

      <!-- Custom repeat controls (hidden unless "Custom" selected) -->
      <div id="repeatCustomRow" class="flex items-center gap-2 text-xs mt-2 hidden">
        <span class="muted">Repeat every</span>
        <input id="repeatCustomCount" type="number" min="1" class="input w-16" value="1">
        <select id="repeatCustomUnit" class="input w-24">
          <option value="day">day(s)</option>
          <option value="week">week(s)</option>
          <option value="month">month(s)</option>
          <option value="year">year(s)</option>
        </select>
      </div>

      <!-- ‚úÖ Row 4: tags -->
      <input
        id="tagsInput"
        class="input"
        placeholder="Tags (e.g., work, coding, creative)"
      >

      <button id="addBtn" class="btn btn-primary">Add Task</button>
    </div>
  </div>
</div>


<!-- MOBILE SCROLL-TO-TOP BUTTON -->
<button
  id="scrollTopBtn"
  class="hidden md:hidden fixed top-3 right-3 z-40 btn btn-teal rounded-full shadow-lg px-4 py-2 text-sm flex items-center gap-1"
  type="button"
  data-scroll-top
>
  <span>‚¨ÜÔ∏è</span>
  <span>Top</span>
</button>

<div id="bottomToolbarMount"></div>

<script>
  (() => {
    const toggles = document.querySelectorAll('.recent-toggle');

    toggles.forEach((toggle) => {
      const targetId = toggle.dataset.target;
      const target = targetId ? document.getElementById(targetId) : null;
      if (!target) return;

      const updateState = () => {
        const isHidden = target.classList.contains('hidden');
        toggle.setAttribute('aria-expanded', String(!isHidden));
        toggle.textContent = isHidden ? 'Show' : 'Hide';
      };

      toggle.addEventListener('click', () => {
        target.classList.toggle('hidden');
        updateState();
      });

      updateState();
    });
  })();
</script>


<script>
  (() => {
    const nav = document.getElementById('mobileBottomNav');
    const isMobile = window.matchMedia('(max-width: 768px)');
    let rafId = null;
    let resizeTimer = null;

    // Only run on browsers that expose the visual viewport (mobile Safari/Chrome)
    if (!nav || !window.visualViewport) return;

    function updateNavOffset() {
      // Skip adjustments on desktop sizes
      if (!isMobile.matches) {
        nav.style.transform = '';
        return;
      }

      const vv = window.visualViewport;

      // When the mobile keyboard opens, visualViewport.height shrinks.
      // Using only the height delta keeps the bar anchored even while the
      // viewport is scrolled (offsetTop can fluctuate as you pan around).
      const layoutHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
      const keyboardLift = Math.max(0, layoutHeight - vv.height);

      if (keyboardLift > 0) {
        // Translate the bar downward by the keyboard height so it stays docked at the page bottom
        nav.style.transform = `translateY(${keyboardLift}px)`;
      } else {
        nav.style.transform = '';
      }
    }

    function scheduleNavUpdate() {
      if (rafId) return;
      rafId = requestAnimationFrame(() => {
        rafId = null;
        updateNavOffset();
      });
    }

    function scheduleNavResize() {
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateNavOffset, 250);
    }

    window.visualViewport.addEventListener('resize', scheduleNavResize);
    window.visualViewport.addEventListener('scroll', scheduleNavUpdate, { passive: true });
    window.addEventListener('orientationchange', scheduleNavResize);

    updateNavOffset();
  })();
</script>


</body>
</html>
