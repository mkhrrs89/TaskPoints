<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TaskPoints ‚Äî To-Do + Points Tracker</title>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="default"/>
  <meta name="apple-mobile-web-app-title" content="TaskPoints"/>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='48' fill='%230b0d10'/><text x='50' y='62' font-size='60' text-anchor='middle' fill='white'>TP</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Teko:wght@500;600;700&display=swap">
  <script src="scoring_core.js"></script>

<link rel="stylesheet" href="styles.css">
<script src="toolbar.js" defer></script>


</head>
<body class="min-h-screen">
<div id="pointsToastContainer" class="points-toast-container"></div>
<div class="mx-auto max-w-6xl p-4 sm:p-6 pb-20 md:pb-6">


  <!-- HEADER -->
  <header class="mb-4">
    <div class="flex items-center justify-between gap-3 mb-3 md:hidden">
      <a href="index.html" class="flex items-center gap-3">
        <img src="assets/taskpoints-logo.png" alt="TaskPoints logo" class="w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm">
<h1 class="text-2xl font-extrabold tracking-tight leading-tight">
  <span style="color:#fb923c;">Task</span><span style="color:#1e666d;">Points</span>
</h1>

      </a>

      <div class="flex items-center gap-2">
        <button id="exportBtnMobile" type="button" class="btn btn-ghost btn-toolbar" data-export-button>Export</button>
        <label class="btn btn-ghost btn-toolbar cursor-pointer">
          <span>Import</span>
          <input id="importInputMobile" type="file" accept="application/json" class="hidden" data-import-input/>
        </label>
      </div>
    </div>

    <div class="row items-center">
      <div class="hidden md:flex items-center gap-3">
        <img src="assets/taskpoints-logo.png" alt="TaskPoints logo" class="w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm">
<h1 class="text-2xl sm:text-3xl font-extrabold tracking-tight">
  <span style="color:#fb923c;">Task</span><span style="color:#1e666d;">Points</span>
</h1>

      </div>

<div class="toolbar header-nav">
  <button id="exportBtn" class="btn btn-ghost btn-toolbar hidden md:inline-flex" data-export-button>Export</button>
  <label class="btn btn-ghost btn-toolbar cursor-pointer hidden md:inline-flex">Import
    <input id="importInput" type="file" accept="application/json" class="hidden" data-import-input/>
  </label>

  <a href="index.html"         class="btn btn-teal btn-toolbar nav-btn active" aria-current="page">Main</a>
  <a href="daily_sources.html" class="btn btn-teal btn-toolbar nav-btn">Sources</a>
  <a href="log.html"           class="btn btn-teal btn-toolbar nav-btn">Log</a>
  <a href="week.html"          class="btn btn-teal btn-toolbar nav-btn">Week</a>
  <div class="dropdown">
    <button type="button" class="btn btn-teal btn-toolbar nav-btn dropdown-toggle" data-dropdown-toggle aria-expanded="false">Game <span class="caret">‚ñæ</span></button>
    <div class="dropdown-menu">
      <a href="game.html"         class="btn btn-teal btn-toolbar nav-btn">Players</a>
      <a href="standings.html"    class="btn btn-teal btn-toolbar nav-btn">Standings</a>
      <a href="matchups.html"     class="btn btn-teal btn-toolbar nav-btn">Matchups</a>
      <a href="schedule.html"     class="btn btn-teal btn-toolbar nav-btn">Schedule</a>
      <a href="game_ratings.html" class="btn btn-teal btn-toolbar nav-btn">Ratings</a>
      <a href="records.html"      class="btn btn-teal btn-toolbar nav-btn">Records</a>
    </div>
  </div>
  <a href="projects.html" class="btn btn-teal btn-toolbar nav-btn">Projects</a>
  <a href="settings.html" class="btn btn-teal btn-toolbar nav-btn">Settings</a>

</div>

    </div>
  </header>

  <!-- TOP ROW -->
  <div class="space-y-3 mb-6">
    <div class="grid gap-3 grid-cols-1 sm:grid-cols-2 lg:grid-cols-[2fr_1fr]">
      <!-- Scoreboard card (expanded) -->
      <div class="glass sm:col-span-2 lg:col-span-1">
        <div class="matchup-scoreboard mt-3">
          <div class="scoreboard-side">
            <div class="muted text-[11px] uppercase tracking-wide">You</div>
            <div id="matchupYourName" class="scoreboard-name">You</div>
            <div id="matchupYourScore" class="scoreboard-score">‚Äî</div>
            <div id="matchupYourRecord" class="scoreboard-record">Record: 0-0</div>
            <div id="matchupYourAverages" class="scoreboard-meta">Daily Avg: ‚Äî ¬∑ PPD: ‚Äî</div>
          </div>

          <div class="scoreboard-diff text-center">
            <div class="muted text-[11px] uppercase tracking-wide">The Diff</div>
            <div id="matchupDiffValue" class="scoreboard-diff-value">‚Äî</div>
            <div id="matchupDiff" class="muted text-xs mt-1">‚Äî</div>
          </div>

          <div class="scoreboard-side text-right">
            <div class="muted text-[11px] uppercase tracking-wide">Opponent</div>
            <div id="matchupOpponent" class="scoreboard-name text-right">‚Äî</div>
            <div id="matchupOpponentScore" class="scoreboard-score">‚Äî</div>
            <div id="matchupOpponentRecord" class="scoreboard-record">Record: 0-0</div>
            <div id="matchupOpponentAverages" class="scoreboard-meta text-right">Daily Avg: ‚Äî ¬∑ PPD: ‚Äî</div>
          </div>
        </div>
      </div>

      <!-- Controls card (right) -->
      <div class="glass sm:col-span-2 lg:col-span-1" id="matchupCard">
        <div class="flex items-start justify-end">
          <div class="flex flex-col gap-2 w-full sm:w-auto sm:flex-row lg:flex-col lg:w-auto">
            <button
              id="todayPointsAddTaskBtn"
              type="button"
              class="btn btn-teal w-full sm:w-auto"
              onclick="toggleAddTask()"
            >
              Add Task
            </button>
            <button
              type="button"
              class="btn btn-teal w-full sm:w-auto"
              onclick="scrollToTasks()"
            >
              Jump to Tasks
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="grid gap-3 grid-cols-1 lg:grid-cols-[0.7fr_1.3fr]">
      <div class="glass flex flex-col items-center justify-center text-center gap-1.5">
        <div class="muted font-semibold uppercase tracking-wide text-[10px]">Inertia Score</div>
        <div class="text-4xl font-extrabold" id="inertiaValue">0.0</div>
        <div class="muted text-[11px] leading-tight" id="inertiaAverage">7-day avg: 0.0</div>
      </div>

      <!-- Daily line graph -->
      <div class="glass flex items-end">
        <canvas id="dailyTrend" class="w-full h-24"></canvas>
      </div>
    </div>
  </div>
  <!-- TOP ROW END -->

  <!-- TODAY'S POINTS BREAKDOWN BAR -->
  <div class="mb-6">
    <div class="flex items-center justify-between mb-1 text-[11px] muted">
      <span>Today‚Äôs Points Breakdown</span>
      <span id="todayBreakdownSummary" class="text-[11px]"></span>
    </div>
    <div class="today-breakdown-bar">
      <div id="todayBreakdownBar" class="h-full flex"></div>
    </div>
  </div>

  <!-- LEADERBOARDS -->
  <div class="grid sm:grid-cols-3 gap-3 mb-6">
    <div class="glass">
      <h3 class="font-semibold mb-2">üèÜ Best Days</h3>
      <ul id="dailyBoard" class="text-xs space-y-1"></ul>
    </div>
    <div class="glass">
      <h3 class="font-semibold mb-2">üèÜ Best Weeks</h3>
      <ul id="weeklyBoard" class="text-xs space-y-1"></ul>
    </div>
    <div class="glass">
      <h3 class="font-semibold mb-2">üèÜ Best Months</h3>
      <ul id="monthlyBoard" class="text-xs space-y-1"></ul>
    </div>
  </div>

<!-- SLEEP + CALORIES -->
<div class="grid sm:grid-cols-2 gap-3 mb-6">
  <!-- LEFT: Sleep Score (existing content) -->
  <div class="glass">
    <div class="flex items-stretch justify-between gap-6 flex-wrap stat-card-row">
      <!-- LEFT: Big stat + input -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-primary">
        <div class="sleep-today-card">
          <div class="stat-mobile-header">
<div class="stat-compact-row">
  <div class="sleep-title-stack">
    <h2 id="sleepAnchor" class="font-bold text-base sm:text-lg stat-title">Sleep Score</h2>
    <!-- Mobile-only: line under the title -->
    <div id="sleepImpactBelow" class="sleep-impact-below hidden"></div>
  </div>

  <div class="stat-compact-controls">
    <div id="sleepInputRow" class="stat-input-row flex items-center gap-2 flex-wrap">
      <input id="sleepScoreInput" class="input w-24 scoreInput" type="number" placeholder="0‚Äì100">
      <input id="sleepRestedInput" class="input w-24 scoreInput" type="number" placeholder="Rested">
      <button id="saveSleepScoreBtn" class="btn btn-plum">Add</button>
    </div>

    <!-- Mobile-only: right side summary (score + rest chip) -->
    <div id="sleepSummaryRow" class="stat-summary-row hidden" aria-live="polite">
      <span id="sleepSummaryValue" class="stat-summary-value"></span>
      <div id="sleepSummaryRest" class="sleep-rest-chip hidden">
        <span id="sleepSummaryRestValue"></span>
      </div>
    </div>
  </div>
</div>


  <div class="stat-compact-meta">
    <div class="muted text-xs">Today‚Äôs Sleep</div>
    <div class="flex items-center gap-2 flex-wrap">
      <div class="flex items-baseline gap-2">
        <div id="sleepTodayValue" class="text-4xl font-extrabold leading-tight stat-value">‚Äî</div>
        <div id="sleepTodayRest" class="sleep-rest-chip hidden"><span id="sleepTodayRestValue"></span></div>
      </div>
    </div>
    <div id="sleepTodayImpact" class="muted text-xs mt-1 stat-impact">Adds 0 pts to today</div>
  </div>
</div>
</div>
</div>
      <!-- RIGHT: History chips -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-secondary">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-semibold text-sm">Recent nights</h3>
        </div>
        <div class="recentWrap">
  <div id="sleepHistory" class="recentRow"></div>
</div>

      </div>
    </div>
  </div>

  <!-- RIGHT: Calories card -->
<div class="glass calories-glass">
  <div class="flex items-stretch justify-between gap-6 flex-wrap stat-card-row">
      <!-- LEFT: Big stat + input -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-primary">
        <div class="calories-today-card">
          <div class="stat-mobile-header">
<div class="stat-compact-row">
  <div class="cal-title-stack">
    <h2 class="font-bold text-lg stat-title">Calories</h2>
    <div id="caloriesImpactBelow" class="cal-impact-below hidden"></div>
  </div>

  <div class="stat-compact-controls">
    <div id="caloriesInputRow" class="stat-input-row caloriesEntryRow flex items-center gap-2 flex-nowrap">
      <input id="caloriesInput" class="input w-24" type="number" placeholder="0‚Äì3000">

      <div class="datePickWrap" title="Pick date">
        <button class="btn date-trigger dateTriggerBtn" type="button" aria-hidden="true" tabindex="-1">
          <!-- your svg stays the same -->
        </button>
        <input id="caloriesDate" class="dateOverlay" type="date" aria-label="Pick a date for this calorie entry">
      </div>

      <button id="saveCaloriesBtn" class="btn btn-teal">Add</button>
    </div>

    <div id="caloriesSummaryRow" class="stat-summary-row hidden" aria-live="polite">
      <span id="caloriesSummaryValue" class="stat-summary-value"></span>
    </div>
  </div>
</div>


<!-- Mobile-only: second line under the title -->
<div id="caloriesImpactBelow" class="cal-impact-below hidden"></div>

              </div>
            </div>

            <div class="stat-compact-meta">
              <div class="muted text-xs">Today‚Äôs Calories</div>
              <div id="caloriesTodayValue" class="text-4xl font-extrabold leading-tight stat-value">‚Äî</div>
              <div id="caloriesTodayImpact" class="muted text-xs mt-1 stat-impact">Adds 0 pts to today</div>
              <div id="caloriesDateLabel" class="datePill"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT: History chips -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-secondary">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-semibold text-sm">Recent days</h3>
        </div>
        <div class="recentWrap">
  <div id="caloriesHistory" class="recentRow"></div>
</div>

      </div>
    </div>
  </div>
</div> <!-- end of SLEEP + CALORIES block -->

<!-- WORK SCORE + BLANK -->
<div class="grid sm:grid-cols-2 gap-3 mb-6">

  <!-- LEFT: Work Score -->
  <div class="glass">
    <div class="flex items-stretch justify-between gap-6 flex-wrap stat-card-row">

      <!-- LEFT SIDE: big stat + input -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-primary">
        <div class="work-today-card">
          <div class="stat-mobile-header">
            <div class="stat-compact-row">
              <h2 id="workAnchor" class="font-bold text-lg stat-title">Work Score</h2>
              <div class="stat-compact-controls">
<div id="workInputRow" class="stat-input-row flex items-center gap-2 flex-wrap sm:flex-nowrap">
  <input id="workScoreInput" class="input w-24 scoreInput" type="number" placeholder="0‚Äì10">
  <input id="workHoursInput" class="input w-24 scoreInput" type="number" placeholder="Hours">
  <button id="saveWorkScoreBtn" class="btn btn-work">Add</button>
</div>
              </div>
            </div>

            <div class="stat-compact-meta">
              <div class="muted text-xs">Today‚Äôs Work</div>
              <div class="flex items-center gap-2 flex-wrap">
                <div class="flex items-baseline gap-2">
                  <div id="workTodayValue" class="text-4xl font-extrabold leading-tight stat-value">‚Äî</div>
                  <div id="workTodayHours" class="work-hours-chip hidden"><span id="workTodayHoursValue"></span></div>
                </div>
              </div>
              <div id="workTodayImpact" class="muted text-xs mt-1 stat-impact">Adds 0 pts to today</div>
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT SIDE: history chips -->
      <div class="flex-1 min-w-[220px] stat-col stat-col-secondary">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-semibold text-sm">Recent days</h3>
        </div>
        <div class="recentWrap">
  <div id="workHistory" class="recentRow"></div>
</div>

      </div>

    </div>
  </div>

<!-- RIGHT: Mood Score -->
<div class="glass">
    <div class="flex items-stretch justify-between gap-6 flex-wrap stat-card-row">

    <!-- LEFT SIDE: big stat + input -->
    <div class="flex-1 min-w-[220px] stat-col stat-col-primary">
      <div class="mood-today-card">
        <div class="stat-mobile-header">
          <div class="stat-compact-row">
            <h2 id="moodAnchor" class="font-bold text-lg stat-title">Mood Score</h2>
            <div class="stat-compact-controls">
<div id="moodInputRow" class="stat-input-row flex items-center gap-2 flex-wrap sm:flex-nowrap">
  <input id="moodScoreInput" class="input w-24 scoreInput" type="number" placeholder="0‚Äì10">
  <button id="saveMoodScoreBtn" type="button" class="btn btn-mood">Add</button>
</div>
            </div>
          </div>

          <div class="stat-compact-meta">
            <div class="muted text-xs">Today‚Äôs Mood</div>
            <div id="moodTodayValue" class="text-4xl font-extrabold leading-tight stat-value">‚Äî</div>
            <div id="moodTodayImpact" class="muted text-xs mt-1 stat-impact">Adds 0 pts to today</div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT SIDE: history chips -->
    <div class="flex-1 min-w-[220px] stat-col stat-col-secondary">
      <div class="flex items-center justify-between mb-2">
        <h3 class="font-semibold text-sm">Recent days</h3>
      </div>
      <div class="recentWrap">
  <div id="moodHistory" class="recentRow"></div>
</div>

    </div>

  </div>
</div>


</div>



  <!-- HABITS -->
<div class="glass mb-6">
  <div class="flex items-center justify-between mb-3 gap-3 flex-wrap">
    <div class="flex items-center gap-3 flex-wrap">
      <h2 id="habitsAnchor" class="font-bold text-lg">Habits</h2>

      <select id="habitsSortSelect" class="input w-44">
        <option value="custom">Custom</option>
        <option value="points">Point value</option>
        <option value="streak">Current streak</option>
        <option value="completion">% completion</option>
      </select>
    </div>

    <div class="flex gap-2 flex-wrap">
      <input id="habitName" class="input w-48" placeholder="Habit name">
      <input id="habitPts"  class="input w-28" type="number" placeholder="Pts">
      <button id="addHabitBtn" class="btn btn-primary">Add Habit</button>
    </div>
  </div>

  <div class="grid gap-2 text-sm muted mb-2" id="habitWeekLabels"></div>
  <div id="habitsList" class="grid gap-2"></div>
  <div id="habitsEmpty" class="text-sm muted hidden">No habits yet.</div>
</div>

<!-- VICES -->
<div class="glass mb-6">
  <div class="flex items-center justify-between mb-3 gap-3 flex-wrap">
    <h2 id="vicesAnchor" class="font-bold text-lg">Vices</h2>
    <div class="flex gap-2 flex-wrap">
      <input id="viceName" class="input w-48" placeholder="Vice name">
      <input id="vicePts"  class="input w-28" type="number" placeholder="Pts">
      <button id="addViceBtn" class="btn btn-primary">Add Vice</button>
    </div>
  </div>
  <div class="grid gap-2 text-sm muted mb-2" id="viceWeekLabels"></div>
  <div id="vicesList" class="grid gap-2"></div>
  <div id="vicesEmpty" class="text-sm muted hidden">No vices yet.</div>
</div>

  <!-- FLEX ACTIONS -->
  <div class="glass mb-6">
    <div class="flex items-center justify-between mb-3 gap-3 flex-wrap">
      <h2 id="flexAnchor" class="font-bold text-lg">Flex Actions</h2>
      <div class="flex gap-2 flex-wrap">
        <input id="flexName" class="input w-48" placeholder="Flex action">
        <input id="flexPts"  class="input w-28" type="number" step="any" placeholder="Pts/use">
        <button id="addFlexBtn" class="btn btn-primary">Add</button>
      </div>
    </div>
    <div id="flexList" class="grid gap-2 text-sm"></div>
    <div id="flexEmpty" class="text-sm muted hidden">No flex actions yet.</div>
  </div>

  <!-- TASKS grouped by day -->
  <div class="glass mb-6">
    <div class="flex justify-between items-center mb-3 gap-3 flex-wrap">
     <div class="flex items-center gap-3 flex-wrap">
       <h2 id="tasksAnchor" class="font-bold text-lg">Your Tasks</h2>
       <button id="openAddTaskBtn" class="btn btn-primary">Add Task</button>
     </div>
      <select id="sortSelect" class="input w-48">
        <option value="due">Sort by Due Date</option>
        <option value="importance">Sort by Importance</option>
        <option value="points">Sort by Points</option>
        <option value="alpha">Sort by Name</option>
      </select>
    </div>
    <div id="taskList" class="grid gap-2"></div>
    <div id="emptyList" class="text-sm muted hidden">No tasks yet.</div>
  </div>

  <footer class="mt-10 flex items-center justify-between">
    <p>Tip: On iPhone Safari ‚Üí <b>Add to Home Screen</b> for an app-like experience.</p>
    <p>v0.24.2 ‚Äî 2025-11-18</p>
  </footer>
</div>

<script>
const STORAGE_KEY="taskpoints_v1";
const OLD_PLAYERS_KEY="taskpoints_players";
const PROJECTS_STORAGE_KEY="tp_projects_v1";
const $=id=>document.getElementById(id);
let state=normalizeState(load());
state = syncStateWithMatchups(state);
  const HABITS_SORT_KEY = "taskpoints_habits_sort";

function normalizeTask(task){
  if(!task || typeof task !== 'object') return task;
  const t = { ...task };
  if (typeof t.postponedDays !== 'number' || Number.isNaN(t.postponedDays)) {
    t.postponedDays = 0;
  }
  if (!t.originalDueDateISO && t.dueDateISO) {
    t.originalDueDateISO = t.dueDateISO;
  }
  return t;
}

function getHabitSortMode(){
  return ($('habitsSortSelect')?.value)
    || localStorage.getItem(HABITS_SORT_KEY)
    || 'custom';
}

function initHabitSortControl(){
  const sel = $('habitsSortSelect');
  if(!sel) return;

  const saved = localStorage.getItem(HABITS_SORT_KEY);
  if(saved && Array.from(sel.options).some(o => o.value === saved)){
    sel.value = saved;
  }

  sel.addEventListener('change', () => {
    localStorage.setItem(HABITS_SORT_KEY, sel.value);
    renderHabits();
  });
}

let editingTaskId = null;
let editingHabitId = null;
let editingFlexId = null;


function sleepBonus(score) {
  if (score >= 100) return 3;
  if (score >= 98) return 2;
  if (score >= 95) return 1;
  return 0;
}

function getSleepInfo(entry) {
  const match = entry?.title?.match(/\((\d+)\)/);
  const score = match ? Number(match[1]) : null;

  const restedRaw = entry && Object.prototype.hasOwnProperty.call(entry, 'sleepRested')
    ? Number(entry.sleepRested)
    : 0;
  const rested = Number.isFinite(restedRaw) ? restedRaw : 0;

  return { score, rested };
}

function sleepPoints(score, rested = 0) {
  if (!Number.isFinite(score)) return 0;
  const base  = score / 10;
  const bonus = sleepBonus(score);
  return base + bonus + (Number.isFinite(rested) ? rested : 0);
}

function getWorkInfo(entry) {
  const match = entry?.title?.match(/\(([^)]+)\)/);
  const score = match ? Number(match[1]) : null;

  const hoursRaw = entry && Object.prototype.hasOwnProperty.call(entry, 'workHours')
    ? Number(entry.workHours)
    : 0;
  const hours = Number.isFinite(hoursRaw) ? hoursRaw : 0;

  return { score, hours };
}

function workHoursBonus(hours = 0) {
  if (!Number.isFinite(hours)) return 0;
  return Math.max(0, hours) * 10;
}

function workPoints(score, hours = 0) {
  if (!Number.isFinite(score)) return 0;
  return score + workHoursBonus(hours);
}

function getTodaySleepEntry() {
  const today = new Date();
  const todayKey = dateKey(today);

  for (const entry of state.completions) {
    if (!entry?.title?.startsWith('Sleep Score')) continue;
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayKey) return entry;
  }

  return null;
}

function getTodayCaloriesEntry() {
  const todayKey = dateKey(new Date());
  for (const entry of state.completions) {
    if (!entry?.title?.startsWith('Calories')) continue;
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayKey) return entry;
  }
  return null;
}

function editTodayCalories() {
  const entry = getTodayCaloriesEntry();
  if (!entry) return alert("You haven't entered today's calories yet.");

  const current = entry.title.match(/\((\d+)\)/)?.[1] ?? '';
  const newVal = prompt("Edit today's calories:", String(current));
  if (newVal === null) return; // user cancelled

  const raw = Number(String(newVal).trim());
  if (Number.isNaN(raw) || raw < 0) return alert("Invalid calories.");

  // keep it pinned to *today* so it stays a ‚Äútoday‚Äù entry
  const d = new Date();
  d.setHours(12, 0, 0, 0);

  entry.title = `Calories (${raw})`;
  entry.points = caloriesToPoints(raw);
  entry.completedAtISO = d.toISOString();

  save();
  renderAll();
}

let sleepEditContext = null;

function promptEditSleepEntry(entry) {
  if (!entry) return;

  sleepEditContext = entry;

  const { score, rested } = getSleepInfo(entry);

  const modal = $('sleepEditModal');
  const scoreInput = $('sleepEditScoreInput');
  const restInput  = $('sleepEditRestedInput');
  const dateLabel  = $('sleepEditDateLabel');

  if (!modal || !scoreInput || !restInput) return;

  const scoreDisplay = Number.isFinite(score) ? score : '';
  const restDisplay  = Number.isFinite(rested) ? rested : '';

  scoreInput.value = scoreDisplay;
  restInput.value  = restDisplay;

  if (dateLabel) {
    const date = new Date(entry.completedAtISO);
    dateLabel.textContent = date.toLocaleDateString('en-US', {
      weekday: 'short', month: 'short', day: 'numeric'
    });
  }

  modal.classList.remove('hidden');
  modal.classList.add('flex');

  scoreInput.focus();
  scoreInput.select();
}

function closeSleepEditModal() {
  const modal = $('sleepEditModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.classList.remove('flex');
  sleepEditContext = null;
}

function submitSleepEditModal() {
  if (!sleepEditContext) return closeSleepEditModal();

  const scoreInput = $('sleepEditScoreInput');
  const restInput  = $('sleepEditRestedInput');
  if (!scoreInput || !restInput) return;

  const scoreVal = Number(scoreInput.value);
  if (Number.isNaN(scoreVal) || scoreVal < 0 || scoreVal > 100) {
    alert('Enter a sleep score between 0 and 100.');
    return;
  }

  const restStr = restInput.value.trim();
  const restVal = restStr === '' ? 0 : Number(restStr);
  if (!Number.isFinite(restVal)) {
    alert('Rested value must be a number.');
    return;
  }

  sleepEditContext.title = `Sleep Score (${scoreVal}) ‚Äî Rest ${restVal}`;
  sleepEditContext.points = sleepPoints(scoreVal, restVal);
  sleepEditContext.sleepRested = restVal;

  save();
  renderAll();
  closeSleepEditModal();
}

let workEditContext = null;
let workEditOptions = null;

function promptEditWorkEntry(entry, options = {}) {
  if (!entry) return;

  workEditContext = entry;
  workEditOptions = options;

  const { score, hours } = getWorkInfo(entry);

  const modal = $('workEditModal');
  const scoreInput = $('workEditScoreInput');
  const hoursInput = $('workEditHoursInput');
  const dateLabel = $('workEditDateLabel');

  if (!modal || !scoreInput || !hoursInput) return;

  const scoreDisplay = Number.isFinite(score) ? score : '';
  const hoursDisplay = Number.isFinite(hours) ? hours : '';

  scoreInput.value = scoreDisplay;
  hoursInput.value = hoursDisplay;

  if (dateLabel) {
    const date = new Date(entry.completedAtISO);
    dateLabel.textContent = date.toLocaleDateString('en-US', {
      weekday: 'short', month: 'short', day: 'numeric'
    });
  }

  modal.classList.remove('hidden');
  modal.classList.add('flex');

  scoreInput.focus();
  scoreInput.select();
}

function closeWorkEditModal() {
  const modal = $('workEditModal');
  if (!modal) return;

  modal.classList.add('hidden');
  modal.classList.remove('flex');
  workEditContext = null;
  workEditOptions = null;
}

function submitWorkEditModal() {
  if (!workEditContext) return closeWorkEditModal();

  const scoreInput = $('workEditScoreInput');
  const hoursInput = $('workEditHoursInput');
  if (!scoreInput || !hoursInput) return;

  const scoreVal = Number(scoreInput.value);
  if (Number.isNaN(scoreVal)) {
    alert('Enter a valid work score.');
    return;
  }

  const hoursStr = hoursInput.value.trim();
  const hoursVal = hoursStr === '' ? 0 : Number(hoursStr);
  if (!Number.isFinite(hoursVal)) {
    alert('Hours value must be a number.');
    return;
  }

  const safeHours = Math.max(0, hoursVal);

  const d = new Date(workEditContext.completedAtISO);
  d.setHours(12, 0, 0, 0);

  if (workEditOptions?.pinToToday) {
    const today = new Date();
    today.setHours(12, 0, 0, 0);
    workEditContext.completedAtISO = today.toISOString();
  } else {
    workEditContext.completedAtISO = d.toISOString();
  }

  workEditContext.title = `Work Score (${scoreVal}) ‚Äî Hours ${safeHours}`;
  workEditContext.points = workPoints(scoreVal, safeHours);
  workEditContext.workHours = safeHours;
  workEditContext.source = 'work';

  save();
  renderAll();
  closeWorkEditModal();
}

function migrateSleepEntriesForBonus() {
  if (!state || !Array.isArray(state.completions)) return;

  let changed = false;

  state.completions.forEach(c => {
    if (!c || !c.title || !c.title.startsWith('Sleep Score')) return;

    const { score, rested } = getSleepInfo(c);
    if (!Number.isFinite(score)) return;

    const restVal = Number.isFinite(rested) ? rested : 0;
    const newPts = sleepPoints(score, restVal);

    if (!Number.isFinite(c.sleepRested)) {
      c.sleepRested = restVal;
      changed = true;
    }

    // only update if different, to avoid noisy rewrites
    if (Math.abs((Number(c.points) || 0) - newPts) > 0.0001) {
      c.points = newPts;
      changed = true;
    }
  });

  if (changed) {
    save();
  }
}

migrateSleepEntriesForBonus();

function migrateWorkEntriesForHours() {
  if (!state || !Array.isArray(state.completions)) return;

  let changed = false;

  state.completions.forEach(c => {
    if (!c || !c.title || !c.title.startsWith('Work Score')) return;

    const { score, hours } = getWorkInfo(c);
    const safeHours = Number.isFinite(hours) ? Math.max(0, hours) : 0;
    const safeScore = Number.isFinite(score) ? score : Number(c.points) || 0;
    const newPts = workPoints(safeScore, safeHours);

    if (!Number.isFinite(c.workHours) || c.workHours !== safeHours) {
      c.workHours = safeHours;
      changed = true;
    }

    if (c.source !== 'work') {
      c.source = 'work';
      changed = true;
    }

    const desiredTitle = Number.isFinite(score)
      ? `Work Score (${score}) ‚Äî Hours ${safeHours}`
      : c.title;
    if (desiredTitle !== c.title) {
      c.title = desiredTitle;
      changed = true;
    }

    if (Math.abs((Number(c.points) || 0) - newPts) > 0.0001) {
      c.points = newPts;
      changed = true;
    }
  });

  if (changed) {
    save();
  }
}

migrateWorkEntriesForHours();


function isDesktop() {
  // Tailwind lg breakpoint (1024px) ‚Äì matches your layout
  return window.matchMedia("(min-width: 1024px)").matches;
}

function openAddTaskModal() {
  const modal = $("addTaskModal");
  if (!modal) return;

  modal.classList.remove("hidden");
  modal.classList.add("flex");

  // ‚úÖ keep custom repeat row in sync immediately
  const repeatSel = $("repeatInput");
  if (repeatSel) syncCustomRepeatUI(repeatSel);

  $('titleInput')?.focus();
}


function closeAddTaskModal() {
  const modal = $("addTaskModal");
  if (!modal) return;

  modal.classList.add("hidden");
  modal.classList.remove("flex");
}

  function toggleAddTask() {
  const modal = $("addTaskModal");
  if (!modal) return;

  if (modal.classList.contains("hidden")) openAddTaskModal();
  else closeAddTaskModal();
}

function openAddTaskModal() {
  const modal = $("addTaskModal");
  if (!modal) return;

  modal.classList.remove("hidden");
  modal.classList.add("flex");
  $("titleInput")?.focus();

  const btn = $("todayPointsAddTaskBtn");
  if (btn) btn.textContent = "Close";

  // ‚úÖ add this
  const rep = $("repeatInput");
  syncCustomRepeatUI(rep);
}


function closeAddTaskModal() {
  const modal = $("addTaskModal");
  if (!modal) return;

  modal.classList.add("hidden");
  modal.classList.remove("flex");

  // üëá and here
  const btn = $("todayPointsAddTaskBtn");
  if (btn) btn.textContent = "Add Task";
}


function showPointsToast(points){
  const container = $('pointsToastContainer');
  if(!container) return;

  const pts = Number(points) || 0;
  if(!pts) return;

  const div = document.createElement('div');
  div.className = 'points-toast';
  const sign = pts > 0 ? '+' : '';
  div.textContent = `${sign}${pts} pts`;

  container.appendChild(div);

  // remove after animation
  setTimeout(()=> {
    div.remove();
  }, 3200);
}

function caloriesToPoints(cal){
  let pts = (2400 - cal) / 100;

  if (pts < 0) pts = 0;      // no negatives
  if (pts > 10) pts = 10;    // cap at 10

  pts = Math.round(pts * 10) / 10;  // nearest tenth
  return pts;
}

function addCompletion(entry){
  const pts = Number(entry.points) || 0;
  state.completions.unshift(entry);
  showPointsToast(pts);
}

function loadProjectsFromStorage(){
  try{
    const raw = localStorage.getItem(PROJECTS_STORAGE_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  }catch(e){
    console.error("Failed to load projects from storage", e);
    return [];
  }
}

function saveProjectsToStorage(list){
  try{
    if (Array.isArray(list)){
      localStorage.setItem(PROJECTS_STORAGE_KEY, JSON.stringify(list));
    }
  }catch(e){
    console.error("Failed to save projects to storage", e);
  }
}


function load() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      // nothing saved yet on this device
      return {
        tasks:        [],
        completions:  [],
        players:      [],
        habits:       [],
        flexActions:  [],
        gameHistory:  [],
        matchups:     [],
        schedule:     [],
        opponentDripSchedules: [],
        projects:     loadProjectsFromStorage()
      };
    }

    const p = JSON.parse(raw);
    const storedProjects = loadProjectsFromStorage();

    return {
      tasks:        Array.isArray(p.tasks)        ? p.tasks        : [],
      completions:  Array.isArray(p.completions)  ? p.completions  : [],
      players:      Array.isArray(p.players)      ? p.players      : [],
      habits:       Array.isArray(p.habits)       ? p.habits       : [],
      flexActions:  Array.isArray(p.flexActions)  ? p.flexActions  : [],
      gameHistory:  Array.isArray(p.gameHistory)  ? p.gameHistory  : [],
      matchups:     Array.isArray(p.matchups)     ? p.matchups     : [],
      schedule:     Array.isArray(p.schedule)     ? p.schedule     : [],
      opponentDripSchedules: Array.isArray(p.opponentDripSchedules) ? p.opponentDripSchedules : [],
      projects:     Array.isArray(p.projects)     ? p.projects     : storedProjects
    };
  } catch (e) {
    console.error('Failed to load TaskPoints state on main page', e);
    return {
      tasks:        [],
      completions:  [],
      players:      [],
      habits:       [],
      flexActions:  [],
      gameHistory:  [],
      matchups:     [],
      schedule:     [],
      opponentDripSchedules: [],
      projects:     loadProjectsFromStorage()
    };
  }
}

function syncStateWithMatchups(current){
  if (!window.TaskPointsCore || typeof TaskPointsCore.syncYouMatchups !== 'function') return current;
  const { state: nextState, changed } = TaskPointsCore.syncYouMatchups(current);
  if (changed) {
    try {
      if (window.TaskPointsCore?.mergeAndSaveState) {
        return TaskPointsCore.mergeAndSaveState(nextState).state;
      }
      localStorage.setItem(STORAGE_KEY, JSON.stringify(nextState));
    } catch (e) {
      console.error('Failed to persist synced matchups', e);
    }
  }
  return nextState;
}

function getPlayerNameById(id) {
  if (!id) return 'Unknown opponent';
  if (id === 'YOU') return 'You';

  const players = Array.isArray(state.players) ? state.players : [];
  const match = players.find(p => p && p.id === id);
  if (match && match.name) return match.name;

  return 'Opponent';
}

function getPlayerById(id) {
  if (!id || id === 'YOU') return null;

  const players = Array.isArray(state.players) ? state.players : [];
  return players.find(p => p && p.id === id) || null;
}

function getPlayerRecordText(playerId) {
  if (!playerId || playerId === 'YOU') return '0-0';

  const player = getPlayerById(playerId);
  const baseline = player && typeof player.baseline === 'number'
    ? player.baseline
    : null;

  const history = Array.isArray(state.gameHistory) ? state.gameHistory : [];

  let wins = 0;
  let losses = 0;
  let games = 0;

  for (const g of history) {
    if (!g || g.playerId !== playerId) continue;

    games++;
    const score = typeof g.score === 'number' ? g.score : Number(g.score) || 0;

    if (baseline != null) {
      if (score >= baseline) wins++;
      else losses++;
    }
  }

  return games ? `${wins}-${losses}` : '0-0';
}

function getYourRecordText() {
  const formatRecord = (rec) => `${rec.wins}-${rec.losses}`;
  const record = computeYourRecord();
  return formatRecord(record);
}

function computeYourRecord(){
  const matchupRecord = computeYourMatchupRecord();
  if (matchupRecord.games > 0) return matchupRecord;
  return computeYourCompletionRecord();
}

function computeYourMatchupRecord(){
  const matchups = Array.isArray(state.matchups) ? state.matchups : [];
  let wins = 0;
  let losses = 0;
  let ties = 0;
  let games = 0;

  matchups.forEach(m => {
    if (!m || (m.playerAId !== 'YOU' && m.playerBId !== 'YOU')) return;
    const aScore = Number(m.scoreA);
    const bScore = Number(m.scoreB);
    if (!Number.isFinite(aScore) || !Number.isFinite(bScore)) return;

    games++;
    const yourScore = m.playerAId === 'YOU' ? aScore : bScore;
    const oppScore  = m.playerAId === 'YOU' ? bScore : aScore;

    if (yourScore > oppScore) wins++;
    else if (yourScore < oppScore) losses++;
    else ties++;
  });

  return { wins, losses, ties, games, source: 'matchups' };
}

function computeYourCompletionRecord(){
  const comps = Array.isArray(state.completions) ? state.completions : [];
  if (!comps.length) return { wins: 0, losses: 0, ties: 0, games: 0, source: 'completions' };

  const dayTotals = {};

  comps.forEach(c => {
    if (!c || !c.completedAtISO) return;
    const k = dateKey(c.completedAtISO);
    const pts = Number(c.points || 0);
    if (!Number.isFinite(pts)) return;
    dayTotals[k] = (dayTotals[k] || 0) + pts;
  });

  const totals = Object.values(dayTotals);
  if (!totals.length) return { wins: 0, losses: 0, ties: 0, games: 0, source: 'completions' };

  const avg = totals.reduce((a, b) => a + b, 0) / totals.length || 0;
  let wins = 0;
  let losses = 0;
  let ties = 0;

  totals.forEach(total => {
    if (total > avg) wins++;
    else if (total < avg) losses++;
    else ties++;
  });

  return { wins, losses, ties, games: totals.length, source: 'completions' };
}

function computeYouDailyAverages(){
  const comps = Array.isArray(state.completions) ? state.completions : [];
  if (!comps.length) return { dailyAvg: 0, ppd: 0, hasData: false };

  const dayTotals = {};

  comps.forEach(c => {
    if (!c || !c.completedAtISO) return;
    const k = dateKey(c.completedAtISO);
    const pts = Number(c.points || 0);
    dayTotals[k] = (dayTotals[k] || 0) + pts;
  });

  const totals = Object.values(dayTotals);
  if (!totals.length) return { dailyAvg: 0, ppd: 0, hasData: false };

  const avg = totals.reduce((a, b) => a + b, 0) / totals.length;
  const rounded = Number(avg.toFixed(1));

  return { dailyAvg: rounded, ppd: rounded, hasData: true };
}

function computePlayerDailyAverages(playerId){
  if (!playerId) return { dailyAvg: 0, ppd: 0, hasData: false };
  if (playerId === 'YOU') return computeYouDailyAverages();

  const history = Array.isArray(state.gameHistory) ? state.gameHistory : [];
  const scores = history
    .filter(h => h && h.playerId === playerId)
    .map(h => Number(h.score))
    .filter(Number.isFinite);

  if (!scores.length) return { dailyAvg: 0, ppd: 0, hasData: false };

  const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
  const rounded = Number(avg.toFixed(1));

  return { dailyAvg: rounded, ppd: rounded, hasData: true };
}

function formatAverageLine(avg, ppd){
  const formatVal = (v) => Number.isFinite(v) ? v.toFixed(1) : '‚Äî';
  return `Daily Avg: ${formatVal(avg)} ¬∑ PPD: ${formatVal(ppd)}`;
}


/* ---------- OPPONENT DRIP SCHEDULE ---------- */
function getOpponentDripSchedules(){
  return Array.isArray(state.opponentDripSchedules) ? state.opponentDripSchedules : [];
}

function generateOpponentDripSchedule(dateKeyStr, playerId, totalPoints){
  const totalRounded = Math.max(0, Math.round((Number(totalPoints) || 0) * 10) / 10);
  const totalUnits   = Math.round(totalRounded * 10);

  const startHour = 6;
  const endHour   = 23;
  const count     = Math.max(12, Math.min(40, Math.round(Math.random() * 20) + 15));

  const baseDate = new Date(`${dateKeyStr}T00:00:00`);

  const hourBuckets = [];
  for (let h = startHour; h <= endHour; h++) {
    let weight = 1;

    // Slightly heavier in the morning and evening
    if ((h >= 7 && h <= 10) || (h >= 17 && h <= 21)) weight += 1.2;

    // Random dead zones
    if (Math.random() < 0.15) weight *= 0.4;

    hourBuckets.push({ hour: h, weight });
  }

  const totalHourWeight = hourBuckets.reduce((s, h) => s + h.weight, 0) || 1;

  function pickTime(){
    let r = Math.random() * totalHourWeight;
    let chosenHour = startHour;
    for (const h of hourBuckets) {
      if (r <= h.weight) { chosenHour = h.hour; break; }
      r -= h.weight;
    }

    const m = Math.floor(Math.random() * 60);
    const s = Math.floor(Math.random() * 60);
    const d = new Date(baseDate.getTime());
    d.setHours(chosenHour, m, s, 0);
    return d;
  }

  const weights = [];
  for (let i = 0; i < count; i++) {
    const base = Math.pow(Math.random(), 1.4);
    const burst = Math.random() < 0.35 ? Math.random() * 1.2 : 0;
    weights.push(base + burst);
  }

  const weightSum = weights.reduce((s, n) => s + n, 0) || 1;

  let remaining = totalUnits;
  const pointUnits = [];
  for (let i = 0; i < count; i++) {
    if (i === count - 1) {
      pointUnits.push(Math.max(0, remaining));
    } else {
      const share = Math.min(
        remaining,
        Math.max(0, Math.round((weights[i] / weightSum) * totalUnits))
      );
      pointUnits.push(share);
      remaining -= share;
    }
  }

  // If rounding left stragglers, tack them onto the last bucket
  if (remaining > 0 && pointUnits.length) {
    pointUnits[pointUnits.length - 1] += remaining;
  }

  const times = pointUnits.map(() => pickTime());
  times.sort((a, b) => a - b);

  const events = pointUnits
    .map((units, idx) => ({ t: times[idx].toISOString(), pts: units / 10 }))
    .filter(e => e.pts > 0)
    .sort((a, b) => new Date(a.t) - new Date(b.t));

  return {
    date: dateKeyStr,
    playerId,
    total: totalRounded,
    events
  };
}

function ensureOpponentDripSchedule(dateKeyStr, playerId, totalPoints){
  if (!dateKeyStr || !playerId) return null;

  const schedules = getOpponentDripSchedules();
  const existingIdx = schedules.findIndex(s => s && s.date === dateKeyStr && s.playerId === playerId);
  const totalRounded = Math.max(0, Math.round((Number(totalPoints) || 0) * 10) / 10);

  if (existingIdx !== -1) {
    const existing = schedules[existingIdx];
    if (existing && Math.abs((existing.total || 0) - totalRounded) < 0.001 && Array.isArray(existing.events) && existing.events.length) {
      return existing;
    }
  }

  const next = generateOpponentDripSchedule(dateKeyStr, playerId, totalRounded);
  const updated = schedules.filter(s => !(s && s.date === dateKeyStr && s.playerId === playerId));
  updated.push(next);

  state.opponentDripSchedules = updated;
  save();

  return next;
}

function accruedOpponentPoints(schedule, now = new Date()){
  if (!schedule) return 0;
  const events = Array.isArray(schedule.events) ? schedule.events.slice() : [];
  events.sort((a, b) => new Date(a.t) - new Date(b.t));

  const nowMs = now.getTime();
  const total = Math.max(0, Number(schedule.total) || 0);

  if (!events.length) return total;

  const firstMs = new Date(events[0].t).getTime();
  const lastMs  = new Date(events[events.length - 1].t).getTime();

  if (Number.isFinite(firstMs) && nowMs < firstMs) return 0;
  if (Number.isFinite(lastMs) && nowMs >= lastMs) return total;

  let accruedUnits = 0;
  events.forEach(e => {
    const when = new Date(e.t).getTime();
    const pts = Math.round((Number(e.pts) || 0) * 10);
    if (Number.isFinite(when) && nowMs >= when) {
      accruedUnits += Math.max(0, pts);
    }
  });

  const capped = Math.min(total * 10, accruedUnits);
  return Math.max(0, capped / 10);
}

function visibleOpponentScoreForMatchup(dateKeyStr, playerId, targetTotal){
  const schedule = ensureOpponentDripSchedule(dateKeyStr, playerId, targetTotal);
  return schedule ? accruedOpponentPoints(schedule, new Date()) : Math.max(0, Number(targetTotal) || 0);
}


function normalizeState(s) {
  return {
    tasks:       Array.isArray(s.tasks)       ? s.tasks.map(normalizeTask)       : [],
    completions: Array.isArray(s.completions) ? s.completions : [],
    players:     Array.isArray(s.players)     ? s.players     : [],
    habits:      Array.isArray(s.habits)      ? s.habits      : [],
    flexActions: Array.isArray(s.flexActions) ? s.flexActions : [],
    gameHistory: Array.isArray(s.gameHistory) ? s.gameHistory : [],
    matchups:    Array.isArray(s.matchups)    ? s.matchups    : [],
    schedule:    Array.isArray(s.schedule)    ? s.schedule    : [],
    opponentDripSchedules: Array.isArray(s.opponentDripSchedules) ? s.opponentDripSchedules : [],
    youImage:    typeof s.youImage === "string" ? s.youImage : "",
    projects:    Array.isArray(s.projects)    ? s.projects    : loadProjectsFromStorage()
  };
}

function save() {
  try {
    if (window.TaskPointsCore?.mergeAndSaveState) {
      const { state: merged, trimmed } = TaskPointsCore.mergeAndSaveState(state);
      if (trimmed) {
        console.warn('Storage nearing capacity. Older history items were trimmed to keep saves working.');
      }
      state = merged;
      return;
    }
    const raw = localStorage.getItem(STORAGE_KEY);
    const existing = raw ? (JSON.parse(raw) || {}) : {};
    const merged = normalizeState({ ...existing, ...state });
    localStorage.setItem(STORAGE_KEY, JSON.stringify(merged));
    state = merged;
  } catch (e) {
    console.error("Failed to save state (index.html)", e);
    // last-ditch: write a normalized snapshot (not raw state)
    try {
      const snap = normalizeState(state);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(snap));
      state = snap;
    } catch (e2) {
      console.error("Last-ditch save failed (index.html)", e2);
    }
  }
}



function resetAll(){
  const msg = [
    'This will erase ALL TaskPoints data stored on this device:',
    '- Tasks',
    '- Completions / log history',
    '- Habits & their history',
    '- Flex actions',
    '- Players / Game data',
    '',
    'This cannot be undone. Continue?'
  ].join('\n');

  if (!confirm(msg)) return;

  try{
    // Clear local storage for TaskPoints
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(PROJECTS_STORAGE_KEY);
  }catch(e){
    console.error('Failed to clear TaskPoints storage', e);
  }

  // Reset in-memory state so the UI updates immediately
  state = {
    tasks:        [],
    completions:  [],
    players:      [],
    habits:       [],
    flexActions:  [],
    gameHistory:  [],
    matchups:     [],
    schedule:     [],
    projects:     []
  };

  // Re-render everything so the page doesn't look broken
  try { renderAll(); }           catch(e){ console.error('renderAll after reset:', e); }
  try { renderHabits(); }        catch(e){ console.error('renderHabits after reset:', e); }
  try { renderVices(); }         catch(e){ console.error('renderVices after reset:', e); }
  try { renderFlexActions(); }   catch(e){ console.error('renderFlexActions after reset:', e); }
  try { renderHabitWeekLabels(); } catch(e){ console.error('renderHabitWeekLabels after reset:', e); }
  try { renderViceWeekLabels(); }  catch(e){ console.error('renderViceWeekLabels after reset:', e); }
}


function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); x.setHours(0,0,0,0); return x; }
function dayDiff(fromKey,toKey){
  if(!fromKey || !toKey) return 0;
  const from = new Date(fromKey + 'T00:00:00');
  const to = new Date(toKey + 'T00:00:00');
  const ms = to - from;
  if (!Number.isFinite(ms) || ms <= 0) return 0;
  return Math.round(ms / 86400000);
}
function trackDueDatePush(task, oldDueISO, newDueISO){
  if(!task) return;
  if (!task.originalDueDateISO && (newDueISO || oldDueISO)) {
    task.originalDueDateISO = newDueISO || oldDueISO || null;
  }
  if(!oldDueISO || !newDueISO) return;
  const delta = dayDiff(oldDueISO, newDueISO);
  if(delta>0){
    const current = Number(task.postponedDays) || 0;
    task.postponedDays = current + delta;
  }
}
function computeNextDueDate(task){
  const rec = task.recurrence || {};
  const mode = rec.mode || 'none';
  if (mode === 'none') return null;

  const baseKey = task.dueDateISO || todayKey();
  const base = new Date(baseKey + 'T00:00:00');

  let next = null;

  if (mode === 'daily') {
    next = addDays(base, 1);
  } else if (mode === 'everyWeekday') {
    next = addDays(base, 1);
    let d = next.getDay(); // 0 Sun, 6 Sat
    if (d === 6) next = addDays(next, 2);     // Sat -> Mon
    else if (d === 0) next = addDays(next, 1); // Sun -> Mon
  } else if (mode === 'weekly') {
    next = addDays(base, 7);
  } else if (mode === 'monthly') {
    next = new Date(base);
    next.setMonth(next.getMonth() + 1);
    next.setHours(0,0,0,0);
  } else if (mode === 'yearly') {
    next = new Date(base);
    next.setFullYear(next.getFullYear() + 1);
    next.setHours(0,0,0,0);
  } else if (mode === 'custom') {
    const count = Number.isFinite(rec.customCount) && rec.customCount > 0 ? rec.customCount : 1;
    const unit  = rec.customUnit || 'day';
    if (unit === 'day') {
      next = addDays(base, count);
    } else if (unit === 'week') {
      next = addDays(base, count * 7);
    } else if (unit === 'month') {
      next = new Date(base);
      next.setMonth(next.getMonth() + count);
      next.setHours(0,0,0,0);
    } else if (unit === 'year') {
      next = new Date(base);
      next.setFullYear(next.getFullYear() + count);
      next.setHours(0,0,0,0);
    }
  }

  return next ? dateKey(next) : null;
}

function startOfWeek(d){ const x=new Date(d); x.setHours(0,0,0,0); const day=(x.getDay()+6)%7; x.setDate(x.getDate()-day); return x; }
function weekDays(baseDate){
  const start=startOfWeek(baseDate);
  const days=[];
  for(let i=0;i<7;i++){
    const d=addDays(start,i);
    days.push({date:d, key:dateKey(d), label:d.toLocaleDateString(undefined,{weekday:'short'})});
  }
  return days;
}
function computeHabitStreak(h){
  if (!h || !Array.isArray(h.doneKeys) || h.doneKeys.length === 0) return 0;

  // Use fromKey so "YYYY-MM-DD" is parsed the same way everywhere else
  const dates = h.doneKeys
    .map(k => fromKey(k))
    .filter(d => d && !isNaN(d))
    .sort((a, b) => b - a); // newest ‚Üí oldest

  if (!dates.length) return 0;

  // Normalize "today"
  const today = new Date();
  today.setHours(0,0,0,0);

  const mostRecent = new Date(dates[0].getTime());
  mostRecent.setHours(0,0,0,0);

  const diffToToday = Math.round((today - mostRecent) / 86400000);
  if (diffToToday > 0) {
    // Last completion wasn't today ‚Üí streak broken
    return 0;
  }

  // Count backwards through consecutive days
  let streak = 1;
  let prev = mostRecent;

  for (let i = 1; i < dates.length; i++) {
    const d = new Date(dates[i].getTime());
    d.setHours(0,0,0,0);

    const diffDays = Math.round((prev - d) / 86400000);
    if (diffDays === 1) {
      streak++;
      prev = d;
    } else {
      break;
    }
  }

  return streak;
}

function computeHabitCompletion(h){
  if (!h) return 0;

  const doneKeys = Array.isArray(h.doneKeys) ? h.doneKeys : [];

  // Normalize "today"
  const today = new Date();
  today.setHours(0,0,0,0);

  // Figure out when this habit/vice "started"
  let start = null;

  // Prefer createdAtISO if present
  if (h.createdAtISO) {
    const d = new Date(h.createdAtISO);
    if (!isNaN(d)) {
      d.setHours(0,0,0,0);
      start = d;
    }
  }

  // Fallback: earliest doneKey
  if (!start && doneKeys.length) {
    const dates = doneKeys
      .map(k => fromKey(k))
      .filter(d => d && !isNaN(d))
      .sort((a, b) => a - b); // oldest ‚Üí newest

    if (dates.length) {
      const d0 = new Date(dates[0].getTime());
      d0.setHours(0,0,0,0);
      start = d0;
    }
  }

  // If we *still* don't have a start, treat as 0% for now
  if (!start) return 0;
  if (start > today) start = today;

  const totalDays = Math.max(
    1,
    Math.round((today - start) / 86400000) + 1
  );

  // Count how many days it was actually marked done
  const doneCount = doneKeys.filter(k => {
    const d = fromKey(k);
    if (!d || isNaN(d)) return false;
    d.setHours(0,0,0,0);
    return d >= start && d <= today;
  }).length;

  const pct = Math.round((doneCount / totalDays) * 100);
  return pct;
}


/* ---------- DATE HELPERS ---------- */
function todayKey(){
  const d = new Date();
  d.setHours(0,0,0,0);
  return dateKey(d);
}

function getGameDayKey(now = new Date()){
  const dt = new Date(now);
  dt.setHours(0,0,0,0);
  return dateKey(dt);
}

function dateKey(d){
  // Accept either a Date or something parseable
  if (!(d instanceof Date)) d = new Date(d);
  if (!d || isNaN(d.getTime())) return 'invalid';
  const y  = d.getFullYear();
  const m  = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${dd}`;
}

function fromKey(k){
  if (!k || typeof k !== 'string') return new Date(NaN);
  const parts = k.split('-');
  if (parts.length < 3) return new Date(NaN);
  const [yStr,mStr,dStr] = parts;
  const y = parseInt(yStr,10);
  const m = parseInt(mStr,10);
  const d = parseInt(dStr,10);
  if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) {
    return new Date(NaN);
  }
  const dt = new Date(y, m-1, d);
  dt.setHours(0,0,0,0);
  return dt;
}

function niceDate(d){
  if (!(d instanceof Date)) d = new Date(d);
  if (!d || isNaN(d.getTime())) return 'Invalid date';
  return d.toLocaleDateString(undefined,{
    year:'numeric',
    month:'short',
    day:'numeric'
  });
}

function aggregateCompletionsByDate(completions){
  const dailyTotals   = {};
  const weeklyTotals  = {};
  const monthlyTotals = {};

  if (!Array.isArray(completions)) return { dailyTotals, weeklyTotals, monthlyTotals };

  completions.forEach(c => {
    if (!c || !c.completedAtISO) return;

    const d = new Date(c.completedAtISO);
    if (!d || isNaN(d.getTime())) {
      // Ignore bad/legacy entries instead of crashing the page
      return;
    }

    const dk = dateKey(d);
    const wk = isoWeekKey(d);
    const mk = monthKey(d);

    const pts = c.points || 0;

    dailyTotals[dk]   = (dailyTotals[dk]   || 0) + pts;
    weeklyTotals[wk]  = (weeklyTotals[wk]  || 0) + pts;
    monthlyTotals[mk] = (monthlyTotals[mk] || 0) + pts;
  });

  return { dailyTotals, weeklyTotals, monthlyTotals };
}

function computeInertia(dailyTotals, todayK){
  const today = fromKey(todayK);
  if (!today || isNaN(today.getTime())) return { inertia: 0, average: 0 };

  const keys = Array.from(new Set([...Object.keys(dailyTotals), todayK]))
    .filter(k => {
      const d = fromKey(k);
      return d && !isNaN(d.getTime());
    })
    .sort((a, b) => fromKey(a) - fromKey(b));

  const inertiaMap = new Map();
  const totalsWithInertia = new Map();

  keys.forEach(k => {
    const current = fromKey(k);
    if (!current || isNaN(current.getTime())) return;

    let sum = 0;
    let count = 0;

    for (let i = 1; i <= 7; i++) {
      const d = new Date(current);
      d.setDate(current.getDate() - i);
      const key = dateKey(d);
      const total = totalsWithInertia.get(key);
      if (Number.isFinite(total)) {
        sum += total;
        count++;
      }
    }

    const average = count ? sum / count : 0;
    const inertia = count ? average * 0.25 : 0;

    inertiaMap.set(k, { inertia, average });
    const base = Number(dailyTotals[k]) || 0;
    totalsWithInertia.set(k, base + inertia);
  });

  return inertiaMap.get(todayK) || { inertia: 0, average: 0 };
}

function deriveTodayWithInertia(dailyTotals, todayK){
  const { inertia, average } = computeInertia(dailyTotals, todayK);
  const todayBase = Number(dailyTotals[todayK]) || 0;
  const todayPoints = Math.round((todayBase + inertia) * 10) / 10;

  return { todayPoints, inertia, average, base: todayBase };
}

function renderTodayPointsSummary(todayPoints, inertia, inertiaAvg){
  const todayPointsEl = $('todayPoints');
  if (todayPointsEl) {
    todayPointsEl.textContent = todayPoints.toLocaleString(undefined, {
      maximumFractionDigits: 1,
    });
  }

  const inertiaValueEl = $('inertiaValue');
  if (inertiaValueEl) inertiaValueEl.textContent = (Number.isFinite(inertia) ? inertia : 0).toFixed(1);

  const inertiaAvgEl = $('inertiaAverage');
  if (inertiaAvgEl) inertiaAvgEl.textContent = `7-day avg: ${(Number.isFinite(inertiaAvg) ? inertiaAvg : 0).toFixed(1)}`;
}

function todaysPointsTotal(){
  const todayK = todayKey();
  const { dailyTotals } = aggregateCompletionsByDate(state.completions || []);
  const { todayPoints } = deriveTodayWithInertia(dailyTotals, todayK);

  return todayPoints;
}

function startOpponentDripTicker(){
  function tick(){
    const todayK = todayKey();
    const matchupKey = getGameDayKey(new Date());
    const { dailyTotals } = aggregateCompletionsByDate(state.completions || []);
    const { todayPoints, inertia, average } = deriveTodayWithInertia(dailyTotals, todayK);
    const { todayPoints: matchupPoints } = deriveTodayWithInertia(dailyTotals, matchupKey);

    renderTodayPointsSummary(todayPoints, inertia, average);

    renderTodaysMatchup(matchupKey, matchupPoints);
  }

  tick();
  setInterval(tick, 45000);
  document.addEventListener('visibilitychange', () => { if (!document.hidden) tick(); });
}

function monthKey(d){
  if (!(d instanceof Date)) d = new Date(d);
  if (!d || isNaN(d.getTime())) return 'invalid-month';
  const y  = d.getFullYear();
  const m  = String(d.getMonth()+1).padStart(2,'0');
  return `${y}-${m}`;
}

function formatMonthKey(k){
  const parts = (k || '').split('-');
  if (parts.length < 2) return 'Invalid month';
  const [yStr,mStr] = parts;
  const y = parseInt(yStr,10);
  const m = parseInt(mStr,10);
  if (!Number.isFinite(y) || !Number.isFinite(m)) return 'Invalid month';
  const dt = new Date(y, m-1, 1);
  if (isNaN(dt.getTime())) return 'Invalid month';
  return dt.toLocaleString(undefined,{month:'long',year:'numeric'});
}

function isoWeekKey(d){
  if (!(d instanceof Date)) d = new Date(d);
  if (!d || isNaN(d.getTime())) return 'invalid-week';

  const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  const dayNum = date.getUTCDay() || 7;
  date.setUTCDate(date.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(date.getUTCFullYear(),0,1));
  const weekNo = Math.ceil(((date - yearStart) / 86400000 + 1) / 7);
  return `${date.getUTCFullYear()}-W${String(weekNo).padStart(2,'0')}`;
}

function isoWeekRange(weekKey){
  const [yStr, wStr] = weekKey.split('-W');
  const y = parseInt(yStr, 10);
  const w = parseInt(wStr, 10);

  // Build a local date that falls in the correct ISO week
  const simple = new Date(y, 0, 1 + (w - 1) * 7); // local time
  let dow = simple.getDay(); // 0 = Sun, 1 = Mon, ... 6 = Sat
  if (dow === 0) dow = 7;    // treat Sunday as 7

  // Start of week = Monday
  const start = new Date(simple);
  start.setDate(simple.getDate() + 1 - dow);

  // End of week = Sunday
  const end = new Date(start);
  end.setDate(start.getDate() + 6);

  return { start, end };
}

function renderStats(){
  const lifetime = state.completions.reduce((s, c) => s + (c.points || 0), 0);

  // Lifetime card was removed in UI, but keep this guard in case the element exists
  const lifetimeEl = $('lifetimePoints');
  if (lifetimeEl) {
    lifetimeEl.textContent = lifetime.toLocaleString();
  }

  const { dailyTotals, weeklyTotals, monthlyTotals } = aggregateCompletionsByDate(state.completions || []);


  const dKeys = Object.keys(dailyTotals);

  const dAvg = dKeys.length
    ? (dKeys.reduce((s, k) => s + dailyTotals[k], 0) / dKeys.length).toFixed(1)
    : "0.0";

  const dailyAvgEl = $('dailyAvg');
  if (dailyAvgEl) {
    dailyAvgEl.textContent = dAvg.toLocaleString();
  }


  // Draw daily trend line
  drawDailyTrend(dailyTotals);

  // Today / this week / this month keys
  const today = new Date();
  today.setHours(0,0,0,0);

  const todayK    = dateKey(today);
  const thisWeekK = isoWeekKey(today);
  const thisMonthK= monthKey(today);
  const matchupKey = getGameDayKey(today);

  const { todayPoints, inertia: inertiaPts, average: inertiaAvg } = deriveTodayWithInertia(dailyTotals, todayK);
  const { todayPoints: matchupPoints } = deriveTodayWithInertia(dailyTotals, matchupKey);

  // Today's points bubble
  renderTodayPointsSummary(todayPoints, inertiaPts, inertiaAvg);

  renderTodaysMatchup(matchupKey, matchupPoints);

  // Today's breakdown bar ‚Äì wrapped in try/catch so it can't kill stats
  try {
    updateTodayBreakdown(state.completions || [], todayK, inertiaPts);
  } catch (e) {
    console.error('updateTodayBreakdown error', e);
  }

  // ----- LEADERBOARDS -----
  function fillBoard(ulId, entries, labelFn){
    const ul = $(ulId);
    if (!ul) return;

    ul.innerHTML = '';
    if (!entries.length) {
      ul.innerHTML = '<li class="muted">No data yet.</li>';
      return;
    }

    entries.slice(0, 10).forEach((row, i) => {
      const li = document.createElement('li');

      // Store the key on the <li> so we can highlight the current one later
      li.dataset.key = row.key;
      li.className = 'flex items-center justify-between';

      const formattedTotal = Number(row.total).toLocaleString(undefined, {
        maximumFractionDigits: 1,
      });

      li.innerHTML = `
        <span>${i+1}. ${labelFn(row)}</span>
        <span class="font-semibold">${formattedTotal} pts</span>
      `;
      ul.appendChild(li);
    });
  }

  const dailyTotalsWithInertia = Object.fromEntries(
    Object.entries(dailyTotals).map(([k, v]) => {
      const { inertia } = computeInertia(dailyTotals, k);
      const inertiaVal = Number.isFinite(inertia) ? inertia : 0;
      return [k, v + inertiaVal];
    })
  );

  const weeklyTotalsWithInertia = {};
  const monthlyTotalsWithInertia = {};

  Object.entries(dailyTotalsWithInertia).forEach(([k, total]) => {
    const d = fromKey(k);
    if (!d || isNaN(d.getTime())) return;

    const wk = isoWeekKey(d);
    const mk = monthKey(d);

    weeklyTotalsWithInertia[wk]  = (weeklyTotalsWithInertia[wk]  || 0) + total;
    monthlyTotalsWithInertia[mk] = (monthlyTotalsWithInertia[mk] || 0) + total;
  });

  const bestDays = Object.entries(dailyTotalsWithInertia)
    .map(([k, v]) => ({ key: k, total: v }))
    .sort((a, b) => b.total - a.total);

  const bestWeeks = Object.entries(weeklyTotalsWithInertia)
    .map(([k, v]) => ({ key: k, total: v, ...isoWeekRange(k) }))
    .sort((a, b) => b.total - a.total);

  const bestMonths = Object.entries(monthlyTotalsWithInertia)
    .map(([k, v]) => ({ key: k, total: v }))
    .sort((a, b) => b.total - a.total);

  // Labels with NO "(Today / This Week / This Month)" text
  fillBoard('dailyBoard', bestDays, r =>
    niceDate(fromKey(r.key))
  );

  fillBoard('weeklyBoard', bestWeeks, r =>
    `${niceDate(r.start)} ‚Äì ${niceDate(r.end)}`
  );

  fillBoard('monthlyBoard', bestMonths, r =>
    formatMonthKey(r.key)
  );

  // Highlight current day/week/month in orange if they appear
  [
    ['dailyBoard', todayK],
    ['weeklyBoard', thisWeekK],
    ['monthlyBoard', thisMonthK],
  ].forEach(([ulId, currentKey]) => {
    const ul = $(ulId);
    if (!ul) return;

    ul.querySelectorAll('li').forEach(li => {
      if (li.dataset.key === currentKey) {
        li.classList.add('leaderboard-current');
      }
    });
  });


function renderTodaysMatchup(todayKeyStr, yourScore){
  const oppNameEl = $('matchupOpponent');
  const oppScoreEl= $('matchupOpponentScore');
  const yourScoreEl = $('matchupYourScore');
  const diffEl    = $('matchupDiff');
  const diffValueEl = $('matchupDiffValue');
  const oppRecordEl = $('matchupOpponentRecord');
  const yourRecordEl = $('matchupYourRecord');
  const yourNameEl = $('matchupYourName');
  const yourAvgEl = $('matchupYourAverages');
  const oppAvgEl = $('matchupOpponentAverages');

  if (!oppNameEl || !oppScoreEl || !yourScoreEl || !diffEl || !diffValueEl || !oppRecordEl || !yourRecordEl) return;

  if (yourNameEl) yourNameEl.textContent = 'You';
  const youAverages = computeYouDailyAverages();
  if (yourAvgEl) {
    const youAvgVal = youAverages.hasData ? youAverages.dailyAvg : null;
    const youPpdVal = youAverages.hasData ? youAverages.ppd : null;
    yourAvgEl.textContent = formatAverageLine(youAvgVal, youPpdVal);
  }
  if (oppAvgEl) oppAvgEl.textContent = formatAverageLine(null, null);

  const setOpponentAverages = (playerId) => {
    if (!oppAvgEl) return;
    const oppAverages = computePlayerDailyAverages(playerId);
    const avgVal = oppAverages.hasData ? oppAverages.dailyAvg : null;
    const ppdVal = oppAverages.hasData ? oppAverages.ppd : null;
    oppAvgEl.textContent = formatAverageLine(avgVal, ppdVal);
  };

  const matchups = Array.isArray(state.matchups) ? state.matchups : [];
  const matchupDateKey = (m) => {
    if (!m) return '';
    if (m.date) return m.date;
    if (m.dateKey) return m.dateKey;
    if (m.dateISO) return dateKey(m.dateISO);
    return '';
  };
  const matchup = matchups.find(m => m && matchupDateKey(m) === todayKeyStr && (m.playerAId === 'YOU' || m.playerBId === 'YOU'));

  if (!matchup) {
    diffEl.textContent = 'No matchup today';
    diffValueEl.textContent = '‚Äî';
    oppScoreEl.textContent = '‚Äî';
    yourScoreEl.textContent = '‚Äî';
    oppRecordEl.textContent = 'Record: ‚Äî';
    yourRecordEl.textContent = `Record: ${getYourRecordText()}`;
    oppNameEl.textContent = '‚Äî';
    setOpponentAverages(null);
    return;
  }

  const youAreA = matchup.playerAId === 'YOU';
  const oppId = youAreA ? matchup.playerBId : matchup.playerAId;
  const oppScoreRaw = youAreA ? matchup.scoreB : matchup.scoreA;
  const yourScoreSaved = youAreA ? matchup.scoreA : matchup.scoreB;

  const oppScoreNum = Number(oppScoreRaw);
  const safeOppScore = Number.isFinite(oppScoreNum) ? oppScoreNum : 0;
  const safeYourScore = Number.isFinite(yourScore)
    ? yourScore
    : (Number.isFinite(yourScoreSaved) ? yourScoreSaved : 0);

  const visibleOppScore = oppId
    ? visibleOpponentScoreForMatchup(todayKeyStr, oppId, safeOppScore)
    : safeOppScore;

  oppNameEl.textContent = getPlayerNameById(oppId);
  oppScoreEl.textContent = visibleOppScore.toFixed(1);
  yourScoreEl.textContent = safeYourScore.toFixed(1);
  oppRecordEl.textContent = `Record: ${getPlayerRecordText(oppId)}`;
  yourRecordEl.textContent = `Record: ${getYourRecordText()}`;
  setOpponentAverages(oppId);

  diffEl.className = 'muted text-xs mt-1';
  const diff = Number((safeYourScore - visibleOppScore).toFixed(1));

  diffValueEl.textContent = `${diff > 0 ? '+' : ''}${diff.toFixed(1)}`;
  diffValueEl.className = 'scoreboard-diff-value';
  diffValueEl.classList.remove('diff-positive', 'diff-negative', 'diff-neutral');

  if (diff > 0) {
    diffEl.textContent = `Winning by ${diff.toFixed(1)} pts`;
    diffValueEl.classList.add('diff-positive');
  } else if (diff < 0) {
    diffEl.textContent = `Losing by ${Math.abs(diff).toFixed(1)} pts`;
    diffValueEl.classList.add('diff-negative');
  } else {
    diffEl.textContent = 'Tied right now';
    diffValueEl.classList.add('diff-neutral');
  }
}

function updateTodayBreakdown(completions, todayKey, inertiaPoints = 0){
  const bar       = $('todayBreakdownBar');
  const summaryEl = $('todayBreakdownSummary');
  if (!bar) return;

  const safeCompletions = Array.isArray(completions) ? completions : [];

  // Totals per category (now includes calories)
  const totals = {
    sleep:    0,
    tasks:    0,
    habits:   0,
    vices:    0,
    flex:     0,
    calories: 0,
    inertia:  Number(inertiaPoints) || 0,
  };

  // Collect today's points by category
  safeCompletions.forEach(c => {
    if (!c || !c.completedAtISO) return;

    const d = new Date(c.completedAtISO);
    if (dateKey(d) !== todayKey) return;

    const pts = Number(c.points) || 0;
    if (!pts) return;

    const titleStr = typeof c.title === 'string' ? c.title : '';

         // Sleep entries: "Sleep Score (...)"
// `c.points` already includes bonus, so just add it once.
if (titleStr.startsWith('Sleep Score (')) {
  totals.sleep += pts;
  return;
}


    // Calories entries: "Calories (...)"
    if (titleStr.startsWith('Calories (')) {
      totals.calories += pts;
      return;
    }

    // Habits / Vices / Flux based on source
    if (c.source === 'habit') {
      totals.habits += pts;
      return;
    }
    if (c.source === 'vice') {
      totals.vices += pts;
      return;
    }
    if (c.source === 'flex') {
      totals.flex += pts;
      return;
    }

    // Everything else counts as Tasks
    totals.tasks += pts;
  });

  // Build the bar
  bar.innerHTML = '';

  const totalPts = Object.values(totals).reduce((sum, v) => sum + v, 0);

  if (!totalPts) {
    if (summaryEl) {
      summaryEl.textContent = 'No points yet today.';
    }
    return;
  }

  const segments = [
    { key: 'sleep',    label: 'Sleep',    cls: 'todayBreakdown-sleep'    },
    { key: 'tasks',    label: 'Tasks',    cls: 'todayBreakdown-tasks'    },
    { key: 'habits',   label: 'Habits',   cls: 'todayBreakdown-habits'   },
    { key: 'vices',    label: 'Vices',    cls: 'todayBreakdown-vices'    },
    { key: 'flex',     label: 'Flux',     cls: 'todayBreakdown-flex'     },
    { key: 'calories', label: 'Calories', cls: 'todayBreakdown-calories' },
    { key: 'inertia',  label: 'Inertia',  cls: 'todayBreakdown-inertia'  },
  ];

  const parts = [];

  segments.forEach(({ key, label, cls }) => {
    const val = totals[key];
    if (val <= 0) return;

    const pct = (val / totalPts) * 100;

    const seg = document.createElement('div');
    seg.className = 'todayBreakdown-seg ' + cls;
    seg.style.width = pct + '%';
    bar.appendChild(seg);

    parts.push(`${label} ${val.toFixed(1)}`);
  });

  if (summaryEl) {
    summaryEl.textContent = parts.join(' ¬∑ ');
  }
}


function drawDailyTrend(dailyTotals){
  const canvas = $('dailyTrend');
  if (!canvas || !canvas.getContext) return;

  const ctx = canvas.getContext('2d');

  const width  = canvas.clientWidth  || 320;
  const height = canvas.clientHeight || 80;
  canvas.width  = width;
  canvas.height = height;

  ctx.clearRect(0, 0, width, height);

  let entries = Object.entries(dailyTotals)
    .map(([key, total]) => ({ key, total }))
    .sort((a, b) => a.key.localeCompare(b.key));

// Show full history, but downsample if it's huge (keeps last point)
const MAX_POINTS = 400; // tweak: 200‚Äì800 depending on taste
if (entries.length > MAX_POINTS) {
  const step = Math.ceil(entries.length / MAX_POINTS);
  entries = entries.filter((_, i) => i % step === 0 || i === entries.length - 1);
}

  const n = entries.length;
  if (!n) {
    ctx.strokeStyle = 'rgba(148,163,184,0.3)';
    ctx.beginPath();
    ctx.moveTo(0, height - 4);
    ctx.lineTo(width, height - 4);
    ctx.stroke();
    return;
  }

  const maxVal = Math.max(...entries.map(r => r.total));
  const minVal = Math.min(...entries.map(r => r.total));
  const range  = (maxVal - minVal) || 1;

  const paddingX = 6;
  const paddingY = 6;
  const w = width  - paddingX * 2;
  const h = height - paddingY * 2;

  // Baseline
  ctx.strokeStyle = 'rgba(15,23,42,0.7)';
  ctx.lineWidth   = 1;
  ctx.beginPath();
  ctx.moveTo(paddingX, paddingY + h);
  ctx.lineTo(paddingX + w, paddingY + h);
  ctx.stroke();

  // Line
  ctx.strokeStyle = '#22d3ee';
  ctx.lineWidth   = 2;
  ctx.beginPath();

  entries.forEach((row, i) => {
    const x = paddingX + (n === 1 ? w / 2 : (w * i / (n - 1)));
    const norm = (row.total - minVal) / range;
    const y = paddingY + h - norm * h;

    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });

  ctx.stroke();
}
}

function bumpOneDay(task){
  if (!task.dueDateISO) return;  // nothing to bump
  const d = new Date(task.dueDateISO + 'T00:00:00');
  const bumped = addDays(d, 1);
  const oldDue = task.dueDateISO;
  task.dueDateISO = dateKey(bumped);
  trackDueDatePush(task, oldDue, task.dueDateISO);
}

function labelForDay(d,baseToday){
  const t=dateKey(baseToday), k=dateKey(d);
  if(k===t) return 'Today';
  if(k===dateKey(addDays(baseToday,1))) return 'Tomorrow';
  return d.toLocaleDateString(undefined,{weekday:'long',month:'short',day:'numeric'});
}
function cmpImportance(a,b){ const o={Low:0,Medium:1,High:2,Critical:3}; return (o[a.importance]||0)-(o[b.importance]||0); }

/* ---------- HABITS ---------- */
function renderHabitWeekLabels(){
  const row = $('habitWeekLabels');
  row.innerHTML = '';

  const days = weekDays(new Date());

  // Use the same layout container as the habit day bubbles
  const wrapper = document.createElement('div');
  wrapper.className = 'habitDaysRow';

  days.forEach(d => {
    const cell = document.createElement('div');
    cell.className = 'habitLabelDay';
    cell.textContent = d.label; // "Mon", "Tue", etc.
    wrapper.appendChild(cell);
  });

  row.appendChild(wrapper);
}


function renderViceWeekLabels(){
  const row = $('viceWeekLabels');
  row.innerHTML = '';

  const days = weekDays(new Date());

  // Same layout as vices' day bubbles
  const wrapper = document.createElement('div');
  wrapper.className = 'habitDaysRow';

  days.forEach(d => {
    const cell = document.createElement('div');
    cell.className = 'habitLabelDay';
    cell.textContent = d.label;
    wrapper.appendChild(cell);
  });

  row.appendChild(wrapper);
}



function renderHabits(){
  const wrap  = $('habitsList');
  const empty = $('habitsEmpty');
  wrap.innerHTML = '';
  const days = weekDays(new Date());

  // Only active habits (NOT vices, NOT retired)
const sortMode = getHabitSortMode();

const habits = state.habits
  .filter(h => (h.category || 'habit') !== 'vice')
  .filter(h => !h.retired)
  .slice();

// Precompute streak + completion once so sorting is stable + fast
habits.forEach(h => {
  h.doneKeys = Array.isArray(h.doneKeys) ? h.doneKeys : [];
  h.__streak = computeHabitStreak(h);
  h.__completion = computeHabitCompletion(h);
});

if (sortMode === 'custom') {
  habits.sort((a,b) => {
    const ao = (typeof a.order === 'number') ? a.order : 0;
    const bo = (typeof b.order === 'number') ? b.order : 0;
    if (ao !== bo) return ao - bo;

    const ac = a.createdAtISO || '';
    const bc = b.createdAtISO || '';
    return ac.localeCompare(bc);
  });
} else if (sortMode === 'points') {
  habits.sort((a,b) =>
    (Number(b.pointsPerDay||0) - Number(a.pointsPerDay||0)) ||
    (a.name||'').localeCompare(b.name||'')
  );
} else if (sortMode === 'streak') {
  habits.sort((a,b) =>
    (Number(b.__streak||0) - Number(a.__streak||0)) ||
    (Number(b.pointsPerDay||0) - Number(a.pointsPerDay||0)) ||
    (a.name||'').localeCompare(b.name||'')
  );
} else if (sortMode === 'completion') {
  habits.sort((a,b) =>
    (Number(b.__completion||0) - Number(a.__completion||0)) ||
    (Number(b.__streak||0) - Number(a.__streak||0)) ||
    (Number(b.pointsPerDay||0) - Number(a.pointsPerDay||0)) ||
    (a.name||'').localeCompare(b.name||'')
  );
}



  if(!habits.length){
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');

  habits.forEach(h => {
    h.doneKeys = Array.isArray(h.doneKeys) ? h.doneKeys : [];

const streak     = Number(h.__streak || 0);
const completion = Number(h.__completion || 0);



  const row = document.createElement('div');
  row.className = 'habitRow';

const daysHtml = days.map(d => {
  const on = h.doneKeys.includes(d.key);
return `<div class="habitDay ${on ? 'on' : 'off'}" data-habit="${h.id}" data-day="${d.key}">
    ${d.date.getDate()}
  </div>`;
}).join('');

  const daysRowHtml = `<div class="habitDaysRow">${daysHtml}</div>`;


    // EDIT MODE
    if(editingHabitId === h.id){
      const category = h.category || 'habit';
      row.innerHTML = `
        <div class="flex flex-col gap-2 min-w-0">
          <input class="input" data-field="name" value="${escapeHtml(h.name)}">
          <input class="input" data-field="points" type="number" value="${h.pointsPerDay||0}">
          <select class="input" data-field="category">
            <option value="habit" ${category==='habit'?'selected':''}>Habit</option>
            <option value="vice"  ${category==='vice'?'selected':''}>Vice</option>
          </select>
          <div class="flex gap-2 flex-wrap">
            <button class="btn btn-success" data-act="habit-save">Save</button>
            <button class="btn btn-ghost" data-act="habit-cancel">Cancel</button>
            <button class="btn btn-ghost" data-act="habit-delete">Delete</button>
          </div>
        </div>
        ${daysRowHtml}
      `;

      wrap.appendChild(row);

      row.querySelector('[data-act="habit-save"]').onclick = () => saveHabitEdit(h.id, row);
      row.querySelector('[data-act="habit-cancel"]').onclick = () => { editingHabitId=null; renderHabits(); renderVices(); };
      row.querySelector('[data-act="habit-delete"]').onclick = () => deleteHabit(h.id);

} else {
// NORMAL MODE
const nameHtml = `
  <div class="habitLeft flex items-center gap-2 flex-wrap min-w-0 flex-1 text-xs sm:text-sm">
    <!-- Left side: habit name + points + streak + completion% -->
    <div class="habitName" title="${escapeHtml(h.name)}">
      ${escapeHtml(h.name)}
    </div>
    <div class="tag bg-zinc-200/60 dark:bg-zinc-700/60">
      ${h.pointsPerDay||0} pts
    </div>
  ${streak > 0 ? `
    <div class="tag streak-pill">
      ${streak} ${streak === 1 ? 'day' : 'days'}
    </div>
  ` : ''}
    <div class="tag bg-zinc-200/60 dark:bg-zinc-700/60 text-orange-400">
      ${completion}%
    </div>
  </div>
`;


  // Right side: controls only (Edit/Delete/‚ñ≤/‚ñº)
const isCustom = (getHabitSortMode() === 'custom');

const controlsHtml = `
  <div class="habitControls flex items-center gap-2 flex-wrap text-xs sm:text-sm">
    <button class="btn btn-ghost" data-act="habit-edit" data-id="${h.id}">Edit</button>
    <button class="btn btn-ghost" data-act="habit-delete" data-id="${h.id}">Delete</button>
    ${isCustom ? `
      <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
              data-act="habit-up" data-id="${h.id}">‚ñ≤</button>
      <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
              data-act="habit-down" data-id="${h.id}">‚ñº</button>
    ` : ``}
  </div>
`;



  // Line 3: date bubbles (sits to the right on desktop, below on mobile)
  row.innerHTML = nameHtml + controlsHtml + daysRowHtml;
  wrap.appendChild(row);
}



  });

  wrap.querySelectorAll('.habitDay').forEach(el=>{
    el.onclick = () => toggleHabitDay(el.getAttribute('data-habit'), el.getAttribute('data-day'));
  });
  wrap.querySelectorAll('[data-act="habit-edit"]').forEach(btn=>{
    btn.onclick = () => { editingHabitId = btn.getAttribute('data-id'); renderHabits(); renderVices(); };
  });
  wrap.querySelectorAll('[data-act="habit-delete"]').forEach(btn=>{
    btn.onclick = () => deleteHabit(btn.getAttribute('data-id'));
  });
  wrap.querySelectorAll('[data-act="habit-up"]').forEach(btn => {
    btn.onclick = () => moveHabit(btn.getAttribute('data-id'), -1);
  });
  wrap.querySelectorAll('[data-act="habit-down"]').forEach(btn => {
    btn.onclick = () => moveHabit(btn.getAttribute('data-id'), +1);
  });
}

function renderVices(){
  const wrap  = $('vicesList');
  const empty = $('vicesEmpty');
  wrap.innerHTML = '';
  const days = weekDays(new Date());

  // Only VICES, non-retired
  const habits = state.habits
    .filter(h => (h.category || 'habit') === 'vice')
    .filter(h => !h.retired)
    .slice()
    .sort((a,b) => {
      const ao = (typeof a.order === 'number') ? a.order : 0;
      const bo = (typeof b.order === 'number') ? b.order : 0;
      if (ao !== bo) return ao - bo;

      const ac = a.createdAtISO || '';
      const bc = b.createdAtISO || '';
      return ac.localeCompare(bc);
    });

  if (!habits.length) {
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');

  habits.forEach(h => {
    h.doneKeys = Array.isArray(h.doneKeys) ? h.doneKeys : [];
    h.failedKeys = Array.isArray(h.failedKeys) ? h.failedKeys : [];
    const streak     = computeHabitStreak(h);
    const completion = computeHabitCompletion(h);
    const row = document.createElement('div');

    row.className = 'habitRow';

    const daysHtml = days.map(d => {
      const on = h.doneKeys.includes(d.key);
      const failed = h.failedKeys.includes(d.key);
      const statusClass = on ? 'on' : (failed ? 'failed' : 'off');
      return `<div class="habitDay viceDay ${statusClass}" data-habit="${h.id}" data-day="${d.key}">

        ${d.date.getDate()}
      </div>`;
    }).join('');

    const daysRowHtml = `<div class="habitDaysRow">${daysHtml}</div>`;

    if (editingHabitId === h.id) {
      // EDIT MODE
      row.innerHTML = `
        <div class="flex flex-col gap-2 min-w-0">
          <input class="input" data-field="name" value="${escapeHtml(h.name)}">
          <input class="input" data-field="points" type="number" value="${h.pointsPerDay||0}">
          <div class="flex gap-2 flex-wrap">
            <button class="btn btn-success" data-act="habit-save">Save</button>
            <button class="btn btn-ghost" data-act="habit-cancel">Cancel</button>
            <button class="btn btn-ghost" data-act="habit-delete">Delete</button>
          </div>
        </div>
        ${daysRowHtml}
      `;

      wrap.appendChild(row);

      const saveBtn   = row.querySelector('[data-act="habit-save"]');
      const cancelBtn = row.querySelector('[data-act="habit-cancel"]');
      const delBtn    = row.querySelector('[data-act="habit-delete"]');

      saveBtn.onclick   = () => saveHabitEdit(h.id, row);
      cancelBtn.onclick = () => { editingHabitId = null; renderHabits(); renderVices(); };
      delBtn.onclick    = () => deleteHabit(h.id);

    } else {
// NORMAL MODE
const nameHtml = `
  <div class="habitLeft flex items-center gap-2 flex-wrap min-w-0 flex-1 text-xs sm:text-sm">
    <!-- Left side: vice name + points + streak + completion% -->
    <div class="habitName" title="${escapeHtml(h.name)}">
      ${escapeHtml(h.name)}
    </div>
    <div class="tag bg-zinc-200/60 dark:bg-zinc-700/60">
      ${h.pointsPerDay||0} pts
    </div>
  ${streak > 0 ? `
    <div class="tag streak-pill">
      ${streak} ${streak === 1 ? 'day' : 'days'}
    </div>
  ` : ''}
    <div class="tag bg-zinc-200/60 dark:bg-zinc-700/60 text-orange-400">
      ${completion}%
    </div>
  </div>
`;


      // Right side: controls only (Edit/Delete/‚ñ≤/‚ñº)
      const controlsHtml = `
        <div class="habitControls flex items-center gap-2 flex-wrap text-xs sm:text-sm">
          <button class="btn btn-ghost" data-act="habit-edit" data-id="${h.id}">Edit</button>
          <button class="btn btn-ghost" data-act="habit-delete" data-id="${h.id}">Delete</button>
          <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
                  data-act="habit-up" data-id="${h.id}">‚ñ≤</button>
          <button class="btn btn-ghost" style="padding:2px 6px;font-size:11px"
                  data-act="habit-down" data-id="${h.id}">‚ñº</button>
        </div>
      `;

      row.innerHTML = nameHtml + controlsHtml + daysRowHtml;
      wrap.appendChild(row);
    }

  });

  // Day toggles
  wrap.querySelectorAll('.habitDay').forEach(el => {
    el.onclick = () => toggleHabitDay(
      el.getAttribute('data-habit'),
      el.getAttribute('data-day')
    );
  });

  // Edit / delete
  wrap.querySelectorAll('[data-act="habit-edit"]').forEach(btn => {
    btn.onclick = () => {
      editingHabitId = btn.getAttribute('data-id');
      renderHabits();
      renderVices();
    };
  });
  wrap.querySelectorAll('[data-act="habit-delete"]').forEach(btn => {
    btn.onclick = () => deleteHabit(btn.getAttribute('data-id'));
  });

  // ‚¨ÜÔ∏è‚¨áÔ∏è NEW: reordering for vices too
  wrap.querySelectorAll('[data-act="habit-up"]').forEach(btn => {
    btn.onclick = () => moveHabit(btn.getAttribute('data-id'), -1);
  });
  wrap.querySelectorAll('[data-act="habit-down"]').forEach(btn => {
    btn.onclick = () => moveHabit(btn.getAttribute('data-id'), +1);
  });
}


function addHabit(){
  const name = $('habitName').value.trim();
  const pts  = Number($('habitPts').value)||0;
  if(!name) return alert('Enter a habit name');

  // Find the current max order among non-retired HABITS
  const maxOrder = state.habits
    .filter(x => !x.retired && (x.category || 'habit') === 'habit')
    .reduce((max, x) =>
      (typeof x.order === 'number' && x.order > max) ? x.order : max,
      0
    );

  const h = {
    id: crypto.randomUUID(),
    name,
    pointsPerDay: pts,
    doneKeys: [],
    createdAtISO: new Date().toISOString(),
    category: 'habit',
    order: maxOrder + 1
  };


  state.habits.push(h);
  save();
  $('habitName').value=''; $('habitPts').value='';

  renderHabits();
  renderVices();
  renderStats();
}

function addVice(){
  const name = $('viceName').value.trim();
  const pts  = Number($('vicePts').value)||0;
  if(!name) return alert('Enter a vice name');

  // Find the current max order among non-retired VICES
  const maxOrder = state.habits
    .filter(x => !x.retired && (x.category || 'habit') === 'vice')
    .reduce((max, x) =>
      (typeof x.order === 'number' && x.order > max) ? x.order : max,
      0
    );

  const h = {
    id: crypto.randomUUID(),
    name,
    pointsPerDay: pts,
    doneKeys: [],
    createdAtISO: new Date().toISOString(),
    category: 'vice',
    order: maxOrder + 1
  };


  state.habits.push(h);
  save();
  $('viceName').value=''; $('vicePts').value='';

  renderHabits();
  renderVices();
  renderStats();
}


function saveHabitEdit(id,row){
  const h=state.habits.find(x=>x.id===id); if(!h) return;
  const nameInput=row.querySelector('input[data-field="name"]');
  const ptsInput=row.querySelector('input[data-field="points"]');
  const catInput=row.querySelector('[data-field="category"]');

  const oldPoints = h.pointsPerDay || 0;

  h.name = nameInput.value.trim() || h.name;
  h.pointsPerDay = Number(ptsInput.value)||0;
  h.category = catInput ? (catInput.value || 'habit') : (h.category || 'habit');

  // update existing log entries
  if (h.pointsPerDay !== oldPoints) {
    state.completions.forEach(c => {
      if (c.source === 'habit' && c.habitId === id) {
        c.points = h.pointsPerDay;
      }
    });
  }

  editingHabitId=null;
  save(); 
  renderHabits(); 
  renderVices();
  renderStats();
}

function deleteHabit(id){
  if(!confirm('Delete this habit (keeps past log entries)?')) return;
  state.habits = state.habits.filter(x=>x.id!==id);
  if(editingHabitId===id) editingHabitId=null;
  save(); renderHabits(); renderStats(); renderVices();
}
function moveHabit(id, delta){
  const h = state.habits.find(x => x.id === id);
  if (!h) return;
  const category = h.category || 'habit';

  // All active items in the same category (habits or vices)
  const siblings = state.habits
    .filter(x => !x.retired && (x.category || 'habit') === category)
    .slice()
    .sort((a,b) => {
      const ao = (typeof a.order === 'number') ? a.order : 0;
      const bo = (typeof b.order === 'number') ? b.order : 0;
      if (ao !== bo) return ao - bo;
      const ac = a.createdAtISO || '';
      const bc = b.createdAtISO || '';
      return ac.localeCompare(bc);
    });

  if (!siblings.length) return;

  // Normalize orders to 1..N in current visual order
  siblings.forEach((x, idx) => { x.order = idx + 1; });

  const idx = siblings.findIndex(x => x.id === id);
  if (idx === -1) return;

  const newIdx = idx + delta;
  if (newIdx < 0 || newIdx >= siblings.length) return;

  const a = siblings[idx];
  const b = siblings[newIdx];
  const tmp = a.order;
  a.order = b.order;
  b.order = tmp;

  save();
  renderHabits();
  renderVices();
}

function toggleHabitDay(habitId, dayKey){
  const h = state.habits.find(x => x.id === habitId);
  if (!h || h.retired) return;

  const category = (h.category || 'habit');   // 'habit' or 'vice'
  const source   = category === 'vice' ? 'vice' : 'habit';

  h.doneKeys   = Array.isArray(h.doneKeys)   ? h.doneKeys   : [];
  h.failedKeys = Array.isArray(h.failedKeys) ? h.failedKeys : [];

  const removeCompletionForDay = () => {
    const mIdx = state.completions.findIndex(c =>
      (c.source === 'habit' || c.source === 'vice') &&
      c.habitId === habitId &&
      c.dayKey === dayKey
    );
    if (mIdx !== -1) state.completions.splice(mIdx, 1);
  };

  if (category === 'vice') {
    const doneIdx   = h.doneKeys.indexOf(dayKey);
    const failedIdx = h.failedKeys.indexOf(dayKey);

    if (doneIdx === -1 && failedIdx === -1) {
      // neutral ‚Üí completed (award points)
      h.doneKeys.push(dayKey);
      const iso = new Date(fromKey(dayKey).getTime() + 12 * 3600 * 1000).toISOString();
      addCompletion({
        id: crypto.randomUUID(),
        taskId: `habit:${habitId}:${dayKey}`,
        title: `[Habit] ${h.name} (${dayKey})`,
        points: h.pointsPerDay || 0,
        completedAtISO: iso,
        source,
        habitId: habitId,
        dayKey: dayKey
      });
    } else if (doneIdx !== -1) {
      // completed ‚Üí failed (remove points, mark failed)
      h.doneKeys.splice(doneIdx, 1);
      removeCompletionForDay();
      if (failedIdx === -1) h.failedKeys.push(dayKey);
    } else {
      // failed ‚Üí neutral
      h.failedKeys.splice(failedIdx, 1);
      removeCompletionForDay();
    }
  } else {
    // Habits keep simple toggle behavior
    const idx = h.doneKeys.indexOf(dayKey);
    if (idx === -1) {
      h.doneKeys.push(dayKey);
      const iso = new Date(fromKey(dayKey).getTime() + 12 * 3600 * 1000).toISOString();
      addCompletion({
        id: crypto.randomUUID(),
        taskId: `habit:${habitId}:${dayKey}`,
        title: `[Habit] ${h.name} (${dayKey})`,
        points: h.pointsPerDay || 0,
        completedAtISO: iso,
        source,
        habitId: habitId,
        dayKey: dayKey
      });
    } else {
      h.doneKeys.splice(idx, 1);
      removeCompletionForDay();
    }

    // If a failed marker snuck in (shouldn't happen for habits), clear it
    const failedIdx = h.failedKeys.indexOf(dayKey);
    if (failedIdx !== -1) h.failedKeys.splice(failedIdx, 1);
  }

  save();
  renderHabits();
  renderStats();
  renderVices();
}


/* ---------- FLEX ACTIONS ---------- */
function renderFlexActions(){
  const list = $('flexList'), empty = $('flexEmpty');
  if (!list || !empty) return;
  list.innerHTML = '';

  const items = Array.isArray(state.flexActions) ? state.flexActions : [];
  if (!items.length) {
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');

  items.forEach(f => {
    const row = document.createElement('div');
    row.className = 'glass flex flex-col sm:flex-row sm:items-start justify-between gap-3 flex-action-row';
    if (editingFlexId === f.id) {
      row.classList.add('flex-action-row--edit');
    }

    if (editingFlexId === f.id) {
      // üîß EDIT MODE
      row.innerHTML = `
        <div class="flex-1 min-w-0">
          <label class="text-xs muted block mb-1">Flex action</label>
          <input class="input w-full mb-2" data-field="name"
                 value="${escapeHtml(f.name || '')}">
          <label class="text-xs muted block mb-1">Points per use</label>
          <input class="input w-28" data-field="points" type="number" step="any"
                 value="${f.points || 0}">
        </div>
        <div class="flex gap-2 flex-wrap">
          <button class="btn btn-success btn-task" data-act="flex-save">Save</button>
          <button class="btn btn-ghost btn-task" data-act="flex-cancel">Cancel</button>
          <button class="btn btn-delete btn-task" data-act="flex-del" data-id="${f.id}">Delete</button>
        </div>
      `;
      list.appendChild(row);

      const saveBtn   = row.querySelector('[data-act="flex-save"]');
      const cancelBtn = row.querySelector('[data-act="flex-cancel"]');
      const delBtn    = row.querySelector('[data-act="flex-del"]');

      saveBtn.onclick   = () => saveFlexEdit(f.id, row);
      cancelBtn.onclick = () => { editingFlexId = null; renderFlexActions(); };
      delBtn.onclick    = () => deleteFlexAction(f.id);

    } else {
      // üìÑ NORMAL MODE
      row.innerHTML = `
        <div class="min-w-0 flex-action-main">
          <div class="font-medium truncate"
               title="${escapeHtml(f.name || '')}">
            ${escapeHtml(f.name || '')}
          </div>
          <div class="text-xs text-zinc-400">${f.points || 0} pts/use</div>
        </div>
        <div class="flex gap-2 flex-wrap flex-action-buttons">
          <button class="btn btn-ghost btn-task" data-act="flex-edit" data-id="${f.id}">Edit</button>
          <button class="btn btn-delete btn-task" data-act="flex-del" data-id="${f.id}">Delete</button>
          <button class="btn btn-success btn-task btn-check" data-act="flex-do" data-id="${f.id}" aria-label="Done">‚úì</button>
        </div>
      `;
      list.appendChild(row);
    }
  });

  // Wire normal-mode buttons
  list.querySelectorAll('[data-act="flex-do"]').forEach(btn => {
    btn.onclick = () => logFlexCompletion(btn.getAttribute('data-id'));
  });
  list.querySelectorAll('[data-act="flex-edit"]').forEach(btn => {
    btn.onclick = () => {
      editingFlexId = btn.getAttribute('data-id');
      renderFlexActions();
    };
  });
  list.querySelectorAll('[data-act="flex-del"]').forEach(btn => {
    btn.onclick = () => deleteFlexAction(btn.getAttribute('data-id'));
  });
}


function addFlexAction(){
  const nameEl = $('flexName');
  const ptsEl  = $('flexPts');
  const name = nameEl.value.trim();
  const pts = parseFloat(ptsEl.value);
  const safePts = Number.isFinite(pts) ? pts : 0;
  if(!name) return;
  if(!Array.isArray(state.flexActions)) state.flexActions = [];
  state.flexActions.push({
    id: crypto.randomUUID(),
    name,
    points: safePts
  });
  nameEl.value = '';
  ptsEl.value = '';
  save();
  renderFlexActions();
  renderStats();
}

function logFlexCompletion(id){
  if(!Array.isArray(state.flexActions)) state.flexActions = [];
  const f = state.flexActions.find(x=>x.id===id);
  if(!f) return;
  const now = new Date().toISOString();
  addCompletion({
    id: crypto.randomUUID(),
    taskId: null,
    flexId: id,
    title: `[Flex] ${f.name}`,
    points: f.points || 0,
    completedAtISO: now,
    source: 'flex'
  });

  save();
  renderAll();
}

function saveFlexEdit(id, row){
  if (!Array.isArray(state.flexActions)) state.flexActions = [];
  const f = state.flexActions.find(x => x.id === id);
  if (!f) return;

  const nameInput = row.querySelector('input[data-field="name"]');
  const ptsInput  = row.querySelector('input[data-field="points"]');

  if (nameInput) {
    const trimmed = nameInput.value.trim();
    if (trimmed) f.name = trimmed;
  }

  if (ptsInput) {
    const pts = parseFloat(ptsInput.value);
    if (Number.isFinite(pts)) f.points = pts;
  }

  editingFlexId = null;
  save();
  renderFlexActions();
  renderStats(); // points per use changed => stats affected
}


/* ---------- TASKS ---------- */
function renderTasks(){
  const container=$('taskList'), empty=$('emptyList'); container.innerHTML='';
  const active=state.tasks.filter(t=>!t.completedAtISO && !t.hidden);
  if(!active.length){ empty.classList.remove('hidden'); } else empty.classList.add('hidden');

  const sort=$('sortSelect').value;
  let tasks=active.slice();
  if(sort==='due'){
    tasks.sort((a,b)=>(a.dueDateISO||'').localeCompare(b.dueDateISO||'') || cmpImportance(b,a) || (b.points-a.points));
  }else if(sort==='importance'){
    tasks.sort((a,b)=>cmpImportance(b,a) || (a.dueDateISO||'').localeCompare(b.dueDateISO||''));
  }else if(sort==='points'){
    tasks.sort((a,b)=>b.points-a.points || (a.dueDateISO||'').localeCompare(b.dueDateISO||''));
  }else{
    tasks.sort((a,b)=>a.title.localeCompare(b.title));
  }

  const today = new Date(); today.setHours(0,0,0,0);
  const overdueBucket = { label:'Overdue', key:'overdue', items:[] };
  const dmap = {};
  for(let i=0;i<7;i++){ const d=addDays(today,i); const k=dateKey(d); dmap[k]={ label:labelForDay(d,today), key:k, date:d, items:[] }; }
  const laterBucket = { label:'Later', key:'later', items:[] };
  const nodueBucket = { label:'No due date', key:'nodue', items:[] };

  for(const t of tasks){
    if(!t.dueDateISO){ nodueBucket.items.push(t); continue; }
    if(t.dueDateISO < dateKey(today)) overdueBucket.items.push(t);
    else if(dmap[t.dueDateISO]) dmap[t.dueDateISO].items.push(t);
    else laterBucket.items.push(t);
  }

  const order=[overdueBucket, ...Object.values(dmap), laterBucket, nodueBucket];
  for(const b of order){
    if(b.items.length===0) continue;
    const div=document.createElement('div');
    div.innerHTML=`<div class="sectionDivider">${b.label}</div>`;
    container.appendChild(div);

    b.items.forEach(t=>{
      const isOverdue = t.dueDateISO && t.dueDateISO < dateKey(today);
      const postponeDays = Number(t.postponedDays) || 0;
      const showPostponePill = postponeDays > 0 && !!t.dueDateISO;

const badge = {
  Low:      'bg-transparent text-zinc-500 border border-zinc-700',
  Medium:   'bg-teal-400/40 text-teal-950',      // darker text for visibility
  High:     'tag-high',
  Critical: 'tag-critical'
}[t.importance] || 'bg-zinc-300/60 text-zinc-950';

      // Build tags row if this task has tags
      const tags = Array.isArray(t.tags) ? t.tags : [];
const tagsHtml = tags.length
  ? tags.map(tag =>
      `<span class="tag bg-zinc-700/40">${escapeHtml(tag)}</span>`
    ).join('')
  : '';


      const card = document.createElement('div');
const cardClasses = ['glass'];
if (t.importance === 'Critical') cardClasses.push('critical-card');
else if (t.importance === 'High') cardClasses.push('high-card');
card.className = cardClasses.join(' ');


if (editingTaskId === t.id) {
  const rec = t.recurrence || {};
  const recMode = rec.mode || 'none';
  const recCount = Number.isFinite(rec.customCount) && rec.customCount > 0 ? rec.customCount : 1;
  const recUnit  = rec.customUnit || 'day';

  card.innerHTML = `
    <div class="flex flex-col gap-3">
      <div class="grid gap-2 sm:grid-cols-2">
        <div class="sm:col-span-2">
          <label class="text-xs muted">Title</label>
          <input class="input mt-1" data-field="title" value="${escapeHtml(t.title)}">
        </div>
        <div>
          <label class="text-xs muted">Importance</label>
          <select class="input mt-1" data-field="importance">
            <option ${t.importance==='Low'?'selected':''}>Low</option>
            <option ${t.importance==='Medium'?'selected':''}>Medium</option>
            <option ${t.importance==='High'?'selected':''}>High</option>
            <option ${t.importance==='Critical'?'selected':''}>Critical</option>
          </select>
        </div>
        <div>
          <label class="text-xs muted">Due Date</label>
          <input class="input mt-1" type="date" data-field="due" value="${t.dueDateISO||''}">
        </div>
        <div>
          <label class="text-xs muted">Points</label>
          <input class="input mt-1" type="number" data-field="points" value="${t.points||0}">
        </div>
        <div>
          <label class="text-xs muted">Repeat</label>
          <select class="input mt-1" data-field="repeat">
            <option value="none" ${recMode==='none'?'selected':''}>Does not repeat</option>
            <option value="daily" ${recMode==='daily'?'selected':''}>Daily</option>
            <option value="everyWeekday" ${recMode==='everyWeekday'?'selected':''}>Every Weekday</option>
            <option value="weekly" ${recMode==='weekly'?'selected':''}>Weekly</option>
            <option value="monthly" ${recMode==='monthly'?'selected':''}>Monthly</option>
            <option value="yearly" ${recMode==='yearly'?'selected':''}>Yearly</option>
            <option value="custom" ${recMode==='custom'?'selected':''}>Custom‚Ä¶</option>
          </select>

          <div class="flex items-center gap-2 text-xs mt-2 repeat-custom-row ${recMode==='custom'?'':'hidden'}">
            <span class="muted">Repeat every</span>
            <input type="number" min="1" class="input w-16" data-field="repeatCustomCount" value="${recCount}">
            <select class="input w-24 text-xs" data-field="repeatCustomUnit">
              <option value="day" ${recUnit==='day'?'selected':''}>day(s)</option>
              <option value="week" ${recUnit==='week'?'selected':''}>week(s)</option>
              <option value="month" ${recUnit==='month'?'selected':''}>month(s)</option>
              <option value="year" ${recUnit==='year'?'selected':''}>year(s)</option>
            </select>
          </div>
        </div>
        <div class="sm:col-span-2">
          <label class="text-xs muted">Tags</label>
          <input class="input mt-1" data-field="tags" value="${(Array.isArray(t.tags) ? t.tags : []).join(', ')}">
        </div>
      </div>
      <div class="flex gap-2 flex-wrap justify-end">
        <button class="btn btn-success" data-act="task-save">Save</button>
        <button class="btn btn-ghost" data-act="task-cancel">Cancel</button>
        <button class="btn btn-ghost" data-act="task-delete">Delete</button>
      </div>
    </div>
  `;

  // ‚¨áÔ∏è keep this
  container.appendChild(card);

  // wire up custom row toggle for this card
  const repSel = card.querySelector('select[data-field="repeat"]');
  const customRow = card.querySelector('.repeat-custom-row');
  if (repSel && customRow) {
    const toggle = () => {
      if (repSel.value === 'custom') customRow.classList.remove('hidden');
      else customRow.classList.add('hidden');
    };
    repSel.addEventListener('change', toggle);
    toggle();
  }

  // ‚¨áÔ∏è keep these exactly like before
  const saveBtn   = card.querySelector('[data-act="task-save"]');
  const cancelBtn = card.querySelector('[data-act="task-cancel"]');
  const delBtn    = card.querySelector('[data-act="task-delete"]');

  saveBtn.onclick   = () => saveTaskEdit(t.id,card);
  cancelBtn.onclick = () => { editingTaskId=null; renderTasks(); };
  delBtn.onclick    = () => deleteTask(t.id);
} else {
card.innerHTML=`
  <div class="flex flex-wrap sm:flex-nowrap items-center gap-3">
    <div class="taskPoints flex flex-col items-center justify-center">
      <div class="taskPointsNumber">${t.points}</div>
      <div class="taskPointsLabel muted">pts</div>
    </div>
<div class="title-wrap min-w-0 flex-1">
  <div class="font-semibold task-title">${escapeHtml(t.title)}</div>

  <div class="flex gap-2 text-xs mt-1 flex-wrap">
    <span class="tag ${badge}">${t.importance}</span>

${t.dueDateISO
  ? `<span class="tag ${isOverdue ? 'bg-rose-600/70 text-rose-50' : 'bg-zinc-700/40'}">
       ${niceDate(fromKey(t.dueDateISO))}
     </span>${showPostponePill ? `<span class="tag postpone-pill">+${postponeDays}d</span>` : ''}`
  : ''
}


    ${tagsHtml}
  </div>
</div>


    <div class="flex gap-2 flex-wrap justify-end ml-auto">
      ${isOverdue?`<button class="btn btn-ghost btn-task" onclick="postponeTask('${t.id}')">Postpone</button>`:''}
      <button class="btn btn-ghost btn-task" onclick="wontDoMain('${t.id}')">Won‚Äôt do</button>
      <button class="btn btn-ghost btn-task" onclick="bumpTaskOneDay('${t.id}')">+1d</button>
      <button class="btn btn-ghost btn-task" onclick="editTask('${t.id}')">Edit</button>
      <button class="btn btn-ghost btn-task" onclick="hideTask('${t.id}')">Hide</button>
      <button class="btn btn-delete btn-task" onclick="deleteTask('${t.id}')">Delete</button>
      <button class="btn btn-success btn-task btn-check" onclick="completeTask('${t.id}')" aria-label="Done">‚úì</button>

    </div>
  </div>`;

        container.appendChild(card);
      }
    });
  }
}

function saveSleepScore(){
  const rawStr = $('sleepScoreInput').value.trim();
  if (rawStr === '') return alert("Enter your sleep score (0‚Äì100).");

  const raw = Number(rawStr);
  if (Number.isNaN(raw) || raw < 0 || raw > 100) {
    return alert("Sleep score must be between 0 and 100.");
  }

  const restedStr = $('sleepRestedInput')?.value.trim() ?? '';
  const rested = restedStr === '' ? 0 : Number(restedStr);
  if (!Number.isFinite(rested)) {
    return alert("Rested value must be a valid number.");
  }

  const pts = sleepPoints(raw, rested); // e.g. 97 ‚Üí 10.7 plus rest

  // Use today's date (local) and normalize so timezones don't mess the day
  const d = new Date();
  d.setHours(12, 0, 0, 0);        // force midday
  const key = dateKey(d);         // e.g. "2025-12-03"
  const whenISO = d.toISOString();

  // Look for an existing Sleep Score entry for this same day
  let existing = null;
  for (const c of state.completions) {
    if (!c.title || !c.title.startsWith('Sleep Score')) continue;
    const cd = new Date(c.completedAtISO);
    if (dateKey(cd) === key) {
      existing = c;
      break;
    }
  }

  if (existing) {
    // Update today's sleep entry
    existing.title = `Sleep Score (${raw}) ‚Äî Rest ${rested}`;
    existing.points = pts;
    existing.sleepRested = rested;
    existing.completedAtISO = whenISO;
  } else {
    // Create a new one if none exists for today
    state.completions.unshift({
      id: crypto.randomUUID(),
      taskId: null,
      title: `Sleep Score (${raw}) ‚Äî Rest ${rested}`,
      points: pts,
      completedAtISO: whenISO,
      sleepRested: rested,
      source: "task"
    });
  }

  $('sleepScoreInput').value = "";  // clear input
  const restInput = $('sleepRestedInput');
  if (restInput) restInput.value = "";

  save();
  renderAll();  // refresh stats, history chips, etc.
}

function editTodaySleepScore() {
  const entry = getTodaySleepEntry();
  if (!entry) return alert("You haven't entered today's sleep score yet.");

  promptEditSleepEntry(entry);
}


function saveCalories(){
  const rawStr = $('caloriesInput').value.trim();
  if (rawStr === '') return alert("Enter today's calories.");

  const raw = Number(rawStr);
  if (Number.isNaN(raw) || raw < 0) return alert("Calories can‚Äôt be negative.");

  const pts = caloriesToPoints(raw);

  // 1) Figure out what date this entry is for (date picker or today)
  const dateStr = $('caloriesDate') ? $('caloriesDate').value : '';
  let d;
  if (dateStr) {
    const [y, m, day] = dateStr.split('-').map(n => parseInt(n, 10));
    d = new Date(y, m - 1, day);
  } else {
    d = new Date();
  }
  // normalize so timezones don't bump it to the wrong day
  d.setHours(12, 0, 0, 0);
  const key = dateKey(d);
  const whenISO = d.toISOString();

  // 2) Look for an existing Calories entry for this same date
  let existing = null;
  for (const c of state.completions) {
    if (!c.title || !c.title.startsWith('Calories')) continue;
    const cd = new Date(c.completedAtISO);
    if (dateKey(cd) === key) {
      existing = c;
      break;
    }
  }

  // 3) If we found one, UPDATE it; otherwise, create a new one
  if (existing) {
    existing.title = `Calories (${raw})`;
    existing.points = pts;
    existing.completedAtISO = whenISO;
  } else {
    state.completions.unshift({
      id: crypto.randomUUID(),
      taskId: null,
      title: `Calories (${raw})`,
      points: pts,
      completedAtISO: whenISO,
      source: "task"
    });
  }

  $('caloriesInput').value = '';
  // optional: keep the chosen date in the picker so you can tweak same day

  save();
  renderAll();
}


function formatCaloriesDateLabel(value) {
  if (!value) return '';
  const [y, m, d] = value.split('-').map(v => parseInt(v, 10));
  if (!y || !m || !d) return '';
  return `${m}/${d}`;
}

function initCaloriesDatePicker(){
  const dateInput = $('caloriesDate');
  const label = $('caloriesDateLabel');
  if(!dateInput || !label) return;

  dateInput.addEventListener('change', () => {
    const picked = dateInput.value; // "YYYY-MM-DD"
    if(!picked){
      label.textContent = '';
      return;
    }

    const [y, m, d] = picked.split('-').map(Number);
    const dt = new Date(y, m - 1, d);

    label.textContent = `üìÖ ${dt.toLocaleDateString([], { month:'short', day:'numeric', year:'numeric' })}`;
  });
}



function renderSleepHistory() {
  const container = $('sleepHistory');
  if (container) container.innerHTML = '';

  const sleepEntries = state.completions
    .filter(c => c.title && c.title.startsWith('Sleep Score'))
    .slice()
    .sort((a,b) => new Date(b.completedAtISO) - new Date(a.completedAtISO));

  // --- LEFT SIDE: Today's big stat ---
  const todayKey = dateKey(new Date());
  const todayEntry = getTodaySleepEntry();

  const todayValueEl   = $('sleepTodayValue');
  const todayImpactEl  = $('sleepTodayImpact');
  const todayRestChip  = $('sleepTodayRest');
  const todayRestValue = $('sleepTodayRestValue');
  const sleepInputRow  = $('sleepInputRow');

const sleepSummaryRow = $('sleepSummaryRow');
const sleepSummaryValue = $('sleepSummaryValue');
const sleepSummaryRest = $('sleepSummaryRest');
const sleepSummaryRestValue = $('sleepSummaryRestValue');
const sleepSummaryImpact = $('sleepSummaryImpact');

   const sleepImpactBelow      = $('sleepImpactBelow');


  
  const setTodaySleepEditable = (el) => {
    if (!el) return;
    if (todayEntry) {
      el.classList.add('cursor-pointer');
      el.setAttribute('role', 'button');
      el.setAttribute('tabindex', '0');
      el.onclick = editTodaySleepScore;
      el.onkeydown = (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          editTodaySleepScore();
        }
      };
    } else {
      el.classList.remove('cursor-pointer');
      el.removeAttribute('role');
      el.removeAttribute('tabindex');
      el.onclick = null;
      el.onkeydown = null;
    }
  };

  if (todayValueEl && todayImpactEl) {
    if (todayEntry) {
      const { score, rested } = getSleepInfo(todayEntry);
      if (score != null && !Number.isNaN(score)) {
        todayValueEl.textContent = score;

        const hasRest = Number.isFinite(rested) && rested !== 0;
        if (todayRestChip && todayRestValue) {
          if (hasRest) {
            todayRestValue.textContent = rested > 0 ? `+${rested}` : `${rested}`;
            todayRestChip.classList.remove('hidden');
          } else {
            todayRestChip.classList.add('hidden');
            todayRestValue.textContent = '';
          }
        }

        const totalPts = sleepPoints(score, rested);
const base  = score / 10;
const bonus = sleepBonus(score);
const rest  = Number.isFinite(rested) ? rested : 0;

const parts = [base];
if (bonus) parts.push(bonus);
if (rest)  parts.push(rest);

const breakdown = parts.map(v => Number(v).toFixed(1)).join(' + ');

if (sleepImpactBelow) {
  sleepImpactBelow.textContent = `adds ${totalPts.toFixed(1)} pts (${breakdown})`;
}

        const restText = hasRest ? ` (${rested >= 0 ? '+' : ''}${rested})` : '';

// --- Mobile summary line: "- 90" and optional (+rested) chip ---
if (sleepSummaryValue && sleepSummaryRow) {
  sleepSummaryValue.textContent = `${score}`;

  // show (+rested) chip
  if (sleepSummaryRest && sleepSummaryRestValue) {
    if (hasRest) {
      sleepSummaryRestValue.textContent = rested > 0 ? `+${rested}` : `${rested}`;
      sleepSummaryRest.classList.remove('hidden');
    } else {
      sleepSummaryRest.classList.add('hidden');
      sleepSummaryRestValue.textContent = '';
    }
  }
}

if (sleepSummaryImpact) {
  const base  = score / 10;
  const bonus = sleepBonus(score);
  const rest  = Number.isFinite(rested) ? rested : 0;

  const parts = [base];
  if (bonus) parts.push(bonus);
  if (rest)  parts.push(rest);

  const breakdown = parts.map(v => Number(v).toFixed(1)).join(' + ');
  sleepSummaryImpact.textContent = `adds ${totalPts.toFixed(1)} pts (${breakdown})`;
}



        
        todayImpactEl.textContent = `Adds ${totalPts.toFixed(1)} pts to today${restText}`;
        todayImpactEl.dataset.empty = 'false';
      } else {
        todayValueEl.textContent = '‚Äî';
        todayImpactEl.textContent = 'Adds ‚Äî pts to today';
        todayImpactEl.dataset.empty = 'true';
      }
    } else {
      todayValueEl.textContent = '‚Äî';
      todayImpactEl.textContent = 'Adds 0 pts to today';
      todayImpactEl.dataset.empty = 'true';
    }
  }

  if (todayRestChip && todayRestValue && !todayEntry) {
    todayRestChip.classList.add('hidden');
    todayRestValue.textContent = '';
  }

  setTodaySleepEditable(todayValueEl);
  setTodaySleepEditable(todayRestChip);
  setTodaySleepEditable(todayImpactEl);
  setTodaySleepEditable(sleepSummaryRow);


if (todayEntry) {
  sleepInputRow?.classList.add('hidden');
  sleepSummaryRow?.classList.remove('hidden');
  sleepImpactBelow?.classList.remove('hidden');
} else {
  sleepInputRow?.classList.remove('hidden');
  sleepSummaryRow?.classList.add('hidden');
  sleepImpactBelow?.classList.add('hidden');
  if (sleepImpactBelow) sleepImpactBelow.textContent = '';
}





  // --- RIGHT SIDE: recent nights chips ---
  // Show the 4 most recent *prior* nights (exclude today's entry if present)
  const recent = sleepEntries
    .filter(entry => {
      const d = new Date(entry.completedAtISO);
      return dateKey(d) !== todayKey;
    })
    .slice(0, 6);

  if (!container) return;


  recent.forEach(entry => {
    const date = new Date(entry.completedAtISO);

    const prettyDate = date.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'numeric',
      day: 'numeric'
    });

    const { score, rested } = getSleepInfo(entry);
    const pts   = sleepPoints(score, rested).toFixed(1);
    const restLabel = rested ? `<div class="sleep-chip-rest muted text-[11px]">${rested > 0 ? `+${rested}` : rested}</div>` : '';
    const scoreDisplay = Number.isFinite(score) ? score : '?';

    const block = document.createElement('div');
    block.className = 'sleep-chip cursor-pointer';

    block.innerHTML = `
      <div class="sleep-chip-date">${prettyDate}</div>
      <div class="sleep-chip-score">${scoreDisplay}</div>
      <div class="sleep-chip-pts">${pts} pts</div>
      ${restLabel}
    `;




    block.onclick = () => {
      promptEditSleepEntry(entry);
    };

    container.appendChild(block);
  });
}

function renderCaloriesHistory() {
  const container = $('caloriesHistory');
  if (container) container.innerHTML = '';

  const entries = state.completions
    .filter(c => c.title && c.title.startsWith('Calories'))
    .slice()
    .sort((a,b) => new Date(b.completedAtISO) - new Date(a.completedAtISO));

  const todayKey = dateKey(new Date());
  const todayEntry = getTodayCaloriesEntry();

  // Big Today stat
  const todayValueEl  = $('caloriesTodayValue');
  const todayImpactEl = $('caloriesTodayImpact');

  const inputRow = $('caloriesInputRow');
  const dateInput = $('caloriesDate');
  const dateLabel = $('caloriesDateLabel');
  const caloriesSummaryRow   = $('caloriesSummaryRow');
const caloriesSummaryValue = $('caloriesSummaryValue');
const caloriesImpactBelow  = $('caloriesImpactBelow');
const impactBelow  = $('caloriesImpactBelow');
const summaryRow   = $('caloriesSummaryRow');
const summaryValue = $('caloriesSummaryValue');


  const setTodayCaloriesEditable = (el) => {
    if (!el) return;
    if (todayEntry) {
      el.classList.add('cursor-pointer');
      el.setAttribute('role', 'button');
      el.setAttribute('tabindex', '0');
      el.onclick = editTodayCalories;
      el.onkeydown = (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          editTodayCalories();
        }
      };
    } else {
      el.classList.remove('cursor-pointer');
      el.removeAttribute('role');
      el.removeAttribute('tabindex');
      el.onclick = null;
      el.onkeydown = null;
    }
  };

// hide the entry UI once today exists (Sleep-style)
if (todayEntry) {
  inputRow?.classList.add('hidden');
  dateLabel?.classList.add('hidden');

  // show mobile summary + impact-below
  summaryRow?.classList.remove('hidden');
  impactBelow?.classList.remove('hidden');
} else {
  inputRow?.classList.remove('hidden');
  dateLabel?.classList.remove('hidden');

  // hide mobile summary + impact-below
  summaryRow?.classList.add('hidden');
  if (summaryValue) summaryValue.textContent = '';
  impactBelow?.classList.add('hidden');
  if (impactBelow) impactBelow.textContent = '';

  // optional: default back to ‚Äútoday‚Äù mode
  if (dateInput) dateInput.value = '';
  if (dateLabel) dateLabel.textContent = '';
}



  setTodayCaloriesEditable(todayValueEl);
  setTodayCaloriesEditable(todayImpactEl);

  
  if (todayValueEl && todayImpactEl) {
    if (todayEntry) {
      const titleMatch = todayEntry.title.match(/\((\d+)\)/);
      const calNum = titleMatch ? Number(titleMatch[1]) : null;

      if (calNum != null && !Number.isNaN(calNum)) {
        todayValueEl.textContent = calNum;
if (caloriesSummaryValue) caloriesSummaryValue.textContent = String(calNum);
if (caloriesImpactBelow) caloriesImpactBelow.textContent = `Adds ${pts.toFixed(1)} pts to today`;

        const pts = caloriesToPoints(calNum);
        todayImpactEl.textContent = `Adds ${pts.toFixed(1)} pts to today`;
        if (summaryValue) summaryValue.textContent = String(calNum);
if (impactBelow) impactBelow.textContent = todayImpactEl.textContent;

        todayImpactEl.dataset.empty = 'false';
      } else {
        todayValueEl.textContent = '‚Äî';
        todayImpactEl.textContent = 'Adds ‚Äî pts to today';
        todayImpactEl.dataset.empty = 'true';
      }
    } else {
      todayValueEl.textContent = '‚Äî';
      todayImpactEl.textContent = 'Adds 0 pts to today';
      todayImpactEl.dataset.empty = 'true';
    }
  }

  // Recent (max 4) excluding today
  const recent = entries
    .filter(entry => dateKey(new Date(entry.completedAtISO)) !== todayKey)
    .slice(0, 6);

  if (!container) return;

  recent.forEach(entry => {
    const date = new Date(entry.completedAtISO);

    const prettyDate = date.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'numeric',
      day: 'numeric'
    });

    const cal = entry.title.match(/\((\d+)\)/)?.[1] || '?';
    const pts = (Number(entry.points) || 0).toFixed(1);

    const block = document.createElement('div');
    block.className = 'cal-chip cursor-pointer';

    block.innerHTML = `
      <div class="cal-chip-date">${prettyDate}</div>
      <div class="cal-chip-value">${cal}</div>
      <div class="cal-chip-pts">${pts} pts</div>
    `;


    // allow editing a past day
    block.onclick = () => {
      const newVal = prompt('Edit calories for this day:', cal);
      if (!newVal && newVal !== '0') return;

      const raw = Number(newVal);
      if (isNaN(raw) || raw < 0) return alert('Invalid calories.');

      entry.title  = `Calories (${raw})`;
      entry.points = caloriesToPoints(raw);

      save();
      renderAll();
    };

    container.appendChild(block);
  });
}

function getTodayWorkEntry() {
  const todayKey = dateKey(new Date());
  for (const entry of state.completions) {
    if (!entry?.title?.startsWith("Work Score")) continue;
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayKey) return entry;
  }
  return null;
}

function editTodayWork() {
  const entry = getTodayWorkEntry();
  if (!entry) return alert("You haven't entered today's work score yet.");

  promptEditWorkEntry(entry, { pinToToday: true });
}

  
function saveWorkScore() {
  const rawStr = $('workScoreInput').value.trim();
  if (rawStr === '') return alert("Enter your work score.");

  const raw = Number(rawStr);
  if (Number.isNaN(raw)) return alert("Work Score must be a number.");

  const hoursStr = $('workHoursInput')?.value.trim() ?? '';
  const hoursVal = hoursStr === '' ? 0 : Number(hoursStr);
  if (!Number.isFinite(hoursVal)) return alert("Hours value must be a number.");
  const safeHours = Math.max(0, hoursVal);

  // Direct 1:1 mapping ‚Üí 7 becomes 7 pts
  const pts = workPoints(raw, safeHours);

  // Date normalized so it always logs to the correct day
  const d = new Date();
  d.setHours(12, 0, 0, 0);
  const key = dateKey(d);
  const whenISO = d.toISOString();

  // Look for an existing Work Score entry for today
  let existing = null;
  for (const c of state.completions) {
    if (!c.title || !c.title.startsWith('Work Score')) continue;
    const cd = new Date(c.completedAtISO);
    if (dateKey(cd) === key) {
      existing = c;
      break;
    }
  }

  if (existing) {
    existing.title = `Work Score (${raw}) ‚Äî Hours ${safeHours}`;
    existing.points = pts;
    existing.workHours = safeHours;
    existing.source = 'work';
    existing.completedAtISO = whenISO;
  } else {
    state.completions.unshift({
      id: crypto.randomUUID(),
      title: `Work Score (${raw}) ‚Äî Hours ${safeHours}`,
      points: pts,
      completedAtISO: whenISO,
      workHours: safeHours,
      source: "work"
    });
  }

  $('workScoreInput').value = "";
  const hoursInput = $('workHoursInput');
  if (hoursInput) hoursInput.value = "";

  save();
  renderAll();
}

function renderWorkHistory() {
  const container = $('workHistory');
  if (container) container.innerHTML = '';
  if (!container) return;

  const entries = state.completions
    .filter(c => c.title && c.title.startsWith('Work Score'))
    .slice()
    .sort((a,b) => new Date(b.completedAtISO) - new Date(a.completedAtISO));

  // TODAY
  const today = new Date();
  const todayK = dateKey(today);
  let todayEntry = null;

  for (const entry of entries) {
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayK) {
      todayEntry = entry;
      break;
    }
  }

  const todayValueEl = $('workTodayValue');
  const todayImpactEl = $('workTodayImpact');
  const inputRow = $('workInputRow');
  const todayHoursChip = $('workTodayHours');
  const todayHoursValue = $('workTodayHoursValue');
  const setTodayWorkEditable = (el) => {
    if (!el) return;
    if (todayEntry) {
      el.classList.add('cursor-pointer');
      el.setAttribute('role', 'button');
      el.setAttribute('tabindex', '0');
      el.title = "Tap/click to edit today's work score";
      el.onclick = editTodayWork;
      el.onkeydown = (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          editTodayWork();
        }
      };
    } else {
      el.classList.remove('cursor-pointer');
      el.removeAttribute('role');
      el.removeAttribute('tabindex');
      el.title = "";
      el.onclick = null;
      el.onkeydown = null;
    }
  };


if (todayValueEl && todayImpactEl) {
  if (todayEntry) {
    const { score, hours } = getWorkInfo(todayEntry);
    if (!Number.isNaN(score) && score !== null) {
      todayValueEl.textContent = score;

      const hasHours = Number.isFinite(hours) && hours !== 0;
      if (todayHoursChip && todayHoursValue) {
        if (hasHours) {
          todayHoursValue.textContent = hours > 0 ? `+${hours}` : `${hours}`;
          todayHoursChip.classList.remove('hidden');
        } else {
          todayHoursChip.classList.add('hidden');
          todayHoursValue.textContent = '';
        }
      }

      const totalPts = workPoints(score, hours);
      const hoursText = hasHours ? ` (${hours >= 0 ? '+' : ''}${hours})` : '';
      todayImpactEl.textContent = `Adds ${totalPts.toFixed(1)} pts to today${hoursText}`;
      todayImpactEl.dataset.empty = 'false';

      // ‚úÖ hide input row after initial entry
      inputRow?.classList.add('hidden');
    } else {
      todayValueEl.textContent = '‚Äî';
      todayImpactEl.textContent = 'Adds ‚Äî pts to today';
      todayImpactEl.dataset.empty = 'true';
    }
  } else {
    todayValueEl.textContent = '‚Äî';
    todayImpactEl.textContent = 'Adds 0 pts to today';
    todayImpactEl.dataset.empty = 'true';

    if (todayHoursChip && todayHoursValue) {
      todayHoursChip.classList.add('hidden');
      todayHoursValue.textContent = '';
    }

    // ‚úÖ show input row if no entry yet
    inputRow?.classList.remove('hidden');
  }
}

  setTodayWorkEditable(todayValueEl);
  setTodayWorkEditable(todayImpactEl);
  setTodayWorkEditable(todayHoursChip);


  // RECENT HISTORY (4 chips)
  const recent = entries
    .filter(e => dateKey(new Date(e.completedAtISO)) !== todayK)
    .slice(0, 6);

  recent.forEach(entry => {
    const date = new Date(entry.completedAtISO);

    const prettyDate = date.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'numeric',
      day: 'numeric'
    });

    const { score, hours } = getWorkInfo(entry);
    const val = Number.isFinite(score) ? score : '?';
    const safeHours = Number.isFinite(hours) ? hours : 0;
    const pts = workPoints(val, safeHours).toFixed(1);
    const hoursBonus = workHoursBonus(safeHours);
    const hoursDisplay = Number.isFinite(hoursBonus)
      ? `${hoursBonus >= 0 ? '+' : ''}${hoursBonus.toFixed(1)}`
      : '';

    const block = document.createElement('div');
    block.className = 'work-chip cursor-pointer';

    block.innerHTML = `
      <div class="work-chip-date">${prettyDate}</div>
      <div class="work-chip-value">${val}</div>
      <div class="work-chip-pts">${pts} pts</div>
      <div class="work-chip-bonus">${hoursDisplay}</div>
    `;

    block.onclick = () => {
      promptEditWorkEntry(entry);
    };

    container.appendChild(block);
  });
}

  function getTodayMoodEntry() {
  const todayKeyStr = dateKey(new Date());
  for (const c of state.completions) {
    if (!c?.title?.startsWith('Mood Score')) continue;
    const d = new Date(c.completedAtISO);
    if (dateKey(d) === todayKeyStr) return c;
  }
  return null;
}

function editTodayMood() {
  const entry = getTodayMoodEntry();
  if (!entry) return alert("You haven't entered today's mood score yet.");

  const current = entry.title.match(/\((.+)\)/)?.[1] ?? "";
  const newVal = prompt("Edit today's mood score:", String(current));
  if (newVal === null) return;

  const num = Number(String(newVal).trim());
  if (Number.isNaN(num)) return alert("Invalid mood score.");

  const d = new Date();
  d.setHours(12, 0, 0, 0);

  entry.title = `Mood Score (${num})`;
  entry.points = num;
  entry.completedAtISO = d.toISOString();

  save();
  renderAll();
}

function saveMoodScore() {
  const rawStr = $('moodScoreInput').value.trim();
  if (rawStr === '') return alert("Enter your mood score.");

  const raw = Number(rawStr);
  if (Number.isNaN(raw)) return alert("Mood Score must be a number.");

  const pts = raw;

  const d = new Date();
  d.setHours(12, 0, 0, 0);
  const key = dateKey(d);
  const whenISO = d.toISOString();

  let existing = null;
  for (const c of state.completions) {
    if (!c.title || !c.title.startsWith('Mood Score')) continue;
    const cd = new Date(c.completedAtISO);
    if (dateKey(cd) === key) { existing = c; break; }
  }

  if (existing) {
    existing.title = `Mood Score (${raw})`;
    existing.points = pts;
    existing.completedAtISO = whenISO;
  } else {
    state.completions.unshift({
      id: crypto.randomUUID(),
      title: `Mood Score (${raw})`,
      points: pts,
      completedAtISO: whenISO,
      source: "task"
    });
  }

  $('moodScoreInput').value = "";
  save();
  renderAll();
}

function renderMoodHistory() {
  const container = $('moodHistory');
  if (container) container.innerHTML = '';

  const entries = state.completions
    .filter(c => c.title && c.title.startsWith('Mood Score'))
    .slice()
    .sort((a,b) => new Date(b.completedAtISO) - new Date(a.completedAtISO));

  const today = new Date();
  const todayK = dateKey(today);

  let todayEntry = null;
  for (const entry of entries) {
    const d = new Date(entry.completedAtISO);
    if (dateKey(d) === todayK) { todayEntry = entry; break; }
  }

  const todayValueEl = $('moodTodayValue');
  const todayImpactEl = $('moodTodayImpact');
  const inputRow = $('moodInputRow');
  const setTodayMoodEditable = (el) => {
    if (!el) return;
    if (todayEntry) {
      el.classList.add('cursor-pointer');
      el.setAttribute('role', 'button');
      el.setAttribute('tabindex', '0');
      el.title = "Tap/click to edit today's mood score";
      el.onclick = editTodayMood;
      el.onkeydown = (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          editTodayMood();
        }
      };
    } else {
      el.classList.remove('cursor-pointer');
      el.removeAttribute('role');
      el.removeAttribute('tabindex');
      el.title = "";
      el.onclick = null;
      el.onkeydown = null;
    }
  };

  if (todayValueEl && todayImpactEl) {
    if (todayEntry) {
      const num = Number(todayEntry.title.match(/\((.+)\)/)?.[1] || NaN);
      if (!isNaN(num)) {
        todayValueEl.textContent = num;
        todayImpactEl.textContent = `Adds ${todayEntry.points} pts to today`;
        todayImpactEl.dataset.empty = 'false';
      } else {
        todayValueEl.textContent = '‚Äî';
        todayImpactEl.textContent = 'Adds ‚Äî pts to today';
        todayImpactEl.dataset.empty = 'true';
      }

      inputRow?.classList.add('hidden');
    } else {
      todayValueEl.textContent = '‚Äî';
      todayImpactEl.textContent = 'Adds 0 pts to today';
      todayImpactEl.dataset.empty = 'true';

      inputRow?.classList.remove('hidden');
    }
  }
  setTodayMoodEditable(todayValueEl);
  setTodayMoodEditable(todayImpactEl);

  const recent = entries
    .filter(e => dateKey(new Date(e.completedAtISO)) !== todayK)
    .slice(0, 6);

  recent.forEach(entry => {
    const date = new Date(entry.completedAtISO);

    const prettyDate = date.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'numeric',
      day: 'numeric'
    });

    const val = entry.title.match(/\((.+)\)/)?.[1] || '?';
    const pts = entry.points;

    const block = document.createElement('div');
    block.className = 'mood-chip cursor-pointer';

    block.innerHTML = `
      <div class="mood-chip-date">${prettyDate}</div>
      <div class="mood-chip-value">${val}</div>
      <div class="mood-chip-pts">${pts} pts</div>
    `;

    block.onclick = () => {
      const newVal = prompt("Edit mood score:", val);
      if (!newVal && newVal !== "0") return;

      const num = Number(newVal);
      if (isNaN(num)) return alert("Invalid number.");

      entry.title = `Mood Score (${num})`;
      entry.points = num;

      save();
      renderAll();
    };

    container.appendChild(block);
  });
}


function addTask(){
  const title = $('titleInput').value.trim();
  if(!title) return alert('Enter a task name');

  const mode = $('repeatInput').value || 'none';
  const rec = { mode };

  // Parse tags from the tags input (comma-separated)
  const rawTags = ($('tagsInput')?.value || '');
  const tags = rawTags
    .split(',')
    .map(s => s.trim())
    .filter(s => s.length > 0);

  if (mode === 'custom') {
    const countRaw = $('repeatCustomCount')?.value;
    const unitRaw  = $('repeatCustomUnit')?.value;
    let count = parseInt(countRaw, 10);
    if (!Number.isFinite(count) || count <= 0) count = 1;
    const unit = (unitRaw === 'week' || unitRaw === 'month' || unitRaw === 'year') ? unitRaw : 'day';
    rec.customCount = count;
    rec.customUnit = unit;
  }

  const task = {
    id: crypto.randomUUID(),
    title,
    importance: $('importanceInput').value,
    dueDateISO: $('dueDateInput').value || null,
    originalDueDateISO: $('dueDateInput').value || null,
    points: Number($('pointsInput').value)||0,
    recurrence: rec,
    tags,                // ‚¨Ö new
    skipDates: [],
    hidden: false,
    completedAtISO: null,
    createdAtISO: new Date().toISOString(),
    postponedDays: 0
  };


  state.tasks.unshift(task);

  save();
  clearForm();
  renderAll();

  closeAddTaskModal();
}


function setDueToday(){
  $('dueDateInput').value = todayKey();
}

function scrollToTasks(){
  const el = $('tasksAnchor');
  if (el) {
    el.scrollIntoView({
      behavior: 'smooth',
      block: 'start'
    });
  }
}

function clearForm(){
  $('titleInput').value='';
  $('pointsInput').value='';
  $('dueDateInput').value='';
  $('importanceInput').value='Medium';
  $('repeatInput').value='none';
  if ($('repeatCustomCount')) $('repeatCustomCount').value='1';
  if ($('repeatCustomUnit')) $('repeatCustomUnit').value='day';
  if ($('tagsInput')) $('tagsInput').value='';          // ‚¨Ö new
  if (repeatCustomRow) repeatCustomRow.classList.add('hidden');
}


function bumpTaskOneDay(id){
  const t = state.tasks.find(x => x.id === id);
  if (!t) return;
  bumpOneDay(t);
  save();
  renderAll();
}

function postponeTask(id){
  const t=state.tasks.find(x=>x.id===id); if(!t||!t.dueDateISO) return;
  const oldDue = t.dueDateISO;
  t.dueDateISO = todayKey();
  trackDueDatePush(t, oldDue, t.dueDateISO);
  save(); renderAll();
}
function wontDoMain(id){
  const t=state.tasks.find(x=>x.id===id); if(!t) return;
  const mode = (t.recurrence && t.recurrence.mode) || 'none';
  if(mode==='none'){
    if(!confirm('Won‚Äôt do this task? It will be removed.')) return;
    state.tasks = state.tasks.filter(x=>x.id!==id);
  }else{
    const k = t.dueDateISO || todayKey();
    t.skipDates = Array.isArray(t.skipDates)?t.skipDates:[];
    if(!t.skipDates.includes(k)) t.skipDates.push(k);
    if(t.dueDateISO===k) t.dueDateISO = todayKey();
  }
  save(); renderAll();
}

function completeTask(id){
  const t = state.tasks.find(x=>x.id===id);
  if(!t) return;
  const now = new Date().toISOString();

  // always log the completion
  addCompletion({
    id: crypto.randomUUID(),
    taskId: id,
    title: t.title,
    points: t.points,
    completedAtISO: now
  });


  const rec = t.recurrence || {};
  const mode = rec.mode || 'none';

  if (mode === 'none') {
    // one-off task ‚Üí mark completed and hide from list
    t.completedAtISO = now;
  } else {
    // repeating task ‚Üí move due date forward, keep it active
    const nextKey = computeNextDueDate(t);
    if (nextKey) t.dueDateISO = nextKey;
    t.completedAtISO = null; // keep it in the active list
  }

  save();
  renderAll();
}

function editTask(id){ editingTaskId = id; renderTasks(); }
function saveTaskEdit(id,card){
  const t=state.tasks.find(x=>x.id===id); if(!t) return;
  const titleInput=card.querySelector('input[data-field="title"]');
  const ptsInput=card.querySelector('input[data-field="points"]');
  const dueInput=card.querySelector('input[data-field="due"]');
  const impSel=card.querySelector('select[data-field="importance"]');
  const repSel=card.querySelector('select[data-field="repeat"]');
  const tagsInput=card.querySelector('input[data-field="tags"]');


  t.title = titleInput.value.trim() || t.title;
  t.points = Number(ptsInput.value)||0;
  const prevDue = t.dueDateISO;
  const dueVal = (dueInput.value||'').trim();
  t.dueDateISO = dueVal || null;
  const impVal = impSel.value;
  if(['Low','Medium','High','Critical'].includes(impVal)) t.importance = impVal;

  trackDueDatePush(t, prevDue, t.dueDateISO);

  if (tagsInput) {
    const raw = tagsInput.value || '';
    t.tags = raw
      .split(',')
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

if (repSel) {
  const mode = repSel.value || 'none';
  t.recurrence = t.recurrence || {};
  t.recurrence.mode = mode;

  if (mode === 'custom') {
    const countInput = card.querySelector('input[data-field="repeatCustomCount"]');
    const unitSel    = card.querySelector('select[data-field="repeatCustomUnit"]');
    let count = parseInt(countInput && countInput.value, 10);
    if (!Number.isFinite(count) || count <= 0) count = 1;
    const unit = (unitSel && (unitSel.value === 'week' || unitSel.value === 'month' || unitSel.value === 'year'))
      ? unitSel.value
      : 'day';
    t.recurrence.customCount = count;
    t.recurrence.customUnit  = unit;
  } else {
    // if you switch away from custom, clean it up
    delete t.recurrence.customCount;
    delete t.recurrence.customUnit;
  }
}

  editingTaskId=null;
  save(); renderAll();
}

function hideTask(id){
  const t = state.tasks.find(x => x.id === id);
  if (!t) return;
  t.hidden = true;
  save();
  renderAll();
}

function deleteTask(id){
  if(!confirm('Delete this task?')) return;
  // Remove the task itself
  state.tasks = state.tasks.filter(t => t.id !== id);
  // Do NOT touch state.completions here ‚Äì keep history/log and points
  if (editingTaskId === id) editingTaskId = null;
  save();
  renderAll();
}


/* ---------- IMPORT/EXPORT/RESET ---------- */
function exportData(){
  const snapshot = { ...state, projects: loadProjectsFromStorage() };
  const blob=new Blob([JSON.stringify(snapshot,null,2)],{type:'application/json'});
  const now = new Date();

  const y  = now.getFullYear();
  const mo = String(now.getMonth() + 1).padStart(2,'0');
  const d  = String(now.getDate()).padStart(2,'0');
  const hh = String(now.getHours()).padStart(2,'0');
  const mm = String(now.getMinutes()).padStart(2,'0');
  const ss = String(now.getSeconds()).padStart(2,'0');

  const filename = `taskpoints-backup-${y}-${mo}-${d}_${hh}-${mm}-${ss}.json`;

  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function applyImportedState(root){
  const normalized = normalizeState({
    tasks:       Array.isArray(root.tasks)       ? root.tasks       : [],
    completions: Array.isArray(root.completions) ? root.completions : [],
    players:     Array.isArray(root.players)     ? root.players     : [],
    habits:      Array.isArray(root.habits)      ? root.habits      : [],
    flexActions: Array.isArray(root.flexActions) ? root.flexActions : [],
    gameHistory: Array.isArray(root.gameHistory) ? root.gameHistory : [],
    matchups:    Array.isArray(root.matchups)    ? root.matchups    : [],
    schedule:    Array.isArray(root.schedule)    ? root.schedule    : [],
    opponentDripSchedules: Array.isArray(root.opponentDripSchedules) ? root.opponentDripSchedules : [],
    youImage:    typeof root.youImage === "string" ? root.youImage : ""
  });

  normalized.projects = Array.isArray(root.projects) ? root.projects : loadProjectsFromStorage();
  state = normalized;

  editingTaskId = null;
  editingHabitId = null;
  editingFlexId = null;

  saveProjectsToStorage(state.projects);

  save();
  renderAll();
  renderHabits();
  renderHabitWeekLabels();
  renderVices();
  renderViceWeekLabels();

  console.log("Import applied successfully, including projects.");
}

function importFile(ev){
  const f = ev.target.files?.[0];
  if (!f) return;

  const r = new FileReader();
  r.onload = () => {
    let data;
    // 1) Parse stage
    try {
      const raw = String(r.result);
      data = JSON.parse(raw);
      console.log("JSON parsed OK (file import):", data);
    } catch (err) {
      console.error("ACTUAL PARSE ERROR (file import):", err);
      alert("The file is not valid JSON. Check console for details.");
      return;
    }

    // 2) App logic stage
    try {
      const root =
        (data && Array.isArray(data.tasks) && Array.isArray(data.completions)) ? data :
        (data && data.state && Array.isArray(data.state.tasks) && Array.isArray(data.state.completions)) ? data.state :
        null;

      if (!root) {
        throw new Error("Root object missing tasks/completions arrays");
      }

      applyImportedState(root);
    } catch (logicErr) {
      console.error("LOGIC ERROR during import (file):", logicErr);
      alert("JSON was valid, but the app crashed trying to load it. Check console.");
    }
  };

  r.readAsText(f);
  ev.target.value = "";
}

function importPaste(){
  const txt = prompt("Paste TaskPoints JSON:");
  if (!txt) return;

  let data;
  // 1) Parse stage
  try {
    data = JSON.parse(txt);
    console.log("JSON parsed OK (paste):", data);
  } catch (err) {
    console.error("ACTUAL PARSE ERROR (paste):", err);
    alert("The text is not valid JSON. Check console for details.");
    return;
  }

  // 2) App logic stage
  try {
    const root =
      (data && Array.isArray(data.tasks) && Array.isArray(data.completions)) ? data :
      (data && data.state && Array.isArray(data.state.tasks) && Array.isArray(data.state.completions)) ? data.state :
      null;

    if (!root) {
      throw new Error("Root object missing tasks/completions arrays");
    }

    applyImportedState(root);
  } catch (logicErr) {
    console.error("LOGIC ERROR during import (paste):", logicErr);
    alert("JSON was valid, but the app crashed trying to load it. Check console.");
  }
}


/* ---------- RENDER/WIRE ---------- */
function renderAll(){
  try {
    renderStats();
  } catch (e) {
    console.error('renderStats error:', e);
  }

  try {
    renderTasks();
  } catch (e) {
    console.error('renderTasks error:', e);
  }

  try {
    renderSleepHistory();
  } catch (e) {
    console.error('renderSleepHistory error:', e);
  }

  try {
    renderCaloriesHistory();
  } catch (e) {
    console.error('renderCaloriesHistory error:', e);
  }

  try {
    renderWorkHistory();
  } catch (e) {
    console.error('renderWorkHistory error:', e);
  }

  try {
  renderMoodHistory();
} catch (e) {
  console.error('renderMoodHistory error:', e);
}
  }

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#039;'}[m])); }

document.addEventListener('DOMContentLoaded', () => {
  $('addBtn')?.addEventListener('click', addTask);
  $('openAddTaskBtn')?.addEventListener('click', openAddTaskModal);
  $('sortSelect')?.addEventListener('change', renderTasks);
  $('resetBtn')?.addEventListener('click', resetAll);
  $('addHabitBtn')?.addEventListener('click', addHabit);
  $('addViceBtn')?.addEventListener('click', addVice);
  $('addFlexBtn')?.addEventListener('click', addFlexAction);
  $('saveSleepScoreBtn')?.addEventListener('click', saveSleepScore);
  $('sleepEditModal')?.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeSleepEditModal();
  });
  ['sleepEditScoreInput','sleepEditRestedInput'].forEach(id => {
    $(id)?.addEventListener('keydown', e => {
      if (e.key === 'Enter') submitSleepEditModal();
    });
  });
  $('workEditModal')?.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeWorkEditModal();
  });
  ['workEditScoreInput','workEditHoursInput'].forEach(id => {
    $(id)?.addEventListener('keydown', e => {
      if (e.key === 'Enter') submitWorkEditModal();
    });
  });
  $('saveCaloriesBtn')?.addEventListener('click', saveCalories);
  $('saveWorkScoreBtn')?.addEventListener('click', saveWorkScore);
  $('saveMoodScoreBtn')?.addEventListener('click', saveMoodScore);

  const rep = $("repeatInput");
  rep?.addEventListener("change", () => syncCustomRepeatUI(rep));
  rep?.addEventListener("input",  () => syncCustomRepeatUI(rep)); // extra iOS safety
  syncCustomRepeatUI(rep); // sync once at load
  
  initCaloriesDatePicker();
  initHabitSortControl();
  renderHabitWeekLabels();
  renderViceWeekLabels();
  renderHabits();
  renderVices();
  renderFlexActions();

console.log('TaskPoints main state summary:', {
  tasks:       Array.isArray(state.tasks)       ? state.tasks.length       : 'no array',
  completions: Array.isArray(state.completions) ? state.completions.length : 'no array',
  habits:      Array.isArray(state.habits)      ? state.habits.length      : 'no array',
  flexActions: Array.isArray(state.flexActions) ? state.flexActions.length : 'no array',
  players:     Array.isArray(state.players)     ? state.players.length     : 'no array',
  gameHistory: Array.isArray(state.gameHistory) ? state.gameHistory.length : 'no array'
});

renderAll();
startOpponentDripTicker();
});


function syncCustomRepeatUI(repeatSelectEl) {
  const row = document.getElementById('repeatCustomRow');
  if (!row || !repeatSelectEl) return;

  if (repeatSelectEl.value === 'custom') row.classList.remove('hidden');
  else row.classList.add('hidden');
}

// Event delegation: works even if the Add Task UI is injected/moved for mobile modal
document.addEventListener('change', (e) => {
  const t = e.target;
  if (t && t.id === 'repeatInput') {
    syncCustomRepeatUI(t);
  }
});

</script>

<!-- EDIT SLEEP ENTRY MODAL -->
  <div
    id="sleepEditModal"
  class="fixed inset-0 z-40 hidden items-center justify-center bg-black/60"
  onclick="closeSleepEditModal()"
>
  <div
    id="sleepEditModalBody"
    class="w-full max-w-sm mx-3 rounded-2xl px-4 pb-5 pt-8 relative bg-zinc-900 text-zinc-100 text-sm"
    onclick="event.stopPropagation();"
  >
    <button
      type="button"
      class="absolute top-3 right-3 btn btn-secondary text-[11px] px-3 py-1 rounded-md"
      onclick="closeSleepEditModal()"
    >
      Close
    </button>

    <div class="flex items-start justify-between gap-3 mb-4">
      <div>
        <div class="muted text-[11px] uppercase tracking-wide">Edit Sleep</div>
        <div id="sleepEditDateLabel" class="text-base font-semibold leading-tight"></div>
      </div>
      <div class="text-2xl">üõå</div>
    </div>

    <label class="grid gap-1 text-sm font-medium">
      Sleep score (0‚Äì100)
      <input id="sleepEditScoreInput" type="number" min="0" max="100" class="input" placeholder="e.g., 95">
    </label>

    <label class="grid gap-1 text-sm font-medium mt-3">
      Rested modifier (can be negative)
      <input id="sleepEditRestedInput" type="number" class="input" placeholder="e.g., 1">
    </label>

    <div class="flex justify-end gap-2 mt-6">
      <button type="button" class="btn btn-secondary" onclick="closeSleepEditModal()">Cancel</button>
      <button type="button" id="sleepEditSaveBtn" class="btn btn-primary" onclick="submitSleepEditModal()">Save</button>
    </div>
  </div>
</div>

<!-- EDIT WORK ENTRY MODAL -->
  <div
    id="workEditModal"
  class="fixed inset-0 z-40 hidden items-center justify-center bg-black/60"
  onclick="closeWorkEditModal()"
>
  <div
    id="workEditModalBody"
    class="w-full max-w-sm mx-3 rounded-2xl px-4 pb-5 pt-8 relative bg-zinc-900 text-zinc-100 text-sm"
    onclick="event.stopPropagation();"
  >
    <button
      type="button"
      class="absolute top-3 right-3 btn btn-secondary text-[11px] px-3 py-1 rounded-md"
      onclick="closeWorkEditModal()"
    >
      Close
    </button>

    <div class="flex items-start justify-between gap-3 mb-4">
      <div>
        <div class="muted text-[11px] uppercase tracking-wide">Edit Work</div>
        <div id="workEditDateLabel" class="text-base font-semibold leading-tight"></div>
      </div>
      <div class="text-2xl">üíº</div>
    </div>

    <label class="grid gap-1 text-sm font-medium">
      Work score
      <input id="workEditScoreInput" type="number" class="input" placeholder="e.g., 5">
    </label>

    <label class="grid gap-1 text-sm font-medium mt-3">
      Hours (/100, negatives become 0)
      <input id="workEditHoursInput" type="number" class="input" placeholder="e.g., 0.25">
    </label>

    <div class="flex justify-end gap-2 mt-6">
      <button type="button" class="btn btn-secondary" onclick="closeWorkEditModal()">Cancel</button>
      <button type="button" id="workEditSaveBtn" class="btn btn-primary" onclick="submitWorkEditModal()">Save</button>
    </div>
  </div>
</div>

<!-- DESKTOP-ONLY ADD TASK MODAL -->
<div
  id="addTaskModal"
  class="fixed inset-0 z-40 hidden items-center justify-center bg-black/60"
>
  <div class="addTaskModalPanel w-full max-w-xl mx-4 rounded-2xl px-6 pb-6 pt-12 relative bg-zinc-900 text-zinc-100">
<button
  type="button"
  class="absolute top-4 right-4 btn btn-secondary text-xs px-3 py-1 rounded-md"
  onclick="closeAddTaskModal()"
>
  Close
</button>




    <div id="addTaskModalBody" class="grid gap-3">
      <!-- Row 1: task title -->
      <input id="titleInput" class="input" placeholder="e.g., 30-min treadmill walk">

      <!-- Row 2: priority + due date + Today -->
      <div id="addTaskRow2" class="flex flex-wrap gap-2 mt-1">
        <select id="importanceInput" class="input flex-1 min-w-[120px]">
          <option>Low</option>
          <option selected>Medium</option>
          <option>High</option>
          <option>Critical</option>
        </select>

        <input id="dueDateInput" type="date" class="input flex-1 min-w-[120px]">

        <button class="addTaskTodayBtn btn btn-ghost text-xs px-2" onclick="setDueToday()">Today</button>
      </div>

      <!-- Row 3: points + repeat rule -->
      <div id="addTaskRow3" class="flex flex-wrap gap-2 mt-1">
        <input id="pointsInput" type="number" min="0" class="input w-24" placeholder="e.g., 25">

        <select id="repeatInput" class="input flex-1 min-w-[120px]">
          <option value="none">Does not repeat</option>
          <option value="daily">Every day</option>
          <option value="weekdays">Weekdays (Mon‚ÄìFri)</option>
          <option value="weekly">Every week</option>
          <option value="monthly">Every month (same date)</option>
          <option value="yearly">Every year (same date)</option>
          <option value="custom">Custom‚Ä¶</option>
        </select>
      </div>

      <!-- Custom repeat controls (hidden unless "Custom" selected) -->
      <div id="repeatCustomRow" class="flex items-center gap-2 text-xs mt-2 hidden">
        <span class="muted">Repeat every</span>
        <input id="repeatCustomCount" type="number" min="1" class="input w-16" value="1">
        <select id="repeatCustomUnit" class="input w-24">
          <option value="day">day(s)</option>
          <option value="week">week(s)</option>
          <option value="month">month(s)</option>
          <option value="year">year(s)</option>
        </select>
      </div>

      <!-- ‚úÖ Row 4: tags -->
      <input
        id="tagsInput"
        class="input"
        placeholder="Tags (e.g., work, coding, creative)"
      >

      <button id="addBtn" class="btn btn-primary">Add Task</button>
    </div>
  </div>
</div>


<!-- MOBILE SCROLL-TO-TOP BUTTON -->
<button
  id="scrollTopBtn"
  class="hidden md:hidden fixed top-3 right-3 z-40 btn btn-teal rounded-full shadow-lg px-4 py-2 text-sm flex items-center gap-1"
  type="button"
  data-scroll-top
>
  <span>‚¨ÜÔ∏è</span>
  <span>Top</span>
</button>

<!-- MOBILE QUICK NAV BAR -->
<nav
  id="mobileBottomNav"
  class="mobile-bottom-nav-shell fixed inset-x-0 bottom-0 z-40 md:hidden border-t border-slate-800 backdrop-blur text-slate-100 drop-shadow-sm"
  style="background: linear-gradient(180deg, #0f4d4d, #0a2f2f);">
  <div class="max-w-6xl mx-auto flex justify-center py-3 pb-4 text-[11px] mobile-bottom-nav">

    <a href="#sleepAnchor" class="flex flex-col items-center gap-0.5 opacity-80 hover:opacity-100">
      <span class="text-lg">üí§</span>
      <span class="uppercase tracking-wide text-[10px]">Sleep</span>
    </a>

    <a href="#habitsAnchor" class="flex flex-col items-center gap-0.5 opacity-80 hover:opacity-100">
      <span class="text-lg">üîó</span>
      <span class="uppercase tracking-wide text-[10px]">Habits</span>
    </a>

    <!-- TASKS moved to the middle with submenu -->
    <div class="mobile-task-dropdown">
      <button
        id="mobileTasksToggle"
        type="button"
        class="flex flex-col items-center gap-0.5 opacity-80 hover:opacity-100">
        <span class="text-lg">‚úîÔ∏è</span>
        <span class="uppercase tracking-wide text-[10px]">Tasks</span>
      </button>

      <div id="mobileTasksMenu" class="mobile-task-menu hidden">
        <button type="button" id="mobileAddTaskBtn" class="btn btn-teal btn-toolbar w-full">Add a Task</button>
        <button type="button" id="mobileGoTasksBtn" class="btn btn-teal btn-toolbar w-full">Go To Tasks</button>
      </div>
    </div>

    <a href="#vicesAnchor" class="flex flex-col items-center gap-0.5 opacity-80 hover:opacity-100">
      <span class="text-lg">üíÄ</span>
      <span class="uppercase tracking-wide text-[10px]">Vices</span>
    </a>

    <a href="#flexAnchor" class="flex flex-col items-center gap-0.5 opacity-80 hover:opacity-100">
      <span class="text-lg">üåÄ</span>
      <span class="uppercase tracking-wide text-[10px]">Flex</span>
    </a>

  </div>
</nav>

<script>
  (() => {
    const toggle = document.getElementById('mobileTasksToggle');
    const menu = document.getElementById('mobileTasksMenu');
    const addBtn = document.getElementById('mobileAddTaskBtn');
    const goBtn = document.getElementById('mobileGoTasksBtn');

    if (!toggle || !menu) return;

    const closeMenu = () => menu.classList.add('hidden');

    toggle.addEventListener('click', (e) => {
      e.preventDefault();
      menu.classList.toggle('hidden');
    });

    document.addEventListener('pointerdown', (e) => {
      if (menu.classList.contains('hidden')) return;
      if (e.target.closest('.mobile-task-dropdown')) return;
      closeMenu();
    });

    addBtn?.addEventListener('click', () => {
      closeMenu();
      openAddTaskModal?.();
    });

    goBtn?.addEventListener('click', () => {
      closeMenu();
      document.getElementById('tasksAnchor')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
    });

    window.addEventListener('resize', () => {
      if (window.innerWidth >= 768) closeMenu();
    });

    // Open on keyboard activation (Enter/Space)
    toggle.addEventListener('keyup', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        menu.classList.toggle('hidden');
      }
    });
  })();
</script>

<script>
  (() => {
    const nav = document.getElementById('mobileBottomNav');
    const isMobile = window.matchMedia('(max-width: 768px)');

    // Only run on browsers that expose the visual viewport (mobile Safari/Chrome)
    if (!nav || !window.visualViewport) return;

    function updateNavOffset() {
      // Skip adjustments on desktop sizes
      if (!isMobile.matches) {
        nav.style.transform = '';
        return;
      }

      const vv = window.visualViewport;

      // When the mobile keyboard opens, visualViewport.height shrinks.
      // Using only the height delta keeps the bar anchored even while the
      // viewport is scrolled (offsetTop can fluctuate as you pan around).
      const layoutHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
      const keyboardLift = Math.max(0, layoutHeight - vv.height);

      if (keyboardLift > 0) {
        // Translate the bar downward by the keyboard height so it stays docked at the page bottom
        nav.style.transform = `translateY(${keyboardLift}px)`;
      } else {
        nav.style.transform = '';
      }
    }

    window.visualViewport.addEventListener('resize', updateNavOffset);
    window.visualViewport.addEventListener('scroll', updateNavOffset);
    window.addEventListener('orientationchange', updateNavOffset);

    updateNavOffset();
  })();
</script>


</body>
</html>
