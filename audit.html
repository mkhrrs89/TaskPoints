<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TaskPoints — Audit</title>

  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%230a2f2f'/><text x='50' y='60' font-size='48' text-anchor='middle' fill='white'>TP</text></svg>">

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles.css">
  <script src="toolbar.js" defer></script>
  <script src="scoring_core.js"></script>
</head>
<body class="min-h-screen">
  <div class="mx-auto max-w-6xl p-4 sm:p-6 pb-20 md:pb-10">

    <div class="flex items-center justify-between gap-3 mb-3 md:hidden">
      <a href="index.html" class="flex items-center gap-3">
        <img src="assets/taskpoints-logo.png" alt="TaskPoints logo" class="w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm">
        <h1 class="text-2xl font-extrabold tracking-tight leading-tight">
          <span style="color:#fb923c;">Task</span><span style="color:#1e666d;">Points</span>
        </h1>
      </a>
      <div class="flex items-center gap-2">
        <button type="button" class="btn btn-ghost btn-toolbar" data-export-button>Export</button>
        <label class="btn btn-ghost btn-toolbar cursor-pointer">
          <span>Import</span>
          <input type="file" accept="application/json" class="hidden" data-import-input/>
        </label>
      </div>
    </div>

    <!-- HEADER -->
    <header class="mb-4">
      <div class="row items-center">
        <div class="flex items-center gap-3">
          <img src="assets/taskpoints-logo.svg" alt="TaskPoints logo" class="hidden md:block w-10 h-10 rounded-2xl object-cover shrink-0 shadow-sm">
          <h1 class="text-2xl sm:text-3xl font-extrabold tracking-tight page-title">Audit</h1>
        </div>

        <div class="toolbar header-nav">
          <a href="index.html"         class="btn btn-teal btn-toolbar nav-btn">Main</a>
          <a href="today.html" class="btn btn-teal btn-toolbar nav-btn">Today</a>
          <a href="daily_sources.html" class="btn btn-teal btn-toolbar nav-btn">Sources</a>
          <a href="log.html"           class="btn btn-teal btn-toolbar nav-btn">Log</a>
          <a href="week.html"          class="btn btn-teal btn-toolbar nav-btn">Week</a>

          <div class="dropdown">
            <button type="button" class="btn btn-teal btn-toolbar nav-btn dropdown-toggle" data-dropdown-toggle aria-expanded="false">
              Game <span class="caret">▾</span>
            </button>
            <div class="dropdown-menu">
              <a href="gamehub.html" class="btn btn-teal btn-toolbar nav-btn">Game Hub</a>
              <a href="game.html"         class="btn btn-teal btn-toolbar nav-btn">Players</a>
              <a href="standings.html"    class="btn btn-teal btn-toolbar nav-btn">Standings</a>
              <a href="matchups.html"     class="btn btn-teal btn-toolbar nav-btn">Matchups</a>
              <a href="schedule.html"     class="btn btn-teal btn-toolbar nav-btn">Schedule</a>
              <a href="game_ratings.html" class="btn btn-teal btn-toolbar nav-btn">Ratings</a>
              <a href="records.html"      class="btn btn-teal btn-toolbar nav-btn">Records</a>
            </div>
          </div>

          <a href="projects.html" class="btn btn-teal btn-toolbar nav-btn">Projects</a>
          <a href="settings.html" class="btn btn-teal btn-toolbar nav-btn">Settings</a>
        </div>
      </div>
    </header>

    <main class="space-y-4">
      <div class="glass space-y-3">
        <div class="flex flex-wrap items-center gap-3 justify-between">
          <div>
            <div class="text-lg font-semibold">Single-Day Audit</div>
            <div class="muted text-sm">Re-run TaskPoints math for one day without mutating data.</div>
          </div>
          <div class="flex items-center gap-2 flex-wrap">
            <label class="text-xs muted">Date</label>
            <input id="auditDate" type="date" class="input w-40" />
            <button id="runAuditBtn" type="button" class="btn btn-teal">Run Audit</button>
          </div>
        </div>
        <div class="flex flex-wrap gap-2">
          <button id="syncMatchupsBtn" type="button" class="btn btn-ghost">Sync Matchups</button>
          <button id="copyReportBtn" type="button" class="btn btn-ghost" data-require-click="true">Copy Report</button>
          <button id="exportJsonBtn" type="button" class="btn btn-ghost">Export JSON</button>
        </div>
      </div>

      <div class="glass space-y-3">
        <div class="flex items-center justify-between gap-2 flex-wrap">
          <div>
            <div class="text-lg font-semibold">Summary</div>
            <div id="auditSummaryMeta" class="muted text-sm">Select a date to begin.</div>
          </div>
          <div id="auditStatusBadge" class="tag bg-zinc-700/70 text-sm">Idle</div>
        </div>
        <div id="auditHighlights" class="grid sm:grid-cols-3 gap-3"></div>
      </div>

      <div class="glass">
        <div class="flex items-center justify-between mb-3">
          <div class="text-lg font-semibold">Checks</div>
          <div id="auditDateLabel" class="muted text-sm"></div>
        </div>
        <div id="auditChecks" class="space-y-2 max-h-[65vh] overflow-y-auto pr-1"></div>
      </div>
    </main>
  </div>

  <button
    class="hidden md:hidden fixed top-3 right-3 z-40 btn btn-teal rounded-full shadow-lg px-4 py-2 text-sm flex items-center gap-1"
    type="button"
    data-scroll-top
  >
    <span>⬆️</span>
    <span>Top</span>
  </button>

  <script>
    const $ = (id) => document.getElementById(id);

    function defaultAuditDate() {
      const d = new Date();
      d.setDate(d.getDate() - 1);
      return TaskPointsCore.dateKey(d);
    }

    function setStatus(label, tone = 'idle') {
      const badge = $('auditStatusBadge');
      if (!badge) return;
      badge.textContent = label;
      badge.className = 'tag text-sm';
      if (tone === 'pass') badge.classList.add('bg-emerald-700/80');
      else if (tone === 'fail') badge.classList.add('bg-rose-700/80');
      else if (tone === 'warn') badge.classList.add('bg-amber-600/80');
      else badge.classList.add('bg-zinc-700/70');
    }

    function summarizeChecks(checks) {
      const counts = { PASS: 0, FAIL: 0, WARN: 0 };
      checks.forEach(c => {
        if (counts[c.status] != null) counts[c.status]++;
      });
      return counts;
    }

    function renderHighlights(checks, totals) {
      const wrap = $('auditHighlights');
      if (!wrap) return;

      const counts = summarizeChecks(checks);
      const cards = [
        { label: 'Checks Passed', value: counts.PASS, tone: 'text-emerald-400' },
        { label: 'Warnings', value: counts.WARN, tone: 'text-amber-300' },
        { label: 'Failures', value: counts.FAIL, tone: 'text-rose-300' },
      ];

      wrap.innerHTML = cards.map(c => `
        <div class="rounded-xl border border-zinc-800/60 bg-white/5 dark:bg-zinc-900/40 p-3">
          <div class="muted text-[11px] uppercase tracking-wide">${c.label}</div>
          <div class="text-3xl font-extrabold ${c.tone}">${c.value}</div>
        </div>
      `).join('');
    }

    function renderChecks(checks, dateKeyStr) {
      const list = $('auditChecks');
      const dateLabel = $('auditDateLabel');
      if (dateLabel) {
        const nice = TaskPointsCore.niceDate(TaskPointsCore.fromKey(dateKeyStr));
        dateLabel.textContent = nice;
      }
      if (!list) return;
      if (!checks.length) {
        list.innerHTML = '<div class="muted text-sm">Run the audit to see results.</div>';
        return;
      }

      list.innerHTML = checks.map(c => {
        const icon = c.status === 'PASS' ? '✅' : c.status === 'WARN' ? '⚠️' : '❌';
        const trace = c.trace ? `<div class="muted text-[11px]">${c.trace}</div>` : '';
        const delta = Number.isFinite(c.delta) ? `<div class="muted text-[11px]">Δ ${c.delta.toFixed(2)}</div>` : '';
        const tips = c.tips ? `<div class="muted text-[11px] mt-1">${c.tips}</div>` : '';
        const expectation = (c.expected !== undefined || c.actual !== undefined)
          ? `<div class="text-xs font-mono bg-zinc-900/50 rounded-lg p-2 mt-2">
              <div>Expected: <span class="font-semibold">${formatVal(c.expected)}</span></div>
              <div>Actual: <span class="font-semibold">${formatVal(c.actual)}</span></div>
            </div>`
          : '';

        const details = c.details && c.details.length
          ? `<ul class="text-xs list-disc ml-5 mt-2 space-y-1">${c.details.map(d => `<li>${d}</li>`).join('')}</ul>`
          : '';

        return `
          <div class="border border-zinc-800/70 rounded-xl p-3 bg-white/5 dark:bg-zinc-900/50">
            <div class="flex items-center justify-between gap-3">
              <div class="flex items-center gap-2">
                <span class="text-xl">${icon}</span>
                <div>
                  <div class="font-semibold">${c.title}</div>
                  ${trace}
                </div>
              </div>
              <div class="text-xs px-2 py-1 rounded-full ${badgeClass(c.status)}">${c.status}</div>
            </div>
            ${delta}
            ${expectation}
            ${details}
            ${tips}
          </div>
        `;
      }).join('');
    }

    function badgeClass(status) {
      if (status === 'PASS') return 'bg-emerald-700/70';
      if (status === 'WARN') return 'bg-amber-700/70';
      return 'bg-rose-700/70';
    }

    function formatVal(v) {
      if (v === undefined) return '—';
      if (typeof v === 'number') return v.toFixed(2);
      if (typeof v === 'object') return JSON.stringify(v);
      return String(v);
    }

    const round2 = n => Math.round((Number(n) || 0) * 100) / 100;

    function formatRecord(rec){
      if (!rec) return '0-0';
      return rec.ties ? `${rec.wins}-${rec.losses}-${rec.ties}` : `${rec.wins}-${rec.losses}`;
    }

    function formatWinLoss(rec){
      if (!rec) return '0-0';
      return `${rec.wins}-${rec.losses}`;
    }

    function isPlayerActive(player) {
      return !!player && player.active !== false;
    }

    function activePlayerIds(state) {
      const ids = new Set(['YOU']);
      (state.players || []).forEach(player => {
        if (player && player.id && isPlayerActive(player)) ids.add(player.id);
      });
      return ids;
    }

    function computeStandingsRecord(state, playerId, activeIds) {
      const record = window.TaskPointsCore?.computeRecord
        ? TaskPointsCore.computeRecord(state, playerId, { includeToday: false, allowFallback: false })
        : { wins: 0, losses: 0, games: 0, source: 'unknown' };

      if (record.source === 'matchups') {
        return { wins: record.wins, losses: record.losses, source: 'matchups' };
      }

      if (playerId === 'YOU') {
        if (!state || !Array.isArray(state.completions) || !state.completions.length) {
          return { wins: 0, losses: 0, source: 'completions' };
        }

        const dayMap = {};
        state.completions.forEach(c => {
          const day = (window.TaskPointsCore && typeof TaskPointsCore.dateKey === 'function')
            ? TaskPointsCore.dateKey(c.completedAtISO || c.dateKey)
            : (c.dateKey || '');
          if (!day) return;
          const pts = window.TaskPointsCore?.pointsForCompletion
            ? TaskPointsCore.pointsForCompletion(c)
            : Number(c.points || 0);
          if (!dayMap[day]) dayMap[day] = 0;
          dayMap[day] += pts;
        });

        const dailyTotals = Object.values(dayMap);
        if (!dailyTotals.length) {
          return { wins: 0, losses: 0, source: 'completions' };
        }

        const avgPPD = dailyTotals.reduce((sum, v) => sum + v, 0) / dailyTotals.length;
        let wins = 0;
        let losses = 0;
        dailyTotals.forEach(total => {
          if (total > avgPPD) wins++;
          else losses++;
        });
        return { wins, losses, source: 'completions' };
      }

      const gameHistory = Array.isArray(state.gameHistory) ? state.gameHistory : [];
      const players = Array.isArray(state.players) ? state.players : [];
      const player = players.find(p => p && p.id === playerId);
      const baseline = typeof player?.baseline === 'number' ? player.baseline : (Number(player?.baseline) || 0);

      let wins = 0;
      let losses = 0;

      gameHistory.forEach(entry => {
        if (!entry || entry.playerId !== playerId) return;
        if (!activeIds.has(entry.playerId)) return;
        if (!baseline) return;
        const score = typeof entry.score === 'number' ? entry.score : (Number(entry.score) || 0);
        if (score >= baseline) wins++;
        else losses++;
      });

      return { wins: record.wins || wins, losses: record.losses || losses, source: 'gameHistory' };
    }

    // More reliable tap handling on mobile: fire on pointerdown and
    // ignore the synthetic click that follows.
    function bindPress(id, handler) {
      const el = $(id);
      if (!el) return;
      const requireClick = el.dataset.requireClick === 'true';
      if (!requireClick) {
        el.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          handler(e);
          el.dataset.ignoreClick = '1';
          setTimeout(() => delete el.dataset.ignoreClick, 300);
        });
      }
      el.addEventListener('click', (e) => {
        if (el.dataset.ignoreClick) return;
        handler(e);
      });
    }

    function matchupDateKey(m) {
      if (!m) return '';
      return m.dateKey || m.date || (m.dateISO ? TaskPointsCore.dateKey(m.dateISO) : '');
    }

    function computeYouDisplayScore(state, dateKeyStr){
      const { dailyTotals } = TaskPointsCore.aggregateCompletionsByDate(state.completions || [], state);
      const { todayPoints } = TaskPointsCore.deriveTodayWithInertia(dailyTotals, dateKeyStr, state);
      return Number.isFinite(todayPoints) ? Math.round(todayPoints * 10) / 10 : null;
    }

    function findOpponentDripSchedule(state, dateKeyStr, playerId, totalPoints){
      const schedules = Array.isArray(state.opponentDripSchedules) ? state.opponentDripSchedules : [];
      const totalRounded = Math.max(0, Math.round((Number(totalPoints) || 0) * 10) / 10);
      return schedules.find(s =>
        s && s.date === dateKeyStr && s.playerId === playerId
        && Math.abs((s.total || 0) - totalRounded) < 0.001
        && Array.isArray(s.events) && s.events.length
      ) || null;
    }

    function accruedOpponentPoints(schedule, now = new Date()){
      if (!schedule) return 0;
      const events = Array.isArray(schedule.events) ? schedule.events.slice() : [];
      events.sort((a, b) => new Date(a.t) - new Date(b.t));

      const nowMs = now.getTime();
      const total = Math.max(0, Number(schedule.total) || 0);

      if (!events.length) return total;

      const firstMs = new Date(events[0].t).getTime();
      const lastMs = new Date(events[events.length - 1].t).getTime();

      if (Number.isFinite(firstMs) && nowMs < firstMs) return 0;
      if (Number.isFinite(lastMs) && nowMs >= lastMs) return total;

      let accruedUnits = 0;
      events.forEach(e => {
        const when = new Date(e.t).getTime();
        const pts = Math.round((Number(e.pts) || 0) * 10);
        if (Number.isFinite(when) && nowMs >= when) {
          accruedUnits += Math.max(0, pts);
        }
      });

      const capped = Math.min(total * 10, accruedUnits);
      return Math.max(0, capped / 10);
    }

    function visibleOpponentScoreForMatchup(state, dateKeyStr, playerId, targetTotal){
      const schedule = findOpponentDripSchedule(state, dateKeyStr, playerId, targetTotal);
      if (!schedule) {
        return { score: Math.max(0, Number(targetTotal) || 0), hasSchedule: false };
      }
      return { score: accruedOpponentPoints(schedule, new Date()), hasSchedule: true };
    }

    function computeHomeMatchupScores(state, dateKeyStr){
      const matchups = Array.isArray(state.matchups) ? state.matchups : [];
      const matchup = matchups.find(m =>
        m && matchupDateKey(m) === dateKeyStr && (m.playerAId === 'YOU' || m.playerBId === 'YOU')
      );
      if (!matchup) {
        return { issues: ['No matchup found for date.'] };
      }

      const youScore = computeYouDisplayScore(state, dateKeyStr);
      const oppId = matchup.playerAId === 'YOU' ? matchup.playerBId : matchup.playerAId;
      const oppTarget = matchup.playerAId === oppId ? Number(matchup.scoreA) : Number(matchup.scoreB);
      const oppResult = visibleOpponentScoreForMatchup(state, dateKeyStr, oppId, oppTarget);

      const issues = [];
      if (!Number.isFinite(youScore)) issues.push('Missing your score.');
      if (!Number.isFinite(oppTarget)) issues.push('Missing opponent target score.');
      if (!oppResult.hasSchedule) issues.push('Opponent drip schedule missing.');

      return {
        youScore,
        oppScore: Number.isFinite(oppResult.score) ? Math.round(oppResult.score * 10) / 10 : null,
        oppId,
        issues
      };
    }

    function computeGamehubMatchupScores(state, dateKeyStr){
      const matchups = Array.isArray(state.matchups) ? state.matchups : [];
      const matchup = matchups.find(m =>
        m && matchupDateKey(m) === dateKeyStr && (m.playerAId === 'YOU' || m.playerBId === 'YOU')
      );
      if (!matchup) {
        return { issues: ['No matchup found for date.'] };
      }

      const youScore = computeYouDisplayScore(state, dateKeyStr);
      const oppId = matchup.playerAId === 'YOU' ? matchup.playerBId : matchup.playerAId;
      const oppTarget = matchup.playerAId === oppId ? Number(matchup.scoreA) : Number(matchup.scoreB);
      const oppResult = visibleOpponentScoreForMatchup(state, dateKeyStr, oppId, oppTarget);

      const issues = [];
      if (!Number.isFinite(youScore)) issues.push('Missing your score.');
      if (!Number.isFinite(oppTarget)) issues.push('Missing opponent target score.');
      if (!oppResult.hasSchedule) issues.push('Opponent drip schedule missing.');

      return {
        youScore,
        oppScore: Number.isFinite(oppResult.score) ? Math.round(oppResult.score * 10) / 10 : null,
        oppId,
        issues
      };
    }

    function runAudit() {
      const dateInput = $('auditDate');
      const selected = dateInput?.value || defaultAuditDate();
      const dateKey = TaskPointsCore.dateKey(selected);

      const { state, storageKeysFound } = TaskPointsCore.loadAppState();
      const snapshot = TaskPointsCore.buildDaySnapshot(dateKey, state);
      const totals = TaskPointsCore.computeDayTotals(snapshot);
      const rollups = TaskPointsCore.buildRollups(state);
      const dayBreakdowns = TaskPointsCore.buildDailyBreakdowns(state);
      const leaderboards = TaskPointsCore.computeLeaderboards(state);
      const dayCompletions = (state.completions || []).filter(c => {
        if (!c || !c.completedAtISO) return false;
        return TaskPointsCore.dateKey(c.completedAtISO) === dateKey;
      });

      const baseActual = Number(rollups.dailyTotals[dateKey]) || 0;
      const { inertia } = TaskPointsCore.computeInertia(rollups.dailyTotals, dateKey);
      const actualTotal = Math.round((baseActual + (Number.isFinite(inertia) ? inertia : 0)) * 10) / 10;

      const dayBreak = dayBreakdowns[dateKey] || { total: 0, categories: {} };

      const checks = [];

      const logTotal = round2((Number(snapshot.baseTotal) || 0) + (Number(snapshot.inertia) || 0));
      const sourcesTotal = round2(Number(dayBreak.total) || 0);
      const mainTotal = round2(Number(actualTotal) || 0);
      const totalDeltas = [
        { label: 'Log vs Sources', delta: logTotal - sourcesTotal },
        { label: 'Log vs Main', delta: logTotal - mainTotal },
        { label: 'Sources vs Main', delta: sourcesTotal - mainTotal }
      ];
      const maxDelta = Math.max(...totalDeltas.map(d => Math.abs(d.delta)));
      const totalIssues = totalDeltas
        .filter(d => Math.abs(d.delta) > 0.05)
        .map(d => `${d.label}: Δ ${d.delta.toFixed(2)}`);
      checks.push({
        id: 'daily-total-parity',
        title: 'Daily totals align across Log/Sources/Main',
        status: maxDelta <= 0.05 ? 'PASS' : 'FAIL',
        expected: 'Totals match within 0.05',
        actual: `Log ${logTotal.toFixed(2)} • Sources ${sourcesTotal.toFixed(2)} • Main ${mainTotal.toFixed(2)}`,
        delta: maxDelta,
        details: totalIssues,
        trace: 'log.html ↔ daily_sources.html ↔ index.html totals',
        tips: 'Recompute derived points and ensure inertia is included in all daily totals.'
      });

      // A) Daily total check
      checks.push({
        id: 'daily-total',
        title: 'Daily total matches main view',
        status: Math.abs(actualTotal - totals.total) < 0.05 ? 'PASS' : 'FAIL',
        expected: totals.total,
        actual: actualTotal,
        delta: actualTotal - totals.total,
        trace: 'aggregateCompletionsByDate → computeInertia',
        tips: 'Ensure all completions for the day have valid timestamps and points.'
      });

      // B) Category subtotals
      const categoryIssues = [];
      const expectedCategories = {};
      TaskPointsCore.CATEGORY_DEFS.forEach(def => {
        const label = def.label;
        const expectedVal = Number(totals.byCategory?.[def.key]) || 0;
        const actualVal = Number(dayBreak.categories?.[def.key]) || 0;
        expectedCategories[def.key] = expectedVal;
        if (Math.abs(expectedVal - actualVal) > 0.05) {
          categoryIssues.push(`${label}: expected ${expectedVal.toFixed(2)}, actual ${actualVal.toFixed(2)}`);
        }
      });
      const expectedInertia = Number(totals.byCategory?.inertia) || 0;
      const actualInertia = Number(dayBreak.categories?.inertia) || 0;
      if (expectedInertia || actualInertia) {
        expectedCategories.inertia = expectedInertia;
        if (Math.abs(expectedInertia - actualInertia) > 0.05) {
          categoryIssues.push(`Inertia: expected ${expectedInertia.toFixed(2)}, actual ${actualInertia.toFixed(2)}`);
        }
      }
      const expectedSum = round2(Object.values(expectedCategories || {}).reduce((s,v)=>s+v,0));
      const actualSum = round2(Number(dayBreak.total) || 0);
      if (Math.abs(expectedSum - actualSum) > 0.05) {
        categoryIssues.push(`Sum mismatch: expected ${expectedSum.toFixed(2)}, actual ${actualSum.toFixed(2)}`);
      }
      checks.push({
        id: 'category-subtotals',
        title: 'Category subtotals',
        status: categoryIssues.length ? 'FAIL' : 'PASS',
        expected: expectedCategories,
        actual: dayBreak.categories,
        delta: round2(actualSum - expectedSum),
        details: categoryIssues,
        trace: 'TaskPointsCore.computeDayTotals vs. daily breakdown'
      });

      // C) Log consistency
      const logEntries = Array.isArray(snapshot.items) ? snapshot.items.length : 0;
      const rawLogMatches = logEntries === (dayBreak.categories ? Object.values(dayBreak.categories).length : logEntries);
      const integrityNotes = [];
      snapshot.items.forEach(item => {
        if (!item.label) integrityNotes.push(`Missing label on item ${item.id}`);
        if (!Number.isFinite(item.points)) integrityNotes.push(`Non-numeric points on item ${item.id}`);
      });
      checks.push({
        id: 'log-consistency',
        title: 'Log entries align with snapshot',
        status: integrityNotes.length ? 'WARN' : 'PASS',
        expected: `${logEntries} entries`,
        actual: `${logEntries} entries`,
        delta: rawLogMatches ? 0 : NaN,
        details: integrityNotes,
        trace: 'state.completions filtered by date'
      });

      // New: Completion timestamp validity
      const timestampIssues = [];
      const allCompletions = Array.isArray(state.completions) ? state.completions : [];
      allCompletions.forEach(c => {
        if (!c) return;
        const label = c.title || c.id || c.taskId || 'unknown';
        if (!c.completedAtISO) {
          timestampIssues.push(`Completion "${label}" missing completedAtISO`);
          return;
        }
        const parsed = new Date(c.completedAtISO);
        if (!parsed || isNaN(parsed.getTime())) {
          timestampIssues.push(`Completion "${label}" has invalid completedAtISO (${c.completedAtISO})`);
        }
      });
      checks.push({
        id: 'completion-timestamps',
        title: 'Completion timestamps are valid',
        status: timestampIssues.length ? 'WARN' : 'PASS',
        expected: 'All completions have valid completedAtISO timestamps',
        actual: timestampIssues.length ? `${timestampIssues.length} issue(s)` : 'All timestamps valid',
        details: timestampIssues,
        trace: 'state.completions completedAtISO'
      });

      // New: Completion metadata health
      const metadataIssues = [];
      const completionIds = new Set();
      const duplicateCompletionIds = new Set();
      dayCompletions.forEach(c => {
        if (!c) return;
        if (!c.id) {
          metadataIssues.push(`Completion "${c.title || c.taskId || 'unknown'}" missing id`);
        } else if (completionIds.has(c.id)) {
          duplicateCompletionIds.add(c.id);
        } else {
          completionIds.add(c.id);
        }
        if ((c.source || 'task') === 'task' && !c.taskId) {
          metadataIssues.push(`Completion "${c.title || c.id || 'unknown'}" missing taskId`);
        }
      });
      if (duplicateCompletionIds.size) {
        metadataIssues.push(`Duplicate completion ids: ${Array.from(duplicateCompletionIds).join(', ')}`);
      }
      checks.push({
        id: 'completion-metadata',
        title: 'Completion metadata completeness',
        status: metadataIssues.length ? 'WARN' : 'PASS',
        expected: 'Completions include ids and task references',
        actual: metadataIssues.length ? `${metadataIssues.length} issue(s)` : 'All metadata present',
        details: metadataIssues,
        trace: 'state.completions metadata'
      });

      // New: Task linkage integrity
      const taskLinkNotes = [];
      const taskIds = new Set((state.tasks || []).map(t => t?.id).filter(Boolean));
      const completionTaskCounts = {};
      dayCompletions.forEach(c => {
        const source = c?.source || 'task';
        if (!c.taskId || source !== 'task') return;
        completionTaskCounts[c.taskId] = (completionTaskCounts[c.taskId] || 0) + 1;
        if (!taskIds.has(c.taskId)) {
          taskLinkNotes.push(`Completion ${c.id || c.taskId} references missing task ${c.taskId}`);
        }
      });
      Object.entries(completionTaskCounts).forEach(([taskId, count]) => {
        if (count > 1) {
          taskLinkNotes.push(`Task ${taskId} completed ${count} times on this day`);
        }
      });
      (state.tasks || []).forEach(t => {
        if (!t?.completedAtISO) return;
        if (TaskPointsCore.dateKey(t.completedAtISO) !== dateKey) return;
        const hasCompletion = dayCompletions.some(c => c?.taskId === t.id);
        if (!hasCompletion) {
          taskLinkNotes.push(`Task ${t.title || t.id} marked complete without a matching completion entry`);
        }
      });
      checks.push({
        id: 'task-linkage',
        title: 'Task completion links stay in sync',
        status: taskLinkNotes.length ? 'WARN' : 'PASS',
        expected: 'Tasks and completions cross-reference cleanly',
        actual: taskLinkNotes.length ? `${taskLinkNotes.length} issue(s)` : 'All linked',
        details: taskLinkNotes,
        trace: 'state.tasks ↔ state.completions'
      });

      // New: Task points match completion points (non-derived)
      const taskPointIssues = [];
      const taskById = new Map((state.tasks || []).filter(Boolean).map(t => [t.id, t]));
      dayCompletions.forEach(c => {
        if (!c || (c.source || 'task') !== 'task' || !c.taskId) return;
        const task = taskById.get(c.taskId);
        if (!task || !Number.isFinite(Number(task.points))) return;
        const derived = TaskPointsCore.deriveCompletionPoints
          ? TaskPointsCore.deriveCompletionPoints(c, state)
          : null;
        if (derived) return;

        const completionPoints = Number(c.points);
        if (!Number.isFinite(completionPoints)) return;
        const taskPoints = Number(task.points);
        const delta = completionPoints - taskPoints;
        if (Math.abs(delta) > 0.01) {
          taskPointIssues.push(`Task "${task.title || task.id}" completion ${completionPoints.toFixed(2)} vs task ${taskPoints.toFixed(2)}`);
        }
      });
      checks.push({
        id: 'task-point-alignment',
        title: 'Task points align with completions',
        status: taskPointIssues.length ? 'WARN' : 'PASS',
        expected: 'Completion points match task points when not formula-based',
        actual: taskPointIssues.length ? `${taskPointIssues.length} mismatch(es)` : 'All aligned',
        details: taskPointIssues,
        trace: 'state.tasks points vs state.completions points'
      });

      // New: Sleep/work/calories point formulas
      const formulaIssues = [];
      const formulaDebug = [];
      dayCompletions.forEach(c => {
        if (!c) return;
        const derived = TaskPointsCore.deriveCompletionPoints
          ? TaskPointsCore.deriveCompletionPoints(c)
          : null;
        if (!derived) return;

        const actualRaw = Number(c.points);
        const actual = Number.isFinite(actualRaw) ? actualRaw : 0;
        const expected = derived.points;
        const delta = actual - expected;

        if (Math.abs(delta) > 0.01) {
          const formulaName = derived.formula
            ? derived.formula.charAt(0).toUpperCase() + derived.formula.slice(1)
            : 'Derived';
          const label = `${formulaName} "${c.title || c.id}"`;
          formulaIssues.push(`${label}: expected ${expected.toFixed(2)}, got ${actual.toFixed(2)}`);
          formulaDebug.push({
            date: dateKey,
            entryId: c.id || c.taskId || c.title,
            rawInputs: derived.inputs,
            storedPoints: actual,
            derivedPoints: expected,
            delta,
            formula: derived.formula
          });
        }
      });
      if (formulaDebug.length) {
        console.warn('[TaskPoints Audit] Sleep/work formula mismatch details', formulaDebug);
      }
      checks.push({
        id: 'formula-replay',
        title: 'Sleep/work/calories points match formulas',
        status: formulaIssues.length ? 'WARN' : 'PASS',
        expected: 'Derived points align with sleep/work/calories formulas',
        actual: formulaIssues.length ? `${formulaIssues.length} mismatch(es)` : 'All aligned',
        details: formulaIssues,
        trace: 'TaskPointsCore.sleepPoints/workPoints/caloriesToPoints'
      });

      // D) Daily sources consistency
      checks.push({
        id: 'daily-sources',
        title: 'Daily sources total matches recomputed total',
        status: Math.abs((dayBreak.total || 0) - totals.total) < 0.05 ? 'PASS' : 'FAIL',
        expected: totals.total,
        actual: dayBreak.total || 0,
        delta: (dayBreak.total || 0) - totals.total,
        trace: 'daily breakdown vs. TaskPointsCore.computeDayTotals'
      });

      const roundingDelta = Math.abs((dayBreak.total || 0) - (totals.total || 0));
      checks.push({
        id: 'rounding-drift',
        title: 'Rounding drift stays under 0.01',
        status: roundingDelta <= 0.01 ? 'PASS' : 'WARN',
        expected: '≤ 0.01',
        actual: roundingDelta,
        delta: roundingDelta,
        trace: 'daily breakdown vs. TaskPointsCore.computeDayTotals',
        tips: 'Use cents rounding for totals to keep drift under a hundredth of a point.'
      });

      // New: Daily breakdown categories remain known
      const knownCategoryKeys = new Set([
        ...TaskPointsCore.CATEGORY_DEFS.map(def => def.key),
        'inertia',
      ]);
      const unknownCategoryIssues = [];
      Object.entries(dayBreak.categories || {}).forEach(([key, value]) => {
        if (!knownCategoryKeys.has(key) && Math.abs(Number(value) || 0) > 0.01) {
          unknownCategoryIssues.push(`Unknown category "${key}" has ${Number(value).toFixed(2)} points`);
        }
      });
      checks.push({
        id: 'unknown-categories',
        title: 'Daily breakdown uses known categories',
        status: unknownCategoryIssues.length ? 'WARN' : 'PASS',
        expected: 'Only defined categories have points',
        actual: unknownCategoryIssues.length ? `${unknownCategoryIssues.length} issue(s)` : 'All categories known',
        details: unknownCategoryIssues,
        trace: 'TaskPointsCore.CATEGORY_DEFS vs. daily breakdown'
      });

      // E) Records + leaderboards
      const weekKey = TaskPointsCore.isoWeekKey(TaskPointsCore.fromKey(dateKey));
      const monthKey = TaskPointsCore.monthKey(TaskPointsCore.fromKey(dateKey));
      const weekTotal = rollups.weeklyTotalsWithInertia[weekKey] || 0;
      const monthTotal = rollups.monthlyTotalsWithInertia[monthKey] || 0;
      const dayRank = leaderboards.bestDays.findIndex(r => r.key === dateKey) + 1;
      const leaderboardIssues = [];
      if (!Number.isFinite(weekTotal) || !Number.isFinite(monthTotal)) {
        leaderboardIssues.push('Week or month rollups missing.');
      }
      checks.push({
        id: 'leaderboards',
        title: 'Leaderboards / records inclusion',
        status: leaderboardIssues.length ? 'WARN' : 'PASS',
        expected: { dayRank: dayRank || '—', weekTotal, monthTotal },
        actual: { dayRank: dayRank || '—', weekTotal, monthTotal },
        delta: 0,
        details: leaderboardIssues,
        trace: 'computeLeaderboards'
      });

      // F) Record alignment (matchups vs. fallback)
      const preferredRecord = TaskPointsCore.computeRecord
        ? TaskPointsCore.computeRecord(state, 'YOU', { includeToday: false, allowFallback: false })
        : { wins: 0, losses: 0, ties: 0, games: 0, source: 'unknown' };
      const recordIssues = [];
      let recordStatus = 'PASS';
      const hasYouMatchups = Array.isArray(state.matchups)
        && state.matchups.some(m => m && (m.playerAId === 'YOU' || m.playerBId === 'YOU')
          && Number.isFinite(Number(m.scoreA)) && Number.isFinite(Number(m.scoreB)));
      if (hasYouMatchups && preferredRecord.source !== 'matchups') {
        recordStatus = 'WARN';
        recordIssues.push('Matchups exist but record is not using matchup-based results.');
      }
      checks.push({
        id: 'record-alignment',
        title: 'Record alignment (matchups vs fallback)',
        status: recordStatus,
        expected: formatRecord(preferredRecord),
        actual: formatRecord(preferredRecord),
        details: recordIssues,
        trace: `TaskPointsCore.computeRecord (${preferredRecord.source})`,
        tips: 'When matchups exist, prefer their win/loss record over daily-average fallback so views stay consistent.'
      });

      // New: standings record alignment with matchups log
      const standingsRecordIssues = [];
      const standingsRecordWarnings = [];
      const standingsExpected = {};
      const standingsActual = {};
      const activeIds = activePlayerIds(state);
      const playerRows = [
        { id: 'YOU', name: 'You' },
        ...(Array.isArray(state.players) ? state.players.filter(p => p && isPlayerActive(p)) : [])
      ];

      playerRows.forEach(player => {
        if (!player || !activeIds.has(player.id)) return;
        const standingsRecord = computeStandingsRecord(state, player.id, activeIds);
        const matchupRecord = window.TaskPointsCore?.computeMatchupRecord
          ? TaskPointsCore.computeMatchupRecord(state, player.id, { includeToday: false })
          : { wins: 0, losses: 0, games: 0 };

        const label = player.name || (player.id === 'YOU' ? 'You' : player.id);
        standingsExpected[label] = formatWinLoss(matchupRecord);
        standingsActual[label] = formatWinLoss(standingsRecord);

        if (matchupRecord.games > 0) {
          if (standingsRecord.wins !== matchupRecord.wins || standingsRecord.losses !== matchupRecord.losses) {
            standingsRecordIssues.push(
              `${label}: standings ${formatWinLoss(standingsRecord)} vs matchups ${formatWinLoss(matchupRecord)}`
            );
          }
          return;
        }

        if ((standingsRecord.wins || standingsRecord.losses)) {
          standingsRecordWarnings.push(
            `${label}: standings shows ${formatWinLoss(standingsRecord)} but no matchup games found`
          );
        }
      });

      const standingsRecordStatus = standingsRecordIssues.length
        ? 'FAIL'
        : (standingsRecordWarnings.length ? 'WARN' : 'PASS');

      checks.push({
        id: 'standings-matchup-records',
        title: 'Standings records match matchup results',
        status: standingsRecordStatus,
        expected: standingsExpected,
        actual: standingsActual,
        details: [...standingsRecordIssues, ...standingsRecordWarnings],
        trace: 'standings.html computePlayerStats vs TaskPointsCore.computeMatchupRecord',
        tips: 'If standings show fallback records, sync matchups so standings and matchup logs reflect the same win/losses.'
      });

      // New: verify your matchup scores match recomputed daily totals (with inertia)
      const youTotalsWithInertia = TaskPointsCore.youDailyTotalsWithInertia(state);
      const matchupScoreIssues = [];

      (state.matchups || []).forEach(m => {
        if (!m || (m.playerAId !== 'YOU' && m.playerBId !== 'YOU')) return;
        const key = matchupDateKey(m);
        const expectedScore = Number(youTotalsWithInertia[key]);
        if (!Number.isFinite(expectedScore)) return;

        const storedScore = m.playerAId === 'YOU' ? Number(m.scoreA) : Number(m.scoreB);
        if (!Number.isFinite(storedScore)) return;

        const delta = storedScore - expectedScore;
        if (Math.abs(delta) > 0.05) {
          const dayLabel = TaskPointsCore.niceDate(TaskPointsCore.fromKey(key));
          matchupScoreIssues.push(`${dayLabel}: stored ${storedScore.toFixed(1)}, expected ${expectedScore.toFixed(1)} (Δ ${delta.toFixed(1)})`);
        }
      });

      checks.push({
        id: 'you-matchup-scores',
        title: 'Your matchup scores match recomputed totals',
        status: matchupScoreIssues.length ? 'FAIL' : 'PASS',
        expected: 'Matchup scores sync to daily totals (incl. inertia)',
        actual: matchupScoreIssues.length ? `${matchupScoreIssues.length} mismatch(es)` : 'All synced',
        details: matchupScoreIssues,
        trace: 'TaskPointsCore.youDailyTotalsWithInertia vs. state.matchups',
        tips: 'Run matchup sync before viewing standings; mismatches here explain record/Baseline Δ drift across pages.'
      });

      const homeScores = computeHomeMatchupScores(state, dateKey);
      const hubScores = computeGamehubMatchupScores(state, dateKey);
      const scoreboardIssues = [];

      const homeIssueList = Array.isArray(homeScores.issues) ? homeScores.issues : [];
      const hubIssueList = Array.isArray(hubScores.issues) ? hubScores.issues : [];
      const scheduleMissing = [...homeIssueList, ...hubIssueList].some(issue => issue.includes('drip schedule'));

      if (Number.isFinite(homeScores.youScore) && Number.isFinite(hubScores.youScore)) {
        const delta = homeScores.youScore - hubScores.youScore;
        if (Math.abs(delta) > 0.05) {
          scoreboardIssues.push(`You score mismatch: home ${homeScores.youScore.toFixed(1)} vs hub ${hubScores.youScore.toFixed(1)} (Δ ${delta.toFixed(1)})`);
        }
      }

      if (Number.isFinite(homeScores.oppScore) && Number.isFinite(hubScores.oppScore)) {
        const delta = homeScores.oppScore - hubScores.oppScore;
        if (Math.abs(delta) > 0.05) {
          scoreboardIssues.push(`Opponent score mismatch: home ${homeScores.oppScore.toFixed(1)} vs hub ${hubScores.oppScore.toFixed(1)} (Δ ${delta.toFixed(1)})`);
        }
      }

      const scoreboardStatus = scoreboardIssues.length
        ? 'FAIL'
        : (scheduleMissing || homeIssueList.length || hubIssueList.length ? 'WARN' : 'PASS');

      checks.push({
        id: 'scoreboard-sync',
        title: 'Home vs GameHub scoreboard sync',
        status: scoreboardStatus,
        expected: {
          home: { you: homeScores.youScore, opponent: homeScores.oppScore },
          gamehub: { you: hubScores.youScore, opponent: hubScores.oppScore }
        },
        actual: {
          home: { you: homeScores.youScore, opponent: homeScores.oppScore },
          gamehub: { you: hubScores.youScore, opponent: hubScores.oppScore }
        },
        details: [...homeIssueList, ...hubIssueList, ...scoreboardIssues],
        trace: 'index.html/renderTodaysMatchup vs gamehub.html/renderTodaysMatchup',
        tips: 'Both scoreboards should show your inertia-inclusive total and the opponent drip total from the same matchup.'
      });

      // G) Game / matchup consistency (lightweight)
      const matchupOnDay = (state.matchups || []).find(m => m.date === dateKey);
      checks.push({
        id: 'game-consistency',
        title: 'Game history present for the day',
        status: matchupOnDay ? 'PASS' : 'WARN',
        expected: 'Matchup record optional',
        actual: matchupOnDay ? 'Found matchup' : 'None for this date',
        trace: 'state.matchups',
        tips: 'If games are not used, this is a warning only.'
      });

      // New: Matchup entry integrity
      const matchupIntegrityIssues = [];
      (state.matchups || []).forEach(m => {
        if (!m) return;
        const key = matchupDateKey(m);
        if (key !== dateKey) return;
        if (!m.playerAId || !m.playerBId) {
          matchupIntegrityIssues.push('Matchup missing player ids');
        }
        if (m.playerAId && m.playerBId && m.playerAId === m.playerBId) {
          matchupIntegrityIssues.push(`Matchup has duplicate player id ${m.playerAId}`);
        }
        const scoreA = Number(m.scoreA);
        const scoreB = Number(m.scoreB);
        if (!Number.isFinite(scoreA) || !Number.isFinite(scoreB)) {
          matchupIntegrityIssues.push(`Matchup scores missing/invalid (A: ${m.scoreA}, B: ${m.scoreB})`);
        }
      });
      checks.push({
        id: 'matchup-integrity',
        title: 'Matchup entries are complete',
        status: matchupIntegrityIssues.length ? 'WARN' : 'PASS',
        expected: 'Matchups include player ids and numeric scores',
        actual: matchupIntegrityIssues.length ? `${matchupIntegrityIssues.length} issue(s)` : 'All matchups complete',
        details: matchupIntegrityIssues,
        trace: 'state.matchups integrity'
      });

      // H) Data integrity
      const seenIds = new Set();
      const duplicates = [];
      snapshot.items.forEach(item => {
        if (item.id && seenIds.has(item.id)) duplicates.push(item.id);
        if (item.id) seenIds.add(item.id);
      });
      const integrityProblems = [];
      if (duplicates.length) integrityProblems.push(`Duplicate item ids: ${duplicates.join(', ')}`);
      const invalidPoints = snapshot.items.filter(it => !Number.isFinite(it.points));
      if (invalidPoints.length) integrityProblems.push(`${invalidPoints.length} item(s) have invalid points.`);
      const statusIntegrity = integrityProblems.length ? 'WARN' : 'PASS';
      checks.push({
        id: 'data-integrity',
        title: 'Data integrity checks',
        status: statusIntegrity,
        expected: 'All items valid',
        actual: integrityProblems.length ? integrityProblems.length + ' issue(s)' : 'No issues',
        details: integrityProblems,
        trace: 'Snapshot validation'
      });

      renderChecks(checks, dateKey);
      renderHighlights(checks, totals);

      const counts = summarizeChecks(checks);
      if (counts.FAIL > 0) setStatus('FAIL', 'fail');
      else if (counts.WARN > 0) setStatus('WARN', 'warn');
      else setStatus('PASS', 'pass');

      const summaryMeta = $('auditSummaryMeta');
      if (summaryMeta) {
        summaryMeta.textContent = `Storage: ${storageKeysFound.join(', ') || 'none'} · Date: ${TaskPointsCore.niceDate(TaskPointsCore.fromKey(dateKey))} · Total ${totals.total.toFixed(2)} pts`;
      }

      const reportPayload = {
        dateKey,
        snapshot,
        totals,
        checks,
        rollups,
      };
      storeLastReport(reportPayload);
    }

    function storeLastReport(data) {
      window.__taskpointsAuditReport = data;
    }

    function copyReport() {
      const data = window.__taskpointsAuditReport;
      if (!data) return alert('Run the audit first.');
      const counts = summarizeChecks(data.checks || []);
      const lines = [
        `TaskPoints Audit — ${data.dateKey}`,
        `PASS: ${counts.PASS}, WARN: ${counts.WARN}, FAIL: ${counts.FAIL}`,
        `Total: ${data.totals?.total ?? '—'} pts`,
        '',
        ...(data.checks || []).map(c => `${c.status} — ${c.title} (expected ${formatVal(c.expected)}, actual ${formatVal(c.actual)})`)
      ];
      const reportText = lines.join('\n');
      const showCopied = () => alert('Report copied to clipboard.');
      const showCopyFailed = () => alert('Unable to copy report.');
      if (navigator.clipboard?.writeText) {
        navigator.clipboard.writeText(reportText).then(showCopied).catch(() => {
          if (!fallbackCopyText(reportText)) showCopyFailed();
        });
        return;
      }
      if (!fallbackCopyText(reportText)) showCopyFailed();
    }

    function fallbackCopyText(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.top = '-1000px';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      textarea.setSelectionRange(0, textarea.value.length);
      let copied = false;
      try {
        copied = document.execCommand('copy');
      } catch (error) {
        copied = false;
      }
      document.body.removeChild(textarea);
      if (copied) {
        alert('Report copied to clipboard.');
      }
      return copied;
    }

    function exportJson() {
      const data = window.__taskpointsAuditReport;
      if (!data) return alert('Run the audit first.');
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `taskpoints-audit-${data.dateKey}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function syncMatchups() {
      if (!window.TaskPointsCore?.loadAppState) return;

      const { state } = TaskPointsCore.loadAppState();
      let nextState = state;
      let changed = false;

      if (window.TaskPointsCore?.syncDerivedPoints) {
        const derivedSync = TaskPointsCore.syncDerivedPoints(nextState);
        nextState = derivedSync.state;
        changed = changed || derivedSync.changed;
      }

      if (window.TaskPointsCore?.syncYouMatchups) {
        const matchupSync = TaskPointsCore.syncYouMatchups(nextState);
        nextState = matchupSync.state;
        changed = changed || matchupSync.changed;
      }

      if (!changed) {
        alert('Matchups already synced.');
        return;
      }

      if (window.TaskPointsCore?.mergeAndSaveState) {
        TaskPointsCore.mergeAndSaveState(nextState);
      } else {
        localStorage.setItem(TaskPointsCore.STORAGE_KEY, JSON.stringify(nextState));
      }

      alert('Matchups synced. Re-running audit.');
      runAudit();
    }

    document.addEventListener('DOMContentLoaded', () => {
      const dateInput = $('auditDate');
      if (dateInput) {
        dateInput.value = defaultAuditDate();
      }
      bindPress('runAuditBtn', runAudit);
      bindPress('syncMatchupsBtn', syncMatchups);
      bindPress('copyReportBtn', copyReport);
      bindPress('exportJsonBtn', exportJson);

      // Auto-run on load for convenience
      runAudit();
    });
  </script>
</body>
</html>
